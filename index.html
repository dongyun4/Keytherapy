<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - Ïò®ÎùºÏù∏ ÌÉÄÏûêÏó∞Ïäµ & Í≤åÏûÑ</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}


#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}


    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Noto Sans KR', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Noto Sans KR', 'Courier New', monospace;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ub20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);

      /* ‚ñº‚ñº‚ñº ÏòàÎ¨∏ ÌÖçÏä§Ìä∏ Ïä§ÌÉÄÏùº ‚ñº‚ñº‚ñº */
      --font-size-typing: 1.15rem;
      --typing-letter-spacing: 0.85px;
      --typing-word-spacing: 1.9px;
      --font-size-typing-mobile: 1.05rem;
      --typing-letter-spacing-mobile: 0.5px;
      --typing-word-spacing-mobile: 1.5px;
      
      /* ‚ñº‚ñº‚ñº ÏûÖÎ†•Ï∞Ω ÌÖçÏä§Ìä∏ Ïä§ÌÉÄÏùº (ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Ï†úÏñ¥) ‚ñº‚ñº‚ñº */
      --font-size-input: 1.13rem; /* ÏòàÎ¨∏Î≥¥Îã§ ÏïΩÍ∞Ñ ÏûëÍ≤å ÏÑ§Ï†ï */
      --letter-spacing-input: 0.4px; /* ÏòàÎ¨∏Î≥¥Îã§ ÏïΩÍ∞Ñ Ï¢ÅÍ≤å ÏÑ§Ï†ï */
      --font-size-input-mobile: 1.03rem;
      --letter-spacing-input-mobile: 0.4px;


      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;

      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);

      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd; /* LemonChiffon for light theme player block */
      --lbb-player-block-bg-pink: #ffe8f0;   /* LightPink for pink theme player block */
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);

      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;

    }
    .light-theme {
      --bg-main: #fdfaf6;
      --bg-container: #fff;
      --bg-typing-area: #f9f5f0;
      --bg-progress-bar: #c0a580;
      --bg-progress-bar-track: #ede7de;
      --text-primary: #524a42;
      --text-secondary: #756A5F;
      --accent-primary: #b89a6c;
      --accent-secondary: #c8ad82;
      --accent-active: #a88a5c;
      --accent-darker: #987b4f;
      --accent-rgb: 184, 154, 108;
      --accent-primary-rgb: 184, 154, 108;
      --input-bg: #fefcf9;
      --input-text: #4a4037;
      --input-border: #dcd3c9;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.25);
      --button-text: #4a4037;
      --button-text-on-accent: #fefcf9;
      --current-line-bg: rgba(var(--accent-rgb), 0.06);
      --current-line-text: #504840;
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.25);
      --current-line-shadow: 0 2px 8px rgba(var(--accent-rgb),0.1);
      --highlight-error: #d3546d;
      --highlight-error-bg: rgba(211, 84, 109, 0.07);
      --shadow-soft: 0 6px 20px rgba(170, 150, 130, 0.08);
      --shadow-inset: inset 0 1px 2px rgba(0,0,0,0.025);
      --shadow-button: 0 3px 8px rgba(170, 150, 130, 0.07);
      --shadow-button-hover: 0 5px 12px rgba(170, 150, 130, 0.1);
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: flex-start;
        padding-top: 3vh;
    }

    .main-content {
      max-width: 1000px;
      width: 100%; background-color: var(--bg-container);
      border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
      display: flex; flex-direction: column; overflow: hidden;
      border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
      transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out;
    }
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }
    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper .practice-mode-controls,
    body.game-mode-active .controls-and-stats-wrapper .feature-toggles,
    body.game-mode-active .controls-and-stats-wrapper #stats,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.game-mode-active .controls-and-stats-wrapper { padding-bottom: 0; }
    body.game-mode-active .settings-container { margin-bottom: 0; }
    body.game-mode-active .main-controls { justify-content: center; gap: 15px; }
    body.game-mode-active .sound-settings,
    body.game-mode-active .theme-settings { display: flex !important; margin-left: 0; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }

    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 35px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      transition: border-radius 0.3s ease;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper { padding: 25px 25px 15px; }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }
    .main-controls { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 12px; }
    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .practice-mode-controls { composes: control-button-group; flex-basis: 100%; order: 1; }
    .practice-mode-controls button { min-width: 100px; }
    .feature-toggles { composes: control-button-group; gap: 10px; justify-content: flex-start; order: 2; flex-grow: 1; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }
    .sound-settings, .theme-settings { display: flex; align-items: center; gap: 8px; order: 3; flex-shrink: 0; }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }

    #soundPackSelect, #themeSelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #soundPackSelect:focus, #themeSelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 15px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 8px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }


    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc((var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }

    .typing-line {
        width: 100%; max-width: 700px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        font-weight: 400; 
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        text-align: left;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.25s ease, color 0.25s ease, background-color 0.25s ease, box-shadow 0.25s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        display: flex;
        align-items: center;
        background-color: transparent;
        white-space: pre-wrap;
    }

    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }

    .typing-line strong {
        color: var(--current-line-typed-text);
    }

    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }

    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }

    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }

    #typing-input-field-container { 
        width: 100%;
        max-width: 700px;
        margin: 2px auto 0 auto;
        position: relative;
    }
    
    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }
    
    .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;
        
        /* ‚ñº‚ñº‚ñº ÎèÖÎ¶ΩÏ†ÅÏù∏ ÏûÖÎ†•Ï∞Ω Ïä§ÌÉÄÏùº Ï†ÅÏö© ‚ñº‚ñº‚ñº */
        font-family: var(--font-typing);
        font-size: var(--font-size-input);
        letter-spacing: var(--letter-spacing-input);
        word-spacing: var(--typing-word-spacing); /* Îã®Ïñ¥ Í∞ÑÍ≤©ÏùÄ ÏòàÎ¨∏Í≥º ÎèôÏùºÌïòÍ≤å Ïú†ÏßÄ */
        line-height: var(--line-height-typing);
        font-weight: 400;
        box-sizing: border-box;
    }

    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }
    
    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }
    
    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-input) * 1.2); /* ÏûÖÎ†•Ï∞Ω Ìè∞Ìä∏ ÌÅ¨Í∏∞Ïóê ÎßûÏ∂∞ Ïª§ÏÑú ÎÜíÏù¥ Ï°∞Ï†ï */
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: middle;
        margin-left: -1px;
    }
    
    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }

    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}


    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }

#returnToPracticeBtnGame {
  padding: 12px 24px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--accent-primary);
  border: 2px solid rgba(var(--accent-rgb), 0.4);
  background-color: transparent;
  transition: all 0.25s ease;
  box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
}

#returnToPracticeBtnGame:hover {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-active);
  box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
}
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }


#gameToggleSoundBtn {
  padding: 10px 16px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 500;
  font-size: 0.9em;
  border: 1.5px solid var(--accent-secondary);
  background-color: transparent;
  color: var(--accent-secondary);
  transition: all 0.25s ease;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: var(--shadow-button);
}

#gameToggleSoundBtn.active {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-primary);
  font-weight: 600;
}

    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
        backdrop-filter: blur(3px);
        -webkit-backdrop-filter: blur(3px);
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    .game-overlay h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin-bottom: 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .game-overlay p {
        font-size: 1.15em; color: var(--text-secondary);
        line-height: 1.65; max-width: 480px; margin-bottom: 25px;
    }
    .light-theme .game-overlay h2, .pink-theme .game-overlay h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 10px 5px;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}
      .main-controls { flex-direction: column; align-items: stretch; }
      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings { width: 100%; justify-content: center; }
      .feature-toggles button { min-width: 100px; }
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }
      
      .typing-line { 
          font-size: var(--font-size-typing-mobile); 
          letter-spacing: var(--typing-letter-spacing-mobile); 
          word-spacing: var(--typing-word-spacing-mobile); 
      }
      .fake-input-field {
          font-size: var(--font-size-input-mobile);
          letter-spacing: var(--letter-spacing-input-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-input-mobile) * 1.2); }

      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .game-overlay h2 { font-size: 1.6em; }
      .game-overlay p { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .sound-settings, .theme-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }


    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .feature-toggles button { min-width: 90px; }
      .select-label { font-size: 0.85em; }
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line { 
          font-size: calc(var(--font-size-typing-mobile) * 0.95); 
      }
      .fake-input-field {
          font-size: calc(var(--font-size-input-mobile) * 0.95);
      }

      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .game-overlay h2 { font-size: 1.4em; }
      .game-overlay p { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }

.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}

.hero-section a:hover {
  transform: scale(1.03);
}

.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}

.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}

.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}

.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}

/* --- ÏûêÎ¶¨ Ïó∞Ïäµ ÌÇ§Î≥¥Îìú Í∞ÄÏù¥Îìú Ïä§ÌÉÄÏùº --- */
/* --- ÏûêÎ¶¨ Ïó∞Ïäµ ÌÇ§Î≥¥Îìú Í∞ÄÏù¥Îìú Ïä§ÌÉÄÏùº --- */
#keyboard-guide {
    display: none; /* Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ïà®ÍπÄ */
    margin-bottom: 25px; /* ÏòàÎ¨∏Í≥º Í∞ÑÍ≤© */
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 800px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex; /* wrapperÎ•º Ï§ëÏïôÏ†ïÎ†¨ÌïòÍ∏∞ ÏúÑÌï® */
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}

/* ‚ñº‚ñº‚ñº [ÏµúÏ¢Ö ÏàòÏ†ï] ÌÇ§Îì§ÏùÑ Í∞êÏã∏Îäî wrapper Ïä§ÌÉÄÏùº ‚ñº‚ñº‚ñº */
.keys-wrapper {
    display: flex; /* ÌÇ§Îì§ÏùÑ Ï†ïÎ†¨ÌïòÍ∏∞ ÏúÑÌï® */
    width: fit-content; /* ÎÇ¥Ïö©Î¨ºÏóê ÎßûÍ≤å ÎÑàÎπÑ Ï°∞Ï†à */
}

/* ‚ñº‚ñº‚ñº [ÏµúÏ¢Ö ÏàòÏ†ï] ÏóáÍ∞àÎ¶ºÏùÑ ÏúÑÌïú spacer(Í∞ÄÏÉÅ ÏöîÏÜå) Ï∂îÍ∞Ä ‚ñº‚ñº‚ñº */
.row-2 .keys-wrapper::before,
.row-3 .keys-wrapper::before {
    content: '';
    display: block;
    flex-shrink: 0;
}
.row-2 .keys-wrapper::before {
    width: 65px; /* (ÌÇ§ ÎÑàÎπÑ 50 + Ï¢åÏö∞Ïó¨Î∞± 8) / 2 */
}
.row-3 .keys-wrapper::before {
    width: 5px; /* ÌÇ§ ÎÑàÎπÑ 50 + Ï¢åÏö∞Ïó¨Î∞± 8 */
}

.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    width: 50px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
}

.keyboard-key .key-main-char {
    font-weight: 600;
    font-size: 1.1em;
    color: var(--text-primary);
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
}

#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char { font-size: 1.2em; }

/* ‚ñº‚ñº‚ñº [ÏµúÏ¢Ö ÏàòÏ†ï] ÌäπÏàòÌÇ§ ÎÑàÎπÑ ÏÑ§Ï†ï ‚ñº‚ñº‚ñº */
.keyboard-key[data-key="shift"] { width: 87px; }
.keyboard-key[data-key="enter"] { width: 55px; }
.keyboard-key[data-key="space"] { width: 332px; }


.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.08);
}
.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}
.light-theme #keyboard-key.highlight-key,
.pink-theme #keyboard-key.highlight-key,
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}

@media (max-width: 820px) {
    #keyboard-guide { padding: 10px; }
    .keyboard-key { width: 42px; height: 42px; font-size: 0.8em; }
    .row-2 .keys-wrapper::before { width: 25px; }
    .row-3 .keys-wrapper::before { width: 50px; }
    .keyboard-key[data-key="shift"] { width: 73px; }
    .keyboard-key[data-key="enter"] { width: 73px; }
    .keyboard-key[data-key="space"] { width: 278px; }
}

@media (max-width: 480px) {
    #keyboard-guide { padding: 5px; }
    .keyboard-key { width: 28px; height: 35px; font-size: 0.7em; margin: 0 2px; border-radius: 4px;}
    .row-2 .keys-wrapper::before { width: 16px; }
    .row-3 .keys-wrapper::before { width: 32px; }
    .keyboard-key[data-key="shift"] { width: 48px; }
    .keyboard-key[data-key="enter"] { width: 48px; }
    .keyboard-key[data-key="space"] { width: 184px; }
}
</style>
</head>
<body>
  <div class="main-content-wrapper"> <div class="main-content">
    <div class="hero-section">
        <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
            <h1 class="hero-title">Key Therapy</h1>
            <p class="hero-tagline">ÍπäÏùÄ ÏàòÎ©¥Í≥º ÏßëÏ§ëÏùÑ ÏúÑÌïú<br>üéßÌÇ§Î≥¥Îìú ÌÉÄÍ±¥ ASMRüéß</p>
        </a>
    </div>
  <div class="controls-and-stats-wrapper">
    <div class="settings-container">
        <div class="main-controls">
            <div class="practice-mode-controls control-button-group">
                <button data-mode="kor"><i class="fas fa-language"></i>ÌïúÍ∏Ä Îã®Î¨∏</button>
                <button data-mode="korLong"><i class="fas fa-align-left"></i>ÌïúÍ∏Ä Ïû•Î¨∏</button>
                <button data-mode="eng"><i class="fas fa-font"></i>ÏòÅÏñ¥ Îã®Î¨∏</button>
                <button data-mode="engLong"><i class="fas fa-stream"></i>ÏòÅÏñ¥ Ïû•Î¨∏</button>
                <button id="gameModeBtn"><i class="fas fa-gamepad"></i>Í≤åÏûÑÌïòÍ∏∞</button>
            </div>
            <div class="feature-toggles control-button-group">
                <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF</button>
                <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> Ïò§ÌÉÄÏ≤¥ÌÅ¨ ON</button>
                <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> Ï∏°Ï†ï ON</button>
                <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> ÏûêÎ¶¨Ïó∞Ïäµ OFF</button>
            </div>
            <div class="sound-settings" id="soundSettingsElement">
                <label for="soundPackSelect" class="select-label" id="soundPackLabel">ÌÉÄÍ±¥Ïùå:</label>
                <select id="soundPackSelect">
                    <option value="crunchy">ÏÑúÍ±±ÏÑúÍ±±</option>
                    <option value="pebbles">Ï°∞ÏïΩÎèå</option>
                    <option value="thocky">ÎèÑÍ∞ÅÎèÑÍ∞Å</option>
                </select>
            </div>
            <div class="theme-settings" id="themeSettingsElement">
                <label for="themeSelect" class="select-label" id="themeSelectLabel">ÌÖåÎßà:</label>
                <select id="themeSelect">
                    <option value="dark">Îã§ÌÅ¨</option>
                    <option value="light">ÏïÑÏù¥Î≥¥Î¶¨</option>
                    <option value="pink">ÌïëÌÅ¨</option>
                </select>
            </div>
        </div>
    </div>
    <div id="stats">
        <span><span class="label">ÏÜçÎèÑ:</span> <span id="speedStat" class="value">0 ÌÉÄ/Î∂Ñ</span></span>
        <span><span class="label">Ï†ïÌôïÎèÑ:</span> <span id="accuracyStat" class="value">0%</span></span>
        <span><span class="label">ÌèâÍ∑†:</span> <span id="avgSpeedStat" class="value">0 ÌÉÄ/Î∂Ñ</span></span>
        <span><span class="label">ÏµúÍ≥†:</span> <span id="maxSpeedStat" class="value">0 ÌÉÄ/Î∂Ñ</span></span>
    </div>
</div>
<div class="progress-bar-container">
    <div class="progress-bar"></div>
</div>
<div class="typing-area-container">
    <div id="keyboard-guide"></div>
    <div id="line-display-area"> </div>
    <div id="typing-input-field-container">
        <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
        <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
    </div>
    <div id="upcoming-lines-area"> </div>
</div>
<div id="game-area-container">
</div>
<div id="result"></div>
</div>
</div>
  <div class="footer"> <p>¬© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> </div>

<script>
// === Ï†ÑÏó≠ Î≥ÄÏàò Î∞è ÏÑ§Ï†ï ===
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = []; // Î∂ÑÌï¥Îêú ÌòÑÏû¨ Ï§Ñ Ï†ÄÏû•

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;

let soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameOverlayEl, gameStartMessageEl, itemEffectPopupEl;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;


let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;


let currentSoundPack = 'crunchy';
const soundFiles = {
    pebbles: Array.from({length: 7}, (_, i) => `soundFiles/pebbles/pebble${i + 1}.wav`),
    crunchy: Array.from({length: 11}, (_, i) => `soundFiles/crunchy/crunchy${i + 1}.wav`),
    thocky: Array.from({length: 10}, (_, i) => `soundFiles/thocky/thocky${i + 1}.wav`)
};
let audioPool = {};
const MAX_AUDIO_OBJECTS = 8;
let audioPointer = {};

let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;

// === RAINFALL GAME MODE VARIABLES ===
let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_preferredGameLanguage = 'kor';
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: 'ÏãúÍ∞Ñ', icon: '‚è±Ô∏è' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: 'ÏÜåÎ©∏', icon: 'üí®' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: 'ÏÉùÎ™Ö', icon: '‚ù§Ô∏è' }
};
const rainfall_gameMainLevelsConfig = [
    // Level 1: Very Easy
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    // Level 2
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    // Level 3
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    // Level 4
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    // Level 5
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    // Level 6
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    // Level 7
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    // Level 8
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    // Level 9
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    // Level 10: Very Hard
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];

// === LETTER BLOCK BATTLE GAME MODE VARIABLES ===
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];

let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };

let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;

const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';

let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;


const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '‚≠ê' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: 'üî•' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '‚ùÑÔ∏è' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '‚ÜîÔ∏è' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;

let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};

// === TYPING BATTLE GAME MODE VARIABLES ===
let gb_isGameActive = false;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_preferredGameLanguage = 'kor';
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000;
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;


const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
// --- END TYPING BATTLE ---

const gameWordsKor = [
    "ÏïàÎÖï", "ÌïòÎäò", "Î∞îÎã§", "Íµ¨Î¶Ñ", "ÏÇ¨Îûë", "ÌñâÎ≥µ", "ÎØ∏ÏÜå", "Î∞îÎûå", "ÌñáÏÇ¥", "ÎÇòÎ¨¥", "ÍΩÉÏûé", "Î≥ÑÎπõ", "ÎßàÏùå", "ÏãúÍ∞Ñ", "ÏπúÍµ¨", "ÏÜåÎßù", "Í∏∞Ïñµ", "Ïù¥Ïú†", "Í≤∞Ïã¨", "ÏàúÍ∞Ñ", "Ïó¨Î¶Ñ", "Í∞ÄÏùÑ", "Í≤®Ïö∏", "Î¥ÑÎÇ†",
    "Ïù¥ÏïºÍ∏∞", "ÎÖ∏Îûò", "ÍøàÏÜç", "Ï∂îÏñµ", "ÏÑ†Î¨º", "Í∞êÏÇ¨", "Ìù¨Îßù", "Ïö©Í∏∞", "ÎØøÏùå", "ÏïΩÏÜç", "ÎØ∏Îûò", "ÌòÑÏã§", "ÏÑ∏Í≥Ñ", "Ïö∞Ï£º", "ÏûêÏó∞", "ÎèôÎ¨º", "ÏãùÎ¨º", "Ïù∏Ìòï", "Ïû•ÎÇúÍ∞ê", "Í∑∏Î¶º",
    "Í≥ºÏûê", "ÏÇ¨ÌÉï", "Ïö∞Ïú†", "ÌïôÍµê", "Í≥µÎ∂Ä", "ÎèÑÏ†Ñ", "ÏÑ±Í≥µ", "Ïã§Ìå®", "Í≥ºÏ†ï", "Í≤∞Í≥º", "ÎÖ∏Î†•", "Í≤∞Ïã§", "Ïù∏ÏÉù", "Ïó¨Ï†ï", "Î™©Ìëú", "Î∞©Ìñ•", "ÏßÄÎèÑ", "ÎÇòÏπ®Î∞ò", "Îì±ÎåÄ", "Ïó¥Ïá†",
    "Í≤åÏûÑ", "ÎÜÄÏù¥", "Ï±ÖÏÉÅ", "ÏùòÏûê", "Ïª¥Ìì®ÌÑ∞", "ÌÇ§Î≥¥Îìú", "ÎßàÏö∞Ïä§", "Î™®ÎãàÌÑ∞", "ÌîÑÎ¶∞ÌÑ∞", "Ïä§ÌîºÏª§", "Ìó§ÎìúÌè∞", "ÎßàÏù¥ÌÅ¨", "Ïπ¥Î©îÎùº", "Ìú¥ÎåÄÌè∞", "ÌÉúÎ∏îÎ¶ø", "Ï∂©Ï†ÑÍ∏∞", "Î∞∞ÌÑ∞Î¶¨",
    "ÏùåÏïÖ", "ÏòÅÌôî", "Ïó¨Ìñâ", "ÏÇ¨ÏßÑ", "Ï°∞Í∞Å", "Í±¥Ï∂ï", "ÎîîÏûêÏù∏", "Ìå®ÏÖò", "ÏöîÎ¶¨", "Ïö¥Îèô", "Ï∑®ÎØ∏", "ÎèÖÏÑú", "Í∏ÄÏì∞Í∏∞", "ÌÜ†Î°†", "Î∞úÌëú", "Í∞ïÏó∞", "ÏÑ∏ÎØ∏ÎÇò", "ÌöåÏùò", "ÏàòÏóÖ",
    "Í∞ïÏïÑÏßÄ", "Í≥†ÏñëÏù¥", "ÌñÑÏä§ÌÑ∞", "ÌÜ†ÎÅº", "ÏÉà", "Î¨ºÍ≥†Í∏∞", "Í±∞Î∂ÅÏù¥", "ÎèÑÎßàÎ±Ä", "ÏÇ¨Ïûê", "Ìò∏ÎûëÏù¥", "ÏΩîÎÅºÎ¶¨", "Í∏∞Î¶∞", "ÌïòÎßà", "ÏïÖÏñ¥", "ÌåêÎã§", "Ìé≠Í∑Ñ", "Í≥†Îûò",
    "Í≥ÑÏ†à", "ÎÇ†Ïî®", "Ïò®ÎèÑ", "ÏäµÎèÑ", "ÌÉúÌíç", "Ïû•Îßà", "ÎààÎ≥¥Îùº", "Ìè≠Ïóº", "ÌïúÌåå", "Ìô©ÏÇ¨", "ÏùºÍ∏∞", "ÏòàÎ≥¥", "Ï≤úÎë•", "Î≤àÍ∞ú", "ÏÜåÎÇòÍ∏∞", "ÏïàÍ∞ú", "Ïù¥Ïä¨",
    "Îî∏Í∏∞", "Ìè¨ÎèÑ", "ÏàòÎ∞ï", "ÏÇ¨Í≥º", "Î∞îÎÇòÎÇò", "Ïò§Î†åÏßÄ", "Í∑§", "Î†àÎ™¨", "ÏûêÎ™Ω", "ÌÇ§ÏúÑ", "ÎßùÍ≥†", "Ï≤¥Î¶¨", "Î≥µÏà≠ÏïÑ", "ÏûêÎëê", "ÏÇ¥Íµ¨", "Îß§Ïã§", "Í∞ê", "Î∞∞",
    "Ï£ºÏä§", "ÏóêÏù¥Îìú", "ÏπµÌÖåÏùº", "ÏôÄÏù∏", "Îß•Ï£º", "ÏÜåÏ£º", "ÎßâÍ±∏Î¶¨", "ÏúÑÏä§ÌÇ§", "Î≥¥ÎìúÏπ¥", "Îç∞ÌÇ¨Îùº", "ÌïòÏù¥Î≥º", "ÌÉÑÏÇ∞Ïàò",
    "ÎπÑÌñâÍ∏∞", "Í∏∞Ï∞®", "Î≤ÑÏä§", "ÌÉùÏãú", "ÏûêÏ†ÑÍ±∞", "ÏßÄÌïòÏ≤†", "Î∞∞", "ÏöîÌä∏", "ÌÅ¨Î£®Ï¶à", "Ïö∞Ï£ºÏÑ†", "Î°úÏºì", "ÎìúÎ°†", "ÏûêÎèôÏ∞®", "Ìä∏Îü≠",
    "Î≥ëÏõê", "ÏïΩÍµ≠", "ÏùòÏÇ¨", "Í∞ÑÌò∏ÏÇ¨", "ÌôòÏûê", "ÏßÑÎ£å", "Ï≤òÎ∞©", "ÏàòÏà†", "ÏûÖÏõê", "Ìá¥Ïõê", "ÏùëÍ∏âÏã§", "Íµ¨Í∏âÏ∞®", "Î∞±Ïã†", "ÎßàÏä§ÌÅ¨", "ÏÜåÎèÖÏ†ú", "Ï≤¥Ïò®Í≥Ñ", "Î∞òÏ∞ΩÍ≥†",
    "Í≥µÏõê", "ÏÇ∞Ï±Ö", "Îì±ÏÇ∞", "Ï∫†Ìïë", "ÎÇöÏãú", "ÏàòÏòÅ", "ÏÑúÌïë", "Ïä§ÌÇ§", "Í≥®ÌîÑ", "ÌÖåÎãàÏä§", "Ï∂ïÍµ¨", "ÏïºÍµ¨", "ÎÜçÍµ¨", "Î∞∞Íµ¨", "ÌÉÅÍµ¨", "Î≥ºÎßÅ",
    "Í∞ÄÏ°±", "Î∂ÄÎ™®", "ÌòïÏ†ú", "ÏûêÎß§", "ÏπúÏ≤ô", "ÏπúÍµ¨", "Ïù¥ÏõÉ", "ÎèôÎ£å", "ÏÑ†Î∞∞", "ÌõÑÎ∞∞", "Ïó∞Ïù∏", "Î∞∞Ïö∞Ïûê", "ÏïÑÍ∏∞", "Ïñ¥Î¶∞Ïù¥", "Ï≤≠ÏÜåÎÖÑ", "Ïñ¥Î•∏", "ÎÖ∏Ïù∏",
    "ÏñºÍµ¥", "Î®∏Î¶¨", "ÎààÏçπ", "ÎààÎèôÏûê", "ÏΩî", "ÏûÖÏà†", "Ïù¥Îπ®", "ÌòÄ", "ÌÑ±", "Î™©", "Ïñ¥Íπ®", "Ìåî", "ÏÜêÎ™©", "ÏÜêÍ∞ÄÎùΩ", "ÏÜêÌÜ±", "Í∞ÄÏä¥", "Î∞∞", "ÌóàÎ¶¨", "Îì±", "ÏóâÎç©Ïù¥", "Îã§Î¶¨", "Î¨¥Î¶é", "Î∞úÎ™©", "Î∞úÍ∞ÄÎùΩ",
    "Í∞êÏ†ï", "Í∏∞ÏÅ®", "Ïä¨Ìîî", "ÌôîÎÇ®", "ÎÜÄÎûå", "ÎëêÎ†§ÏõÄ", "Î∂ÄÎÅÑÎüº", "ÏßÄÎ£®Ìï®", "Ìù•ÎØ∏", "ÎßåÏ°±", "Î∂àÎßå", "ÏßàÌà¨", "Ïó∞ÎØº", "Í≥µÍ∞ê", "ÏûêÏã†Í∞ê", "ÏûêÏ°¥Í∞ê", "Ïó¥Îì±Í∞ê",
    "ÏÉâÍπî", "Îπ®Í∞ï", "Ï£ºÌô©", "ÎÖ∏Îûë", "Ï¥àÎ°ù", "ÌååÎûë", "ÎÇ®ÏÉâ", "Î≥¥Îùº", "Î∂ÑÌôç", "ÌïòÏñë", "Í≤ÄÏ†ï", "ÌöåÏÉâ", "Í∞àÏÉâ", "Í∏àÏÉâ", "ÏùÄÏÉâ", "Î¨¥ÏßÄÍ∞ú", "Îã®ÏÉâ", "ÌòºÌï©ÏÉâ",
    "Ïà´Ïûê", "ÌïòÎÇò", "Îëò", "ÏÖã", "ÎÑ∑", "Ïó¨ÏÑØ", "ÏùºÍ≥±", "Ïó¨Îçü", "ÏïÑÌôâ", "Ïó¥", "Ïä§Î¨º", "ÏÑúÎ•∏", "ÎßàÌùî", "Ïâ∞", "ÏòàÏàú", "ÏùºÌùî", "Ïó¨Îì†", "ÏïÑÌùî",
    "ÏãúÏûë", "Ï§ëÎã®", "Í≥ÑÏÜç", "Ï¢ÖÎ£å", "ÌôïÏù∏", "Ï∑®ÏÜå", "Ï†ÄÏû•", "ÏÇ≠Ï†ú", "Ìé∏Ïßë", "Í≤ÄÏÉâ", "Ï∂îÍ∞Ä", "Î≥ÄÍ≤Ω", "ÎèÑÏõÄ", "ÏïàÎÇ¥", "Í≤ΩÍ≥†", "Ïò§Î•ò", "ÏÑ±Í≥µ", "Ï†ïÎ≥¥", "Ìï≠Î™©", "Î™©Î°ù",
    "Ïú†Î¶¨", "Í∏àÏÜç", "ÎÇòÎ¨¥", "Îèå", "Ìùô", "Î¨º", "Î∂à", "Í≥µÍ∏∞", "Îπõ", "ÏÜåÎ¶¨", "ÎÉÑÏÉà", "Îßõ", "ÎäêÎÇå", "ÏÉùÍ∞Å", "Í∞êÍ∞Å", "ÏßÄÎä•", "Ï∞ΩÏùò", "ÏÉÅÏÉÅ", "ÌëúÌòÑ", "ÏòàÏà†", "Í≥ºÌïô",
    "ÏàòÌïô", "Ïó≠ÏÇ¨", "ÏßÄÎ¶¨", "ÏÇ¨Ìöå", "Í≤ΩÏ†ú", "Ï†ïÏπò", "Î≤ïÎ•†", "Ïú§Î¶¨", "Ï≤†Ìïô", "Ï¢ÖÍµê", "Ïñ∏Ïñ¥", "Î¨∏Ìïô", "ÍµêÏú°", "Ïã¨Î¶¨", "ÏùòÌïô", "Í≥µÌïô", "Í∏∞Ïà†", "Ï†ïÎ≥¥", "ÌÜµÏã†", "Ïö∞Ï£ºÏù∏", "Î∞©Ïö∏Î±Ä", "ÏÇ¨ÎßâÏó¨Ïö∞",
    "Í∞ÄÎ°úÎì±", "Í∞ÄÏúÑÏßà", "Í∞ÄÏ†ïÍµêÏÇ¨", "Í∞ÄÏ°±ÏÇ¨ÏßÑ", "Í∞ÄÏßÄÍ∞ÅÏÉâ", "Í∞àÎ¶ºÍ∏∏", "Í∞àÎ¶ºÎèå", "Í∞êÏÇ¨Ìå®", "Í∞êÏ†ïÌëúÌòÑ", "Í∞ïÍ∞ïÏà†Îûò", "Í∞úÎ∞úÏûê", "Í±∞Î∂ÅÏÑ†", "Í±¥Í∞ïÍ≤ÄÏßÑ", "Í±¥ÎÑêÎ™©", "Í≤ÄÏ†ïÍ≥†Ïãú", "Í≤∞ÌòºÍ∏∞ÎÖê", "Í≤ΩÍ∏∞Ïû•", "Í≤ΩÏ∞∞Í¥Ä", "Í≤ΩÌò∏Ïõê", "Í≥ÑÎûÄÌõÑÎùºÏù¥", "Í≥†ÏÜçÎèÑÎ°ú", "Í≥†Ïù∏Îèå", "Í≥®Î™©ÎåÄÏû•", "Í≥µÍ∏∞ÎÜÄÏù¥", "Í≥µÏ§ëÏ†ÑÌôî", "Í≥µÌú¥Ïùº", "Í≥ºÏùºÍ∞ÄÍ≤å", "Í≥ºÌïôÏÉÅÏûê", "Í¥ÄÍ¥ëÎ≤ÑÏä§", "Í¥ëÌôîÎ¨∏", "Íµ¨Í∏âÏÉÅÏûê", "Íµ≠ÌöåÏùòÏõê", "Íµ∞Í≥†Íµ¨Îßà", "Í∑∏Î¶ºÏùºÍ∏∞", "Í∑πÏû•", "Í∏∞ÎÖêÌíà", "Í∏∞ÏÉÅÏ∫êÏä§ÌÑ∞", "Í∏∞Ï∞®Ïó¨Ìñâ", "Í∏¥Í∏âÏÉÅÌô©", "ÍπÄÏû•ÎèÖ", "ÍπåÎßàÍ∑Ä", "ÍπåÏπòÎ∞•", "ÍΩÉÎã§Î∞ú", "ÍøÄÎ≤å", "ÍøàÎÇòÎùº", "ÎÅùÎßêÏûáÍ∏∞", "ÎÇòÎ¨¥ÎäòÎ≥¥", "ÎÇòÎπÑÎÑ•ÌÉÄÏù¥", "ÎÇôÌïòÏÇ∞", "ÎÇöÏãúÍæº", "ÎÇúÏÑºÏä§ÌÄ¥Ï¶à", "ÎÇ†Í∞ú", "ÎÇ®ÎåÄÎ¨∏", "ÎÇ≠Îñ†Îü¨ÏßÄ", "ÎÇ¥ÎπÑÍ≤åÏù¥ÏÖò", "ÎÉâÏû•Í≥†", "ÎÑ§ÏûéÌÅ¥Î°úÎ≤Ñ", "ÎÖ∏Îû´ÏÜåÎ¶¨", "ÎÖ∏Ìä∏Î∂Å", "ÎÜÄÏù¥Í≥µÏõê", "ÎÜçÍµ¨Í≥µ", "ÎààÏÇ¨Îûå", "Îã§Î¶¨ÎØ∏", "Îã§ÎûåÏ•ê", "Îã§Ïù¥ÏïÑÎ™¨Îìú", "Îã®ÌíçÏûé", "Îã¨Î¶¨Í∏∞", "Îã≠Íº¨Ïπò", "Îã¥Î≤ºÎùΩ", "ÎãπÍ∑º", "ÎåÄÌÜµÎ†π", "ÎåÄÌïúÎØºÍµ≠", "ÎèÑÏÑúÍ¥Ä", "ÎèÖÏàòÎ¶¨", "ÎèàÍ∞ÄÏä§", "ÎèåÍ≥†Îûò", "ÎèôÎ¨ºÏõê", "ÎëêÎ∂Ä", "ÎëêÌÜµÏïΩ", "ÎìúÎùºÏù¥Í∏∞", "Îì±ÏÇ∞Ìôî", "ÎîîÏßÄÌÑ∏Ïπ¥Î©îÎùº", "ÎùºÎ©¥", "ÎùºÎîîÏò§", "Î°úÎ¥á", "Î¶¨Î™®Ïª®", "ÎßàÎùºÌÜ§", "ÎßàÎ≤ïÏÇ¨", "ÎßåÎëê", "ÎßåÎ¶¨Ïû•ÏÑ±"
].map(word => word.trim());
const gameWordsEng = [
    "hello", "world", "galaxy", "planet", "comet", "orbit", "nebula", "quasar", "pulsar", "meteor", "asteroid", "gravity", "energy", "force", "speed", "light", "sound", "echo", "pulse", "wave", "quantum", "field", "charge",
    "nature", "animal", "plant", "flower", "river", "ocean", "beach", "coast", "forest", "jungle", "desert", "mountain", "valley", "canyon", "island", "volcano", "glacier", "meadow", "prairie", "savanna", "swamp", "marsh", "reef",
    "summer", "winter", "spring", "autumn", "season", "weather", "climate", "cloud", "storm", "breeze", "hurricane", "typhoon", "tornado", "rainbow", "sunrise", "sunset", "twilight", "day", "night", "morning", "evening", "midnight", "noon",
    "people", "person", "human", "family", "friend", "enemy", "neighbor", "stranger", "guest", "host", "child", "adult", "teenager", "baby", "woman", "man", "girl", "boy", "king", "queen", "prince", "princess", "knight",
    "school", "college", "university", "student", "teacher", "professor", "class", "grade", "exam", "test", "quiz", "score", "point", "award", "prize", "medal", "trophy", "champion", "winner", "loser", "team", "coach", "player",
    "game", "play", "sport", "match", "race", "competition", "tournament", "hobby", "music", "movie", "theater", "concert", "opera", "ballet", "dance", "song", "melody", "rhythm", "harmony", "art", "painting", "drawing", "sculpture",
    "apple", "orange", "banana", "grape", "melon", "lemon", "lime", "peach", "pear", "plum", "cherry", "berry", "strawberry", "blueberry", "raspberry", "blackberry", "kiwi", "mango", "pineapple", "coconut", "avocado", "tomato", "potato",
    "computer", "keyboard", "mouse", "monitor", "screen", "laptop", "desktop", "server", "network", "internet", "website", "software", "hardware", "program", "code", "debug", "algorithm", "database", "interface", "protocol", "security", "backup", "firewall",
    "function", "variable", "constant", "array", "object", "string", "number", "boolean", "null", "undefined", "class", "constructor", "method", "property", "module", "import", "export", "async", "await", "promise", "callback", "event", "listener",
    "system", "design", "architecture", "component", "framework", "library", "package", "version", "control", "branch", "merge", "commit", "push", "pull", "request", "issue", "bug", "feature", "release", "deploy", "build", "test", "automation"
].map(word => word.trim());


function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

const lbb_wordPool = gameWordsKor.filter(word => word.length >= 2 && word.length <= 3);
if (lbb_wordPool.length === 0) {
    console.warn("LBB: 2-3Í∏ÄÏûê Îã®Ïñ¥ ÌíÄÏù¥ ÎπÑÏñ¥ÏûàÏñ¥ Ï†ÑÏ≤¥ Îã®Ïñ¥ ÌíÄÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.");
    lbb_wordPool.push(...gameWordsKor);
}

const sentencePool = { 
    kor: ["Îî∞ÎúªÌïú ÌñáÏÇ¥Ïù¥ Ï∞ΩÍ∞ÄÏóê Í∞ÄÎìù ÎÇ¥Î¶∞Îã§.", "ÎåÄÌïúÎØºÍµ≠ ÏÑúÏö∏ÌäπÎ≥ÑÏãú ÏïÑÎ¶ÑÎã§Ïö¥ Ïö∞Î¶¨ Í∞ïÏÇ∞ Ìë∏Î•¥Í≤å Ìë∏Î•¥Í≤å."], 
    eng: ["The weather is lovely today perfect for a nice walk."], 
    korLong: [ "ÎÇ°ÏùÄ Í≥®Î™©Ïùò Ï¥àÏûÖ, ÌóàÎ¶¨ ÍµΩÏùÄ ÎÖ∏ÌååÏùò ÏÜêÍ∏∏Ïù¥ ÌñáÏÇ¥Ïóê Î∞îÎûòÏßÑ Îã¥Î≤ºÎùΩÏùÑ Ïñ¥Î£®ÎßåÏßÑÎã§. Í∑∏ÎÖÄÏùò ÏÜêÍ∞ÄÎùΩ ÎßàÎîîÎßàÎîîÏóê ÏßÄÎÇú ÏÑ∏ÏõîÏùò Ï£ºÎ¶ÑÏù¥ Í∞ïÎ¨ºÏ≤òÎüº ÏÉàÍ≤®Ï†∏ ÏûàÏóàÍ≥†, Í∑∏ ÎßàÎîî ÎÅùÏóêÏÑú Ïä§Î©∞ ÎÇòÏò® Ïù¥ÏïºÍ∏∞Îì§Ïù¥ Î¨¥ÏÑ±Ìïú Îã¥ÏüÅÏù¥Îç©Íµ¥Ï≤òÎüº Î≤ΩÏùÑ ÌúòÍ∞êÏïòÎã§."], 
    engLong: [ "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper and faint wood, a nostalgic perfume that seemed to whisper tales of bygone eras."]
};

function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}

document.addEventListener('DOMContentLoaded', () => {
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');

  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  if (![lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl].every(el => el)) {
      console.error("ÌïòÎÇò Ïù¥ÏÉÅÏùò ÌïÑÏàò HTML ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
      if (resultEl) resultEl.textContent = "ÌéòÏù¥ÏßÄ Î°úÎî© Ïò§Î•ò.";
      return;
  }

  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;

  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;

  document.getElementById('soundPackLabel').textContent = 'ÌÉÄÍ±¥Ïùå:';
  document.getElementById('themeSelectLabel').textContent = 'ÌÖåÎßà:';


  initializeAudioPool();
  buildKeyboard();

  document.querySelectorAll('.practice-mode-controls button[data-mode]').forEach(button => {
    button.addEventListener('click', function() {
      if (this.id !== 'gameModeBtn') {
        startPractice(this.dataset.mode, true);
      }
    });
  });

  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => activateGameMode('rainfall'));
  }

  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';

  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> Ï∏°Ï†ï ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Ï∏°Ï†ï OFF';
    statsEl.classList.add('hidden');
  }

  typingInputField.addEventListener('input', handleInputEvent);
  
  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }


  document.addEventListener('keydown', (e) => {
    const activeInput = document.activeElement;
    const isTypingFocusable = (currentMode !== '' || currentGameType !== '');
    const isNotInputFocused = (activeInput.tagName !== 'INPUT' && activeInput.tagName !== 'SELECT' && activeInput.tagName !== 'TEXTAREA');
    const isFocusKey = (!e.ctrlKey && !e.altKey && !e.metaKey && e.key.length === 1 && e.key !== ' ');

    if (isTypingFocusable && isNotInputFocused && isFocusKey) {
        if (currentMode === 'game' && gameInputField && !gameInputField.disabled) {
            gameInputField.focus();
        } else if (currentMode !== 'game' && typingInputField && !typingInputField.disabled) {
            typingInputField.focus();
        }
    }
  });


  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';
    }
  });

  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> Ïò§ÌÉÄÏ≤¥ÌÅ¨ ON' : '<i class="far fa-eye-slash"></i> Ïò§ÌÉÄÏ≤¥ÌÅ¨ OFF';
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl && linesToPractice[currentDisplayLineIndex] !== undefined) {
        handleHighlightUpdate(currentLineEl, typingInputField.value, linesToPractice[currentDisplayLineIndex]);
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    if (audioPool[currentSoundPack] && (audioPointer[currentSoundPack] === undefined || audioPointer[currentSoundPack] === null) ) {
        audioPointer[currentSoundPack] = 0;
    } else if (!audioPool[currentSoundPack]) {
        initializeAudioPoolForPack(currentSoundPack);
    }
  });

  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });

  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> Ï∏°Ï†ï ON' : '<i class="fas fa-eye-slash"></i> Ï∏°Ï†ï OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });

  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> ÏûêÎ¶¨Ïó∞Ïäµ ON' : '<i class="far fa-keyboard"></i> ÏûêÎ¶¨Ïó∞Ïäµ OFF';
    
    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }

    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });

  startPractice('kor', true);
});

function applyTheme(theme) {
    document.body.classList.remove('light-theme', 'pink-theme');
    if (theme === 'light') document.body.classList.add('light-theme');
    else if (theme === 'pink') document.body.classList.add('pink-theme');
    
    if (gameCanvas && currentGameType) {
        requestAnimationFrame(() => {
            if (currentGameType === 'rainfall') drawRainfallGame();
            else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
            else if (currentGameType === 'giantBattle') drawGiantBattleGame();
        });
    }
}


function initializeAudioPoolForPack(packKey) {
    if (soundFiles.hasOwnProperty(packKey) && (!audioPool[packKey] || audioPool[packKey].length === 0)) {
        audioPool[packKey] = [];
        audioPointer[packKey] = 0;
        for (let i = 0; i < MAX_AUDIO_OBJECTS; i++) {
            const audio = new Audio();
            audio.preload = 'auto';
            audioPool[packKey].push(audio);
        }
    }
}

function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}

function startPractice(mode, resetSessionStats = false) {
    if (rainfall_isGameActive || lbb_isGameActive || gb_isGameActive) returnToPracticeMode(false);
    document.body.classList.remove('game-mode-active');
    currentMode = mode;
    currentGameType = '';

    if (mainControlsEl && soundSettingsEl.parentNode !== mainControlsEl) {
        originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
    }


    if (resultEl) resultEl.textContent = 'ÏÉàÎ°úÏö¥ Î¨∏Ï†úÎ•º Î∂àÎü¨ÏòµÎãàÎã§...';
    document.querySelector('.typing-area-container').style.display = 'flex';
    if (document.getElementById('typing-input-field-container')) {
        document.getElementById('typing-input-field-container').style.display = 'block';
    }
    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
    }
    if (gameAreaContainerEl) gameAreaContainerEl.style.display = 'none';
    if (gameStartMessageEl) gameStartMessageEl.style.display = 'none';
    if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';


    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.mode === mode) btn.classList.add('active');
    });
    if (gameModeBtnEl) {
        gameModeBtnEl.innerHTML = '<i class="fas fa-gamepad"></i>Í≤åÏûÑÌïòÍ∏∞';
        gameModeBtnEl.classList.remove('active');
    }


    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }
    startTime = null;
    currentLineStartTime = null;
    currentArticleCorrectChars = 0;

    currentDisplayLineIndex = 0;
    const poolToUse = sentencePool[currentMode];
    let textToPractice = getRandom(poolToUse);
    if (!textToPractice && poolToUse && poolToUse.length > 0) textToPractice = poolToUse[0];
    if (!textToPractice) textToPractice = "ÏòàÎ¨∏ Î°úÎî©Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.";

    linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if (linesToPractice.length === 0) {
        linesToPractice.push(textToPractice.includes("Ïã§Ìå®") ? textToPractice : "ÏòàÎ¨∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
    }

    if (currentMode.includes('Long') && linesToPractice.length > 1) {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'block';
    } else {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = 'ÌÉÄÏûêÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();

    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}

function splitTextIntoLines(text, mode, screenWidth) {
    let maxLength;
    if (mode.includes('Long')) {
        if (screenWidth <= 480) maxLength = mode.includes('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.includes('eng') ? 55 : 35;
        else maxLength = mode.includes('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }

    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.includes('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}

function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';

    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();

    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.textContent = passedLineText;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);

    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');

    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        handleHighlightUpdate(currentEl, "", currentLineText);
    } else {
        currentEl.textContent = ' ';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);

    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = upcomingLineText;
            fragmentUpcoming.appendChild(upcomingEl);
        } else {
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = ' ';
            upcomingEl.style.visibility = 'hidden';
            fragmentUpcoming.appendChild(upcomingEl);
        }
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
}

function handleInputEvent(e) {
    if ((currentMode !== 'game' && e.target === typingInputField) || (currentMode === 'game' && e.target === gameInputField)) {
        playTypingSound();
    }

    if (currentMode !== 'game' && e.target === typingInputField) {
        const typedValue = typingInputField.value;
        const currentLineEl = document.getElementById('current-typing-line');
        if (!currentLineEl) return;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        handleHighlightUpdate(currentLineEl, typedValue, originalLine);
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight();
    }
}

function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;
    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">ÌÉÄÏûê Ïó∞Ïäµ ÏãúÏûë...</span><span id="cursor"></span>`;
        return;
    }
    
    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span id="cursor"></span>`;
    } else {
        fakeInputField.innerHTML = `${typedValue}<span id="cursor"></span>`;
    }
}


function handleHighlightUpdate(targetElement, typedValue, originalLine) {
    if (!targetElement) return;
    if (typeof originalLine !== 'string') {
        targetElement.textContent = ' ';
        return;
    }
    let builtHTML = "";
    for (let i = 0; i < originalLine.length; i++) {
        const char = originalLine[i];

        if (i < typedValue.length) {
            if (highlightEnabled && typedValue[i] !== originalLine[i]) {
                builtHTML += `<span class="highlight">${char}</span>`;
            } else {
                builtHTML += `<strong>${char}</strong>`;
            }
        } else {
            builtHTML += `<span class="untyped-char">${char}</span>`;
        }
    }
    targetElement.innerHTML = builtHTML || ' ';
}

function handleKeyDownEvent(e) {
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const targetInput = e.target;

    if (e.isComposing) return;

    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }

    if (currentMode !== 'game' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;

        if (e.key === 'Backspace' || (e.key === 'Shift' && !e.repeat && !isModifierKey)) {
            playTypingSound();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            playTypingSound();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            playTypingSound();
            processCurrentLineCompletion();
        } else if (e.key === ' ' && originalLine !== null) {
            playTypingSound();
        }
    }
}


function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }

    let lineCorrectCharsThisLine = 0;
    let lineMistypedCharsOnThisLine = 0;

    for (let i = 0; i < originalLine.length; i++) {
        if (i < typedValue.length) {
            if (typedValue[i] === originalLine[i]) {
                lineCorrectCharsThisLine++;
            } else {
                lineMistypedCharsOnThisLine++;
            }
        } else {
            lineMistypedCharsOnThisLine++;
        }
    }
    if (typedValue.length > originalLine.length) {
        lineMistypedCharsOnThisLine += (typedValue.length - originalLine.length);
    }

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;

    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }


    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;

    if (!currentMode.includes('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }

    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? 'Îã§Ïùå Ï§Ñ...' : 'Îã§Ïùå Î¨∏Ï†ú!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? 'Ïû•Î¨∏ ÏôÑÎ£å! ÏÉàÎ°úÏö¥ Î¨∏Ï†ú Ï§ÄÎπÑ Ï§ë...' : 'Ïó∞Ïäµ ÏôÑÎ£å! ÏÉàÎ°úÏö¥ Î¨∏Ï†ú Ï§ÄÎπÑ Ï§ë...';
        if (currentMode.includes('Long')) {
            currentArticleCorrectChars = 0;
            startTime = null;
        }
        setTimeout(() => startPractice(currentMode, false), 200);
    }
}

function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;

  let currentSpeedToShow = 0;
  if (isSessionReset) {
      currentSpeedToShow = 0;
  } else if (startTime === null && !currentMode.includes('Long')) {
      currentSpeedToShow = lastArticleSpeed;
  } else if (currentMode.includes('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} ÌÉÄ/Î∂Ñ`;

  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;

  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} ÌÉÄ/Î∂Ñ`;

  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} ÌÉÄ/Î∂Ñ`;
}


function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.includes('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}

function playTypingSound() {
  if (!soundEnabled || !currentSoundPack || !soundFiles[currentSoundPack] || !audioPool[currentSoundPack]) return;

  const soundPackSounds = soundFiles[currentSoundPack];
  const currentAudioPoolForPack = audioPool[currentSoundPack];

  if (soundPackSounds.length === 0 || currentAudioPoolForPack.length === 0) return;

  const soundSrc = getRandom(soundPackSounds);
  if (!soundSrc) return;

  let foundAvailableAudio = false;
  for (let i = 0; i < currentAudioPoolForPack.length; i++) {
      const audioIndex = (audioPointer[currentSoundPack] + i) % currentAudioPoolForPack.length;
      let audioToPlay = currentAudioPoolForPack[audioIndex];

      if (audioToPlay && audioToPlay.paused) {
          audioPointer[currentSoundPack] = (audioIndex + 1) % currentAudioPoolForPack.length;
          audioToPlay.src = soundSrc;
          const playPromise = audioToPlay.play();
          if (playPromise !== undefined) {
              playPromise.catch(error => { /* console.warn("Audio play failed:", error); */ });
          }
          foundAvailableAudio = true;
          break;
      }
  }

  if (!foundAvailableAudio) {
      let audioToPlay = currentAudioPoolForPack[audioPointer[currentSoundPack]];
      audioPointer[currentSoundPack] = (audioPointer[currentSoundPack] + 1) % currentAudioPoolForPack.length;
      if (audioToPlay) {
        audioToPlay.src = soundSrc;
        const playPromise = audioToPlay.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => { /* console.warn("Fallback audio play failed:", error); */ });
        }
      }
  }
}

function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// --- GAME MODE ENTRY POINT ---
function activateGameMode(gameType) {
    if (keyboardGuideEl) keyboardGuideEl.style.display = 'none';
    currentMode = 'game';
    currentGameType = gameType;

    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }


    document.body.classList.add('game-mode-active');
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);


    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;


    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;

    gameAreaContainerEl.style.display = 'flex';

    gameStartMessageEl = document.getElementById('game-start-message');
    gameCanvas = document.getElementById('game-canvas');
    if (gameCanvas) gameCtx = gameCanvas.getContext('2d');
    else console.error("activateGameMode: game-canvas ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");

    gameInputField = document.getElementById('game-input-field');
    gameOverlayEl = document.getElementById('gameOverlay');
    itemEffectPopupEl = document.getElementById('item-effect-popup');
    lbbTimerBarContainerEl = document.getElementById('lbb-timer-bar-container');
    lbbTimerBarEl = document.getElementById('lbb-timer-bar');
    lbbTimerTextEl = document.getElementById('lbb-timer-text');

    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }

    const gameTypeRow = document.getElementById('gameTypeSelectionRow');
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> ÏÜåÎÇòÍ∏∞';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => activateGameMode('rainfall'));
    gameTypeRow.appendChild(sonagiBtn);

    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> Î∏îÎ°ù Î∞∞ÌãÄ';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => activateGameMode('letterBlockBattle'));
    gameTypeRow.appendChild(letterBlockBtn);

    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> ÌÉÄÏù¥Ìïë Î∞∞ÌãÄ';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => activateGameMode('giantBattle'));
    gameTypeRow.appendChild(typingBattleBtn);

    const settingsRow1 = document.getElementById('gameSettingsRow1');
    const settingsRow2 = document.getElementById('gameSettingsRow2');
    settingsRow1.innerHTML = ''; settingsRow2.innerHTML = '';

    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);

    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);

    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> ÌÉÄÍ±¥Ïùå ON' : '<i class="fas fa-volume-mute"></i> ÌÉÄÍ±¥Ïùå OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);
    
    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = 'Î†àÎ≤®:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';

    let maxLevelForSelect;
    let currentLevelForSelect;

    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }

    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
    gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }
        if (isActive) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);
    
    const langControlItem = document.createElement('div');
    langControlItem.classList.add('game-control-item');
    const langSelectLabel = document.createElement('label');
    langSelectLabel.htmlFor = 'gameLangSelectInBar';
    langSelectLabel.classList.add('select-label');
    langSelectLabel.textContent = 'Ïñ∏Ïñ¥:';
    const gameLangSelectInBar = document.createElement('select');
    gameLangSelectInBar.id = 'gameLangSelectInBar';
    gameLangSelectInBar.className = 'game-control-select';
    
    const korOption = document.createElement('option');
    korOption.value = 'kor'; korOption.textContent = 'ÌïúÍµ≠Ïñ¥';
    const engOption = document.createElement('option');
    engOption.value = 'eng'; engOption.textContent = 'ÏòÅÏñ¥';
    gameLangSelectInBar.appendChild(korOption);
    gameLangSelectInBar.appendChild(engOption);
    
    if (gameType === 'letterBlockBattle') {
        gameLangSelectInBar.value = 'kor';
        gameLangSelectInBar.disabled = true;
    } else {
        gameLangSelectInBar.value = (gameType === 'rainfall') ? rainfall_preferredGameLanguage : gb_preferredGameLanguage;
        gameLangSelectInBar.disabled = false;
    }
    
    gameLangSelectInBar.addEventListener('change', (e) => {
        const newLang = e.target.value;
        if (gameType === 'rainfall') rainfall_preferredGameLanguage = newLang;
        else if (gameType === 'giantBattle') gb_preferredGameLanguage = newLang;
    });
    langControlItem.appendChild(langSelectLabel);
    langControlItem.appendChild(gameLangSelectInBar);

    settingsRow2.appendChild(levelControlItem);
    settingsRow2.appendChild(langControlItem);

    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> ÌÉÄÏûêÏó∞Ïäµ Í∞ÄÍ∏∞`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);

    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);
    
    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }
    
    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> ÏÜåÎÇòÍ∏∞</h2>
             <p>Îñ®Ïñ¥ÏßÄÎäî Îã®Ïñ¥Î•º Îπ†Î•¥Í≤å ÏûÖÎ†•ÌïòÏÑ∏Ïöî!<br>Î†àÎ≤®ÏùÑ ÏÑ†ÌÉùÌïòÍ≥† Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.<br>Í∞Å Î†àÎ≤®ÏùÄ 2Î∂Ñ ÎèôÏïà 3Îã®Í≥ÑÏùò ÎÇúÏù¥ÎèÑÎ°ú ÏßÑÌñâÎê©ÎãàÎã§.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 ÏÉùÎ™Ö)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3Ï¥à Î©àÏ∂§)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (ÌôîÎ©¥ Ï†ïÎ¶¨)</div>
             </div>
             <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> Í≤åÏûÑ ÏãúÏûë</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> Î∏îÎ°ù Î∞∞ÌãÄ</h2>
            <p>ÏÉÅÌïòÏ¢åÏö∞ Î∏îÎ°ùÏùò Îã®Ïñ¥Î•º ÏûÖÎ†•ÌïòÏó¨ Ïù¥ÎèôÌïòÍ≥†, Ï†ÅÍ≥º Îπà Ïπ∏ÏúºÎ°ú Ïó∞Í≤∞ÎêòÎ©¥ ÏäπÎ¶¨Ìï©ÎãàÎã§!<br>2Î∂Ñ ÏïàÏóê ÏäπÎ∂ÄÍ∞Ä ÎÇòÏßÄ ÏïäÎäîÎã§Î©¥ ÌöçÎìùÌïú Ï†êÏàòÎ°ú ÏäπÌå®Í∞Ä Í≤∞Ï†ïÎê©ÎãàÎã§.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> ÎÖ∏Îûë Î∏îÎ°ù: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}Ï†ê</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> Îπ®Í∞ï Î∏îÎ°ù: ${LBB_BLOCK_EFFECT_TYPES.RED.score}Ï†ê</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> ÌååÎûë Î∏îÎ°ù: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}Ï†ê + Ï†Å 2Ï¥à Ï†ïÏßÄ</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> Ï¥àÎ°ù Î∏îÎ°ù: ÎÑàÏôÄ ÎÇòÏùò ÏúÑÏπò Î≥ÄÍ≤Ω!</div>
            </div>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> Í≤åÏûÑ ÏãúÏûë</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> ÌÉÄÏù¥Ìïë Î∞∞ÌãÄ</h2>
            <p>ÏèüÏïÑÏßÄÎäî Îã®Ïñ¥Îì§ÏùÑ Ï†ïÌôïÌûà ÏûÖÎ†•ÌïòÏó¨ Ï†ÅÏùò Í≥µÍ≤©ÏùÑ ÎßâÏïÑÎÇ¥Í≥†,<br>ÎãπÏã†Ïùò Í≥µÍ≤© Îã®Ïñ¥Î°ú Ï†ÅÏùÑ Í≤©ÌååÌïòÏÑ∏Ïöî! 2Î∂Ñ ÏïàÏóê ÏäπÎ¶¨ÌïòÏÑ∏Ïöî!</p>
            <p>Ïñ∏Ïñ¥ÏôÄ Î†àÎ≤®ÏùÑ ÏÑ†ÌÉùÌïòÍ≥† Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäºÏùÑ ÎàÑÎ•¥ÏÑ∏Ïöî.</p>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> Í≤åÏûÑ ÏãúÏûë</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "Îã®Ïñ¥ ÏûÖÎ†• ÌõÑ Enter ÎòêÎäî Space";

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.innerHTML = '<i class="fas fa-gamepad"></i>Í≤åÏûÑÌïòÍ∏∞';
        gameModeBtnEl.classList.add('active');
    }
}

function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}


// --- RAINFALL (ÏÜåÎÇòÍ∏∞) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    
    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "Îã®Ïñ¥ ÏûÖÎ†• ÌõÑ Enter ÎòêÎäî Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}

function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }
        
        drawRainfallGame();
        
        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }
        
        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}

function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }
    
    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error("Rainfall: Invalid game level configuration for level " + rainfall_gameLevel);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) { 
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}

function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;
    
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }
    
    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }
    
    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`Ï†êÏàò: ${rainfall_gameScore}`, 15, 30);
    
    gameCtx.textAlign = 'center';
    gameCtx.fillText(`Î†àÎ≤®: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);
    
    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`ÏÉùÎ™Ö: ${'‚ù§Ô∏è'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
        
        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';
    
    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;
        
        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}


function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    
    function generateWord() {
        if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;
        
        let newWordText;
        let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
        let itemDetails = null;

        if (isItem) {
            const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
            itemDetails = getRandom(itemTypes);
            newWordText = itemDetails.text;
        } else {
            const wordPool = (rainfall_preferredGameLanguage === 'kor' ? gameWordsKor : gameWordsEng).filter(w => w.length <= 4);
            const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
            newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
            if (!newWordText) newWordText = rainfall_preferredGameLanguage === 'kor' ? 'Îã®Ïñ¥' : 'word';
        }

        rainfall_usedWordsInLevel.add(newWordText);
        if (rainfall_usedWordsInLevel.size > 100) {
            const oldestWord = rainfall_usedWordsInLevel.values().next().value;
            rainfall_usedWordsInLevel.delete(oldestWord);
        }

        const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

        rainfall_wordsOnScreen.push({
            text: newWordText,
            x: Math.random() * (gameCanvas.width - 100) + 50,
            y: -20,
            speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
            isFast: isFast,
            itemType: isItem ? itemDetails.type : null,
            color: isItem ? itemDetails.color : null,
            duration: isItem ? itemDetails.duration : 0
        });
    }
    
    generateWord();
    rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
}


function handleRainfallGameInputSubmit() {
    if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
    const typedWord = gameInputField.value.trim();
    if (typedWord === "") return;

    let wordFound = false;
    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        const wordToMatch = rainfall_preferredGameLanguage === 'eng' ? word.text.toLowerCase() : word.text;
        
        if (typedWord === wordToMatch) {
            if (word.itemType) {
                activateRainfallItemEffect(word.itemType, word.duration);
            } else {
                rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
            }
            
            rainfall_wordsOnScreen.splice(i, 1);
            wordFound = true;
            break;
        }
    }

    if (!wordFound) {
        if(gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    gameInputField.value = "";
}

function activateRainfallItemEffect(itemType, duration) {
    let popupText = "";
    const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
    if (!itemInfo) return;

    switch(itemType) {
        case 'extraLife':
            if (rainfall_gameLives < 10) rainfall_gameLives++;
            popupText = `ÏÉùÎ™Ö +1 ${itemInfo.icon}`;
            break;
        case 'timeStop':
            rainfall_isTimeStopped = true;
            popupText = `ÏãúÍ∞Ñ Ï†ïÏßÄ! ${itemInfo.icon}`;
            if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
            window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
            break;
        case 'clearScreen':
            popupText = `ÌôîÎ©¥ Ï†ïÎ¶¨! ${itemInfo.icon}`;
            for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                if (!rainfall_wordsOnScreen[j].itemType) {
                    rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                    rainfall_wordsOnScreen.splice(j, 1);
                }
            }
            break;
    }
    if (popupText) showGamePopup(popupText, 1500);
}


function triggerRainfallLifeLostEffect() {
    if (gameCanvas) {
        gameCanvas.classList.add('flash-effect');
        setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
    }
}


// --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
    if(level) lbb_gameLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    lbb_playerNoPlayableBlocksTimerId = null;
    if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    lbb_relocationCountdownIntervalId = null;

    lbb_isGameActive = true;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_isRelocating = false;
    
    lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];
    
    lbb_playerScore = 0;
    lbb_enemyScore = 0;
    
    generateLBBGameBoard();
    lbb_playerPos = { r: 0, c: 0 };
    lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
    lbb_enemyOriginalStartPos = { ...lbb_enemyPos };
    
    if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
        lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
    }
    if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
        lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
    }
    
    if (gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "Îã®Ïñ¥ ÏûÖÎ†• ÌõÑ Enter ÎòêÎäî Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }
    
    lbb_gameStartTime = Date.now();
    lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
    startLBBGameLoop();
}

function startLBBGameLoop() {
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    function loop() {
        if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
            cancelAnimationFrame(lbb_gameLoopId);
            lbb_gameLoopId = null;
            return;
        }
        drawLetterBlockBattleGame();
        if(lbb_isGameActive && !lbb_gamePausedForOverlay){
            updateLBBGameLogic();
        }
        lbb_gameLoopId = requestAnimationFrame(loop);
    }
    lbb_gameLoopId = requestAnimationFrame(loop);
}

function updateLBBGameLogic() {
    if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

    if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
        return;
    }

    if (lbb_swapEffect.active) {
        updateLBBSwapAnimation();
    } else if (lbb_finalBattleAnimation.isActive) {
        updateLBBFinalBattleAnimation();
    } else {
        if (!lbb_isRelocating) {
             checkAndTriggerPlayerLBBRelocation();
        }
    }

    lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
    lbb_blockBreakParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1; 
        p.alpha -= 0.02;
    });
}

function drawLetterBlockBattleGame() {
    if (!gameCtx || !gameCanvas) return;
    
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }
    
    const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
    const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
    const boardX = (gameCanvas.width - boardWidth) / 2;
    const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

    const bodyClasses = document.body.classList;
    let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
        inputBgColor = '#fefcf9';
        brokenColor = '#f9f5f0';
        playerBlockBg = '#fffacd';
        playerColor = '#4A90E2';
        enemyColor = '#D0021B';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
        inputBgColor = '#fffafa';
        brokenColor = '#fff5f8';
        playerBlockBg = '#ffe8f0';
        playerColor = '#E91E63';
        enemyColor = '#7B1FA2';
    } else {
        textColor = '#e8e0d8';
        inputBgColor = '#33302e';
        brokenColor = '#262422';
        playerBlockBg = 'rgba(212, 175, 122, 0.08)';
        playerColor = 'dodgerblue';
        enemyColor = 'tomato';
    }

    const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();
    
    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
            if (!block) continue;
            
            const x = boardX + c * LBB_BLOCK_SIZE;
            const y = boardY + r * LBB_BLOCK_SIZE;

            gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

            if (!block.broken) {
                const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                if (isPlayerAdjacent) {
                    gameCtx.fillStyle = playerBlockBg;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }

                gameCtx.font = lbb_blockTextFont;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillStyle = block.effect.color || textColor;
                gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                if (block.effect.icon) {
                    gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                    gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                }
            }
            gameCtx.strokeStyle = borderColor;
            gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
        }
    }
    
    lbb_blockBreakParticles.forEach(p => {
        gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
        gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
    });

    function drawCharacter(pos, color, isPlayer) {
        const x = boardX + pos.c * LBB_BLOCK_SIZE;
        const y = boardY + pos.r * LBB_BLOCK_SIZE;
        gameCtx.fillStyle = color;
        gameCtx.beginPath();
        gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
        gameCtx.fill();
        if (isPlayer) {
            gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.lineWidth = 1;
        }
    }
    
    if (lbb_swapEffect.active) {
        drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
        drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
    } else if (lbb_finalBattleAnimation.isActive) {
        drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
        drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
    } else {
        drawCharacter(lbb_playerPos, playerColor, true);
        drawCharacter(lbb_enemyPos, enemyColor, false);
    }
    
    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.textAlign = 'left';
    gameCtx.fillStyle = playerColor;
    gameCtx.fillText(`ÌîåÎ†àÏù¥Ïñ¥: ${lbb_playerScore}`, 15, 30);
    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = enemyColor;
    gameCtx.fillText(`Ï†Å: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
    gameCtx.textAlign = 'center';
    gameCtx.fillStyle = textColor;
    gameCtx.fillText(`Î†àÎ≤®: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);
    
    if (lbb_relocationCountdown > 0) {
        gameCtx.font = "bold 16px 'Poppins', sans-serif";
        gameCtx.fillStyle = 'orange';
        gameCtx.textAlign = 'center';
        gameCtx.fillText(`Í∏∏ÏùÑ Ï∞æÎäî Ï§ë... ${lbb_relocationCountdown}Ï¥à`, gameCanvas.width / 2, gameCanvas.height - 20);
    }

    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && lbb_isGameActive) {
        const elapsedTime = Date.now() - lbb_gameStartTime;
        const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
        if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
        const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}


function generateLBBGameBoard() {
    lbb_gameBoard = [];
    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        lbb_gameBoard[r] = [];
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const effectRoll = Math.random();
            let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
            if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                const itemRoll = Math.random();
                if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
            }
            lbb_gameBoard[r][c] = {
                word: getRandom(lbb_wordPool),
                broken: false,
                effect: effectType
            };
        }
    }
}

function getSurroundingLBBBlocks(pos, checkBroken = true) {
    const blocks = [];
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; 

    for (const [dr, dc] of directions) {
        const r = pos.r + dr;
        const c = pos.c + dc;

        if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
            const block = lbb_gameBoard[r][c];
            if (!checkBroken || (block && !block.broken)) {
                blocks.push({ ...block, r, c });
            }
        }
    }
    return blocks;
}

function handleLetterBlockBattleInputSubmit() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
    const typedWord = gameInputField.value.trim();
    if (!typedWord) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    const matchedBlock = surroundingBlocks.find(block => block && block.word === typedWord);

    if (matchedBlock) {
        lbb_playerMoveAndBreak(matchedBlock);
        checkLBBBattleCondition();
    } else {
        if (gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    if (gameInputField) gameInputField.value = '';
}

function lbb_playerMoveAndBreak(targetBlock) {
    lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
    const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
    block.broken = true;

    lbb_playerScore += block.effect.score;
    lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
    if (block.effect.effect) {
        lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
    }
}

function lbb_enemyAIAction() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;
    
    const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
    if(surroundingBlocks.length > 0) {
        if (lbb_enemyNoPlayableBlocksTimerId) {
            clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
            lbb_enemyNoPlayableBlocksTimerId = null;
        }
        const targetBlock = getRandom(surroundingBlocks);
        lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
        const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
        block.broken = true;
        lbb_enemyScore += block.effect.score;
        lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
        if (block.effect.effect) {
             lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
        }
        checkLBBBattleCondition();
    } else {
        if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
            lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(false);
                lbb_enemyNoPlayableBlocksTimerId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
        }
    }
}

function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
    lbb_gamePausedForEffect = true;
    let popupText = '';
    
    switch (effect) {
        case 'freezeEnemy':
            if (isPlayer) {
                lbb_isEnemyFrozen = true;
                popupText = `Ï†Å Ï†ïÏßÄ! ${icon}`;
                if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
            }
            break;
        case 'swapPositions':
            lbb_swapEffect.active = true;
            lbb_swapEffect.step = 0;
            lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
            lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
            lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
            lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
            popupText = `ÏúÑÏπò Î≥ÄÍ≤Ω! ${icon}`;
            break;
    }
    
    if (popupText) {
        showGamePopup(popupText, 1500);
    }

    setTimeout(() => { 
        if(effect !== 'swapPositions') lbb_gamePausedForEffect = false; 
    }, 500);
}

function updateLBBSwapAnimation() {
    if (!lbb_swapEffect.active) return;
    
    lbb_swapEffect.step++;
    const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

    const playerTarget = lbb_swapEffect.enemyOld;
    const enemyTarget = lbb_swapEffect.playerOld;
    
    lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
    lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;
    
    lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
    lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;
    
    if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
        lbb_swapEffect.active = false;
        lbb_playerPos = { ...playerTarget };
        lbb_enemyPos = { ...enemyTarget };
        lbb_gamePausedForEffect = false;
    }
}
function lbb_triggerBlockBreakEffect(r, c, colorHex) {
    const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
    for (let i = 0; i < 15; i++) {
        lbb_blockBreakParticles.push({
            x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            ...colorRgb,
            alpha: 1
        });
    }
}

function checkLBBBattleCondition() {
    const path = findPath(lbb_playerPos, lbb_enemyPos);
    if (path) {
        lbb_triggerFinalBattleAnimation(path);
    }
}

function findPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([`${start.r},${start.c}`]);

    while (queue.length > 0) {
        const [current, path] = queue.shift();

        if (current.r === end.r && current.c === end.c) {
            return path;
        }
        
        const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);
        
        for (const neighbor of neighbors) {
            const posKey = `${neighbor.r},${neighbor.c}`;
            if (!visited.has(posKey)) {
                visited.add(posKey);
                const newPath = [...path, neighbor];
                queue.push([neighbor, newPath]);
            }
        }
    }
    return null;
}

function lbb_triggerFinalBattleAnimation(pathToMeet) {
    if (lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.isActive = true;
    lbb_finalBattleAnimation.step = 0;
    lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
}

function updateLBBFinalBattleAnimation() {
    if (!lbb_finalBattleAnimation.isActive) return;
    
    lbb_finalBattleAnimation.step++;
    const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;
    
    const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
    const meetingC = lbb_finalBattleAnimation.meetingPoint.c;
    
    lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
    lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;
    
    if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
        lbb_finalBattleAnimation.isActive = false;
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
    }
}

function checkAndTriggerPlayerLBBRelocation() {
    if(lbb_isRelocating) return;
    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    if(surroundingBlocks.length === 0){
        if(!lbb_playerNoPlayableBlocksTimerId) {
            lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
            lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(true);
                lbb_playerNoPlayableBlocksTimerId = null;
                clearInterval(lbb_relocationCountdownIntervalId);
                lbb_relocationCountdownIntervalId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

            lbb_relocationCountdownIntervalId = setInterval(() => {
                lbb_relocationCountdown--;
                if(lbb_relocationCountdown <= 0) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
            }, 1000);
        }
    } else {
        if (lbb_playerNoPlayableBlocksTimerId) {
            clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
        }
        if(lbb_relocationCountdownIntervalId) {
            clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;
        }
        lbb_relocationCountdown = 0;
    }
}
function lbb_initiateRelocation(isPlayerRelocation) {
    if (isPlayerRelocation) {
        lbb_isRelocating = true;
        showGamePopup("Í∏∏Ïù¥ ÎßâÌòîÏäµÎãàÎã§! Ïû¨Î∞∞ÏπòÌï©ÎãàÎã§...", 2000);
        setTimeout(() => lbb_performRelocation(true), 1000);
    } else {
        lbb_performRelocation(false);
    }
}

function lbb_performRelocation(isPlayerRelocation) {
    const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
    const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);
    
    if(newPos) {
        if(isPlayerRelocation) {
            lbb_playerPos = newPos;
        } else {
            lbb_enemyPos = newPos;
        }
        lbb_gameBoard[newPos.r][newPos.c].broken = true;
    } else {
        handleGameEnd(false, "stuck");
    }
    if (isPlayerRelocation) {
       lbb_isRelocating = false;
    }
}

function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
    const allSpots = [];
    for(let r=0; r<boardRows; r++){
        for(let c=0; c<boardCols; c++){
            if(!lbb_gameBoard[r][c].broken){
                 const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                 if(dist >= minDistanceFromOpponent){
                    allSpots.push({r, c});
                 }
            }
        }
    }
    return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
}


// === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
    if (level) gb_currentLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    }

    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);

    gb_isGameActive = true;
    gb_gamePausedForOverlay = false;
    gb_playerHealth = GB_MAX_PLAYER_HEALTH;
    gb_enemyAttacks = [];
    gb_gameStartTime = Date.now();
    gb_enemyHitEffectTimer = 0;

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    gb_enemyHealth = currentLevelConfig.enemyHealth;

    const gameLangSelectInBar = document.getElementById('gameLangSelectInBar');
    if (gameLangSelectInBar) gb_preferredGameLanguage = gameLangSelectInBar.value;

    gb_spawnPlayerAttackWord();

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "Îã®Ïñ¥ ÏûÖÎ†• ÌõÑ Enter ÎòêÎäî Space";
      setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }
    
    gb_enemyAttackIntervalId = setInterval(gb_spawnEnemyAttack, currentLevelConfig.attackInterval);

    startGiantBattleGameLoop();
}

function startGiantBattleGameLoop() {
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    function loop() {
        if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
             cancelAnimationFrame(gb_gameLoopId);
             gb_gameLoopId = null;
             return;
        }
        drawGiantBattleGame();
        if (gb_isGameActive && !gb_gamePausedForOverlay) {
            updateGiantBattleGameLogic();
        }
        gb_gameLoopId = requestAnimationFrame(loop);
    }
    gb_gameLoopId = requestAnimationFrame(loop);
}

function updateGiantBattleGameLogic() {
    if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

    if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
        handleGameEnd(gb_playerHealth > gb_enemyHealth, "timeUp");
        return;
    }

    if (gb_enemyHitEffectTimer > 0) {
        gb_enemyHitEffectTimer -= 1000 / 60;
        if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
    }

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
        const attack = gb_enemyAttacks[i];
        attack.y += currentLevelConfig.attackSpeed;

        const attackObjectHeight = 40;
        const playerHpBarY = gameCanvas.height - 35 - 18;
        const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;


        if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
            gb_enemyAttacks.splice(i, 1);
            gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
            const damageText = attack.isSpecial ? `ÌäπÎ≥Ñ Í≥µÍ≤© ÌîºÍ≤©! üî•` : `ÌîºÍ≤©! ü§ï`;
            showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
            if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

            if (gb_playerHealth <= 0) {
                gb_playerHealth = 0;
                handleGameEnd(false, "hp");
                return;
            }
        } else if (attack.y > gameCanvas.height + attackObjectHeight) {
             gb_enemyAttacks.splice(i, 1);
        }
    }

    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
        return;
    }
}

function drawGiantBattleGame() {
    if (!gameCtx || !gameCanvas) return;
    
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }
    
    const bodyClasses = document.body.classList;
    let mainTextColor, accentColor, specialAttackColor;
    if (bodyClasses.contains('light-theme')) {
        mainTextColor = '#524a42';
        accentColor = '#b89a6c';
        specialAttackColor = '#b89a6c';
    } else if (bodyClasses.contains('pink-theme')) {
        mainTextColor = '#4F333D';
        accentColor = '#E85D75';
        specialAttackColor = '#E85D75';
    } else { 
        mainTextColor = '#e8e0d8';
        accentColor = '#d4af7a';
        specialAttackColor = '#d4af7a';
    }
    
    function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
        const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();
        
        gameCtx.fillStyle = bgColor;
        gameCtx.fillRect(x, y, width, height);
        
        const healthPercentage = Math.max(0, currentHealth) / maxHealth;
        const currentHealthWidth = width * healthPercentage;
        
        const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, healthColor);
        gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
        gameCtx.fillStyle = gradient;
        gameCtx.fillRect(x, y, currentHealthWidth, height);
        
        gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
        gameCtx.fillRect(x, y, currentHealthWidth, height / 2);
        
        if (label) {
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 12px 'Poppins', sans-serif";
            gameCtx.textAlign = textAlign;
            gameCtx.textBaseline = "bottom";
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
            gameCtx.shadowBlur = 0;
        }
    }
    
    function hexToDarker(hex, percent) {
      let { r, g, b } = hexToRgb(hex);
      r = parseInt(r * (1 - percent));
      g = parseInt(g * (1 - percent));
      b = parseInt(b * (1 - percent));
      return `rgb(${r}, ${g}, ${b})`;
    }

    const topUiY = 30;
    const uiMargin = 15;
    const healthBarHeight = 18;
    
    const enemyHealthBarWidth = gameCanvas.width * 0.3;
    drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "Ï†Å HP", 'right');

    const playerAreaBottomMargin = 50; 
    const playerHpBarWidth = gameCanvas.width * 0.3;
    const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
    const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
    drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "ÌîåÎ†àÏù¥Ïñ¥ HP", 'right');
    
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = mainTextColor;
    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(`Î†àÎ≤®: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

    if (gb_gameStartTime) {
        const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
        const minutes = Math.floor(remainingTime / 60000);
        const seconds = Math.floor((remainingTime % 60000) / 1000);
        gameCtx.font = "bold 14px 'Poppins', sans-serif";
        gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
    }
    
    const attackWordBoxHeight = 40;
    const attackWordBoxWidth = gameCanvas.width * 0.3; 
    const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
    const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20; 
    
    gameCtx.strokeStyle = accentColor;
    gameCtx.lineWidth = 2;
    gameCtx.beginPath();
    gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
    gameCtx.stroke();
    gameCtx.lineWidth = 1;
    
    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.fillStyle = accentColor;
    gameCtx.textAlign = "center";
    gameCtx.textBaseline = "middle";
    gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
    gameCtx.shadowBlur = 2;
    gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);
    
    gameCtx.font = "bold 24px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
    gameCtx.shadowBlur = 5;
    gameCtx.shadowOffsetX = 1;
    gameCtx.shadowOffsetY = 1;

    for (const attack of gb_enemyAttacks) {
        gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
        if (attack.isSpecial) {
            gameCtx.shadowColor = accentColor;
            gameCtx.shadowBlur = 10;
        } else {
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
        }
        gameCtx.fillText(attack.word, attack.x, attack.y);
    }
    gameCtx.shadowBlur = 0;
    gameCtx.shadowOffsetX = 0;
    gameCtx.shadowOffsetY = 0;
}

function gb_spawnPlayerAttackWord() {
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gb_preferredGameLanguage === 'kor' ? gameWordsKor : gameWordsEng;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || (gb_preferredGameLanguage === 'kor' ? "Í≥µÍ≤©" : "attack");
}

function gb_spawnDefenseWord(currentLevelConfig) {
    const wordPool = gb_preferredGameLanguage === 'kor' ? gameWordsKor : gameWordsEng;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || (gb_preferredGameLanguage === 'kor' ? "ÏàòÎπÑ" : "guard");
}


function gb_spawnEnemyAttack() {
    if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gb_preferredGameLanguage === 'kor' ? gameWordsKor : gameWordsEng;

    let word = "";
    let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
    let originalWordForSpecial = "";
    const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);


    if (isSpecialAttack) {
        const specialMinLen = 4;
        const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
        word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || (gb_preferredGameLanguage === 'kor' ? "Í∞ïÌÉÄ" : "SMASH");
        originalWordForSpecial = word;
    } else {
        const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
        word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || (gb_preferredGameLanguage === 'kor' ? "ÎèåÍ≤©" : "charge");
    }

    const startY = -20;

    gb_enemyAttacks.push({
        word: word,
        originalWord: isSpecialAttack ? originalWordForSpecial : word,
        x: Math.random() * (gameCanvas.width - 100) + 50,
        y: startY,
        speed: currentLevelConfig.attackSpeed,
        element: 'rock',
        isSpecial: isSpecialAttack
    });
}

function handleGiantBattleInputSubmit() {
    if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
    const typedWordFull = gameInputField.value.trim();
    if (typedWordFull === "") return;

    const typedWord = gb_preferredGameLanguage === 'eng' ? typedWordFull.toLowerCase() : typedWordFull;

    const playerAttackWordToMatch = gb_preferredGameLanguage === 'eng' ? gb_playerAttackWord.toLowerCase() : gb_playerAttackWord;
    if (typedWord === playerAttackWordToMatch) {
        gb_playerAttack();
        if(gameInputField) gameInputField.value = "";
        return;
    }

    const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
    for (let i = 0; i < sortedEnemyAttacks.length; i++) {
        const enemyAttack = sortedEnemyAttacks[i];
        const enemyWordToMatch = gb_preferredGameLanguage === 'eng' ? enemyAttack.word.toLowerCase() : enemyAttack.word;

        if (typedWord === enemyWordToMatch) {
            if (enemyAttack.isSpecial) {
                enemyAttack.isSpecial = false;
                const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                showGamePopup("ÌäπÏàò Í≥µÍ≤© Î¨¥Î†•Ìôî! üõ°Ô∏è", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
            } else {
                gb_playerDefend(enemyAttack);
            }
            if(gameInputField) gameInputField.value = "";
            return;
        }
    }

    if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
    setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    if(gameInputField) gameInputField.value = "";
}

function gb_playerAttack() {
    gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
    gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
    showGamePopup(`Î™ÖÏ§ë! üí•`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
    gb_spawnPlayerAttackWord();
    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
    }
}

function gb_playerDefend(rock) {
    const index = gb_enemyAttacks.indexOf(rock);
    if (index > -1) {
        gb_enemyAttacks.splice(index, 1);
        showGamePopup("Î∞©Ïñ¥! üõ°Ô∏è", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
    }
}

// --- Í≥µÌÜµ Í≤åÏûÑ Ìï®Ïàò (Ïò§Î≤ÑÎ†àÏù¥, Ïó∞ÏäµÎ™®Îìú Î≥µÍ∑Ä Îì±) ---
function handleGameEnd(playerWins, reason = "") {
    // 1. Î™®Îì† ÌôúÏÑ± Í≤åÏûÑ Î£®ÌîÑ Î∞è Ïù∏ÌÑ∞Î≤å Ï§ëÏßÄ
    rainfall_isGameActive = false; lbb_isGameActive = false; gb_isGameActive = false;
    rainfall_gamePausedForOverlay = true; lbb_gamePausedForOverlay = true; gb_gamePausedForOverlay = true;
    if (gameInputField) gameInputField.disabled = true;

    if (rainfall_gameLoopId) { cancelAnimationFrame(rainfall_gameLoopId); rainfall_gameLoopId = null; }
    if (lbb_gameLoopId) { cancelAnimationFrame(lbb_gameLoopId); lbb_gameLoopId = null; }
    if (gb_gameLoopId) { cancelAnimationFrame(gb_gameLoopId); gb_gameLoopId = null; }
    if (rainfall_wordGenerationIntervalId) { clearInterval(rainfall_wordGenerationIntervalId); rainfall_wordGenerationIntervalId = null; }
    if (lbb_enemyActionIntervalId) { clearInterval(lbb_enemyActionIntervalId); lbb_enemyActionIntervalId = null; }
    if (gb_enemyAttackIntervalId) { clearInterval(gb_enemyAttackIntervalId); gb_enemyAttackIntervalId = null; }

    // 2. ÌòÑÏû¨ Í≤åÏûÑÏùò ÏÑ§Ï†ïÍ≥º ÏÉÅÌÉúÎ•º Í∞ÄÏ†∏Ïò¥
    let gameConfig, currentLevel, score;
    const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

    if (currentGameType === 'rainfall') {
        gameConfig = { name: 'ÏÜåÎÇòÍ∏∞', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
        currentLevel = rainfall_gameLevel;
        score = rainfall_gameScore;
    } else if (currentGameType === 'letterBlockBattle') {
        gameConfig = { name: 'Î∏îÎ°ù Î∞∞ÌãÄ', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
        currentLevel = lbb_gameLevel;
        score = lbb_playerScore;
    } else if (currentGameType === 'giantBattle') {
        gameConfig = { name: 'ÌÉÄÏù¥Ìïë Î∞∞ÌãÄ', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
        currentLevel = gb_currentLevel;
        score = Math.round(gb_playerHealth);
    } else {
        return; 
    }
    
    const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;


    // 3. Í≤åÏûÑ Ï§ë Î†àÎ≤® Î≥ÄÍ≤Ω Ïãú Ï¶âÏãú Ïû¨ÏãúÏûë
    if (reason === 'level_change') {
        showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
        return;
    }
    
    // 4. Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥ ÌõÑ ÏûêÎèô ÏßÑÌñâ Ï≤òÎ¶¨
    if (playerWins && currentLevel < gameConfig.maxLevel) {
        const nextLevel = currentLevel + 1;
        const title = `<i class="fas fa-crown"></i> Î†àÎ≤® ${currentLevel} ÌÅ¥Î¶¨Ïñ¥!`;
        const body = `Ïû†Ïãú ÌõÑ Îã§Ïùå Î†àÎ≤®(${nextLevel})ÏùÑ ÏãúÏûëÌï©ÎãàÎã§...`;
        
        gameOverlayEl.innerHTML = `<h2>${title}</h2><p>${body}</p>`;
        gameOverlayEl.classList.add('visible');

        setTimeout(() => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = nextLevel;
            updateDropdown(nextLevel);
            showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
        }, 2500);
        return;
    }

    // 5. ÏµúÏ¢Ö ÏäπÎ¶¨ ÎòêÎäî Ìå®Î∞∞ Ï≤òÎ¶¨ (Î≤ÑÌäº ÌëúÏãú)
    let title, body, nextStepButtonText, nextStepAction;

    if (playerWins) { // ÏµúÏ¢Ö ÏäπÎ¶¨
        title = `<i class="fas fa-trophy"></i> Î™®Îì† Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥!`;
        if (currentGameType === 'letterBlockBattle') {
            body = `ÌîåÎ†àÏù¥Ïñ¥ Ï†êÏàò: ${lbb_playerScore}<br>Ï†Å Ï†êÏàò: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `ÌîåÎ†àÏù¥Ïñ¥ HP: ${score}<br>Ï†Å HP: ${gb_enemyHealth}`;
        } else {
             body = `ÏµúÏ¢Ö Ï†êÏàò: ${score}`;
        }
        nextStepButtonText = '<i class="fas fa-redo"></i> Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = 1;
            updateDropdown(1);
            showCountdownThenStart(gameConfig.initFunc, [true, 1]);
        };
    } else { // Ìå®Î∞∞
        title = `<i class="fas fa-skull-crossbones"></i> Í≤åÏûÑ Ïò§Î≤Ñ`;
        if (reason === 'timeUp' && ( (currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > gb_enemyHealth) )) {
             title = `<i class="far fa-clock"></i> ÏãúÍ∞Ñ Ï¢ÖÎ£å! (ÌåêÏ†ïÏäπ)`;
        } else if (reason === 'timeUp') {
            title = `<i class="far fa-clock"></i> ÏãúÍ∞Ñ Ï¢ÖÎ£å!`;
        }
        
        if (currentGameType === 'letterBlockBattle') {
            body = `ÌîåÎ†àÏù¥Ïñ¥ Ï†êÏàò: ${lbb_playerScore}<br>Ï†Å Ï†êÏàò: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `ÌîåÎ†àÏù¥Ïñ¥ HP: ${Math.round(gb_playerHealth)}<br>Ï†Å HP: ${Math.round(gb_enemyHealth)}`;
        } else {
            body = `ÏµúÏ¢Ö Ï†êÏàò: ${score}<br>Îã¨ÏÑ± Î†àÎ≤®: ${currentLevel}`;
        }

        nextStepButtonText = '<i class="fas fa-redo"></i> Îã§Ïãú ÎèÑÏ†Ñ';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            const levelToRetry = selectedLevelInDropdown;
            window[gameConfig.levelVarName] = levelToRetry;
            updateDropdown(levelToRetry); 
            showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
        };
    }

    gameOverlayEl.innerHTML = `
        <h2>${title}</h2><p>${body}</p>
        <button id="nextStepBtnOverlay" class="game-button">${nextStepButtonText}</button>
        <button id="returnToPracticeOverlayBtn" class="game-button" style="background: var(--text-secondary); border-color: var(--text-secondary);"><i class="fas fa-keyboard"></i> ÌÉÄÏûêÏó∞Ïäµ Í∞ÄÍ∏∞</button>`;
    gameOverlayEl.classList.add('visible');
    document.getElementById('nextStepBtnOverlay').addEventListener('click', nextStepAction);
    document.getElementById('returnToPracticeOverlayBtn').addEventListener('click', () => returnToPracticeMode(true));
}


function showCountdownThenStart(startGameFunction, args = [true, 1]) {
    if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';

    let count = 3;
    const countdown = () => {
        const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];
        
        if (drawFunc) drawFunc();

        if (count > 0) {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 80px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            count--;
            setTimeout(countdown, 1000);
        } else {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 70px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            setTimeout(() => {
                startGameFunction(...args);
            }, 500);
        }
    };
    countdown();
}


function returnToPracticeMode(resetSessionStats = true) {
    currentMode = '';
    currentGameType = '';
    if (keyboardGuideEl && keyboardGuideEnabled) {
        keyboardGuideEl.style.display = 'block';
    }
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;

    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);

    rainfall_gameLoopId = null; rainfall_wordGenerationIntervalId = null;
    lbb_gameLoopId = null; lbb_enemyActionIntervalId = null; lbb_gameStartTime = null;
    gb_gameLoopId = null; gb_enemyAttackIntervalId = null; gb_gameStartTime = null;

    if (gameOverlayEl) gameOverlayEl.classList.remove('visible');
    if (gameStartMessageEl) gameStartMessageEl.style.display = 'none';
    if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');

    document.body.classList.remove('game-mode-active');

    const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
    if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
        if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
             originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        }
        if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
            originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
        }
    }
    if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
        gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
        gameToggleSoundBtn = null;
    }

    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
    }

    let lastPracticeMode = 'kor';
    const activePracticeButton = document.querySelector('.practice-mode-controls button.active[data-mode]');
    if(activePracticeButton && activePracticeButton.id !== 'gameModeBtn'){
        lastPracticeMode = activePracticeButton.dataset.mode;
    } else {
        const firstPracticeBtn = document.querySelector('.practice-mode-controls button[data-mode]:not(#gameModeBtn)');
        if (firstPracticeBtn) {
            lastPracticeMode = firstPracticeBtn.dataset.mode;
        }
    }
    updateKeyboardDisplay();
    updateKeyboardHighlight();
    startPractice(lastPracticeMode, resetSessionStats);
}

// --- ÏûêÎ¶¨ Ïó∞Ïäµ Í∏∞Îä• Í¥ÄÎ†® Ìï®Ïàò ---
const charToKeyMap = {
    '„ÖÇ': 'q', '„Öà': 'w', '„Ñ∑': 'e', '„Ñ±': 'r', '„ÖÖ': 't', '„Öõ': 'y', '„Öï': 'u', '„Öë': 'i', '„Öê': 'o', '„Öî': 'p',
    '„ÖÅ': 'a', '„Ñ¥': 's', '„Öá': 'd', '„Ñπ': 'f', '„Öé': 'g', '„Öó': 'h', '„Öì': 'j', '„Öè': 'k', '„Ö£': 'l',
    '„Öã': 'z', '„Öå': 'x', '„Öä': 'c', '„Öç': 'v', '„Ö†': 'b', '„Öú': 'n', '„Ö°': 'm',
    '„ÖÉ': 'q', '„Öâ': 'w', '„Ñ∏': 'e', '„Ñ≤': 'r', '„ÖÜ': 't', '„Öí': 'o', '„Öñ': 'p',
    '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
    '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?' : '/'
};

// ‚ñº‚ñº‚ñº [ÏàòÏ†ï] Î≥µÏû°Ìïú ÌïúÍ∏Ä Î∂ÑÌï¥ Î°úÏßÅ Í∞úÏÑ† ‚ñº‚ñº‚ñº
const Hangul = (() => {
    const CHO = ['„Ñ±', '„Ñ≤', '„Ñ¥', '„Ñ∑', '„Ñ∏', '„Ñπ', '„ÖÅ', '„ÖÇ', '„ÖÉ', '„ÖÖ', '„ÖÜ', '„Öá', '„Öà', '„Öâ', '„Öä', '„Öã', '„Öå', '„Öç', '„Öé'];
    const JUNG = ['„Öè', '„Öê', '„Öë', '„Öí', '„Öì', '„Öî', '„Öï', '„Öñ', '„Öó', '„Öò', '„Öô', '„Öö', '„Öõ', '„Öú', '„Öù', '„Öû', '„Öü', '„Ö†', '„Ö°', '„Ö¢', '„Ö£'];
    const JONG = ['', '„Ñ±', '„Ñ≤', '„Ñ≥', '„Ñ¥', '„Ñµ', '„Ñ∂', '„Ñ∑', '„Ñπ', '„Ñ∫', '„Ñª', '„Ñº', '„ÑΩ', '„Ñæ', '„Ñø', '„ÖÄ', '„ÖÅ', '„ÖÇ', '„ÖÑ', '„ÖÖ', '„ÖÜ', '„Öá', '„Öà', '„Öä', '„Öã', '„Öå', '„Öç', '„Öé'];
    const HANGUL_OFFSET = 0xAC00;

    const disassemble = (str) => {
        return str.split('').map(char => {
            const code = char.charCodeAt(0);
            if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                const uniValue = code - HANGUL_OFFSET;
                const jong = uniValue % 28;
                const jung = Math.floor((uniValue - jong) / 28) % 21;
                const cho = Math.floor(uniValue / (21 * 28));
                
                const result = [CHO[cho]];
                const jungJamo = JUNG[jung];
                
                // Î≥µÌï© Î™®Ïùå Î∂ÑÌï¥
                switch(jungJamo) {
                    case '„Öò': result.push('„Öó', '„Öè'); break;
                    case '„Öô': result.push('„Öó', '„Öê'); break;
                    case '„Öö': result.push('„Öó', '„Ö£'); break;
                    case '„Öù': result.push('„Öú', '„Öì'); break;
                    case '„Öû': result.push('„Öú', '„Öî'); break;
                    case '„Öü': result.push('„Öú', '„Ö£'); break;
                    case '„Ö¢': result.push('„Ö°', '„Ö£'); break;
                    default: result.push(jungJamo); break;
                }
                
                if (jong > 0) {
                    const jongJamo = JONG[jong];
                    // Î≥µÌï© Î∞õÏπ® Î∂ÑÌï¥
                    switch(jongJamo) {
                        case '„Ñ≥': result.push('„Ñ±', '„ÖÖ'); break;
                        case '„Ñµ': result.push('„Ñ¥', '„Öà'); break;
                        case '„Ñ∂': result.push('„Ñ¥', '„Öé'); break;
                        case '„Ñ∫': result.push('„Ñπ', '„Ñ±'); break;
                        case '„Ñª': result.push('„Ñπ', '„ÖÅ'); break;
                        case '„Ñº': result.push('„Ñπ', '„ÖÇ'); break;
                        case '„ÑΩ': result.push('„Ñπ', '„ÖÖ'); break;
                        case '„Ñæ': result.push('„Ñπ', '„Öå'); break;
                        case '„Ñø': result.push('„Ñπ', '„Öç'); break;
                        case '„ÖÄ': result.push('„Ñπ', '„Öé'); break;
                        case '„ÖÑ': result.push('„ÖÇ', '„ÖÖ'); break;
                        default: result.push(jongJamo); break;
                    }
                }
                return result;
            }
            return [char]; // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Î¨∏ÏûêÎäî Í∑∏ÎåÄÎ°ú Î∞òÌôò
        }).flat();
    };
    return { disassemble };
})();

// ‚ñº‚ñº‚ñº [ÏàòÏ†ï] ÌÇ§Î≥¥Îìú ÏÉùÏÑ± Î°úÏßÅ ÏàòÏ†ï ‚ñº‚ñº‚ñº
// ‚ñº‚ñº‚ñº [ÏµúÏ¢Ö ÏàòÏ†ï] ÌÇ§Î≥¥Îìú ÏÉùÏÑ± Î°úÏßÅ - wrapper div Ï∂îÍ∞ÄÎ°ú Ï†ïÎ†¨ Î¨∏Ï†ú Ìï¥Í≤∞ ‚ñº‚ñº‚ñº
function buildKeyboard() {
    keyboardGuideEl.innerHTML = '';
    const layout = [
        ['q','w','e','r','t','y','u','i','o','p','[',']'],
        ['a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
        ['z','x','c','v','b','n','m',',','.','/'],
        ['ShiftLeft', 'Space','ShiftRight']
    ];
    const keyInfo = {
        'q': { eng: 'Q', kor: '„ÖÇ', shiftKor: '„ÖÉ' }, 'w': { eng: 'W', kor: '„Öà', shiftKor: '„Öâ' },
        'e': { eng: 'E', kor: '„Ñ∑', shiftKor: '„Ñ∏' }, 'r': { eng: 'R', kor: '„Ñ±', shiftKor: '„Ñ≤' },
        't': { eng: 'T', kor: '„ÖÖ', shiftKor: '„ÖÜ' }, 'y': { eng: 'Y', kor: '„Öõ' }, 'u': { eng: 'U', kor: '„Öï' },
        'i': { eng: 'I', kor: '„Öë' }, 'o': { eng: 'O', kor: '„Öê', shiftKor: '„Öí' }, 'p': { eng: 'P', kor: '„Öî', shiftKor: '„Öñ' },
        'a': { eng: 'A', kor: '„ÖÅ' }, 's': { eng: 'S', kor: '„Ñ¥' }, 'd': { eng: 'D', kor: '„Öá' },
        'f': { eng: 'F', kor: '„Ñπ' }, 'g': { eng: 'G', kor: '„Öé' }, 'h': { eng: 'H', kor: '„Öó' },
        'j': { eng: 'J', kor: '„Öì' }, 'k': { eng: 'K', kor: '„Öè' }, 'l': { eng: 'L', kor: '„Ö£' },
        'z': { eng: 'Z', kor: '„Öã' }, 'x': { eng: 'X', kor: '„Öå' }, 'c': { eng: 'C', kor: '„Öä' },
        'v': { eng: 'V', kor: '„Öç' }, 'b': { eng: 'B', kor: '„Ö†' }, 'n': { eng: 'N', kor: '„Öú' }, 'm': { eng: 'M', kor: '„Ö°' },
        '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, ';': { base: ';', shift: ':' },
        "'": { base: "'", shift: '"' }, ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' },
        '/': { base: '/', shift: '?' }
    };

    layout.forEach((row, index) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = `keyboard-row row-${index + 1}`;
        
        // ÌÇ§Îì§ÏùÑ Í∞êÏã∏Îäî wrapper div Ï∂îÍ∞Ä
        const keysWrapper = document.createElement('div');
        keysWrapper.className = 'keys-wrapper';

        row.forEach(keyId => {
            const keyDiv = document.createElement('div');
            const dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
            keyDiv.dataset.key = dataKey;
            keyDiv.classList.add('keyboard-key');

            const data = keyInfo[keyId];
            if (data) {
                const engMain = data.base || data.eng.toLowerCase();
                const engShift = data.shift || data.eng.toUpperCase();
                const korMain = data.kor || data.base || '';
                const korShift = data.shiftKor || data.shift || '';
                
                keyDiv.innerHTML = `
                    <div class="key-eng">
                        <span class="key-main-char">${engMain}</span>
                        <span class="key-shift-char">${engShift}</span>
                    </div>
                    <div class="key-kor">
                        <span class="key-main-char">${korMain}</span>
                        <span class="key-shift-char">${korShift}</span>
                    </div>
                `;
            } else {
                 keyDiv.classList.add('special');
                 keyDiv.textContent = keyId.replace(/Left|Right/, '');
            }
             if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId)) {
                keyDiv.classList.add('home-row-base');
            }
            // wrapperÏóê ÌÇ§ Ï∂îÍ∞Ä
            keysWrapper.appendChild(keyDiv);
        });
        // rowÏóê wrapper Ï∂îÍ∞Ä
        rowDiv.appendChild(keysWrapper);
        keyboardGuideEl.appendChild(rowDiv);
    });
}
function updateKeyboardDisplay() {
    if (!keyboardGuideEl) return;
    const isKorMode = currentMode.startsWith('kor');
    
    keyboardGuideEl.className = 'keyboard-guide';
    if (keyboardGuideEnabled) {
        keyboardGuideEl.classList.add('visible');
    }
    keyboardGuideEl.classList.add(isKorMode ? 'lang-kor' : 'lang-eng');
}

function clearKeyboardHighlight() {
    if (!keyboardGuideEl) return;
    const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
    highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
}

function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();
    
    const isKorMode = currentMode.startsWith('kor');
    let nextCharToPress;

    if (isKorMode) {
        const disassembledTyped = Hangul.disassemble(typingInputField.value);
        if (disassembledTyped.length < disassembledLine.length) {
            nextCharToPress = disassembledLine[disassembledTyped.length];
        }
    } else {
        const originalLine = linesToPractice[currentDisplayLineIndex];
        if (!originalLine) return;
        const typedValue = typingInputField.value;
        if (typedValue.length < originalLine.length) {
            nextCharToPress = originalLine[typedValue.length];
        }
    }
    
    if (!nextCharToPress) return;

    let keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    let isShiftNeeded = false;

    if (isKorMode) {
        if ('„ÖÉ„Öâ„Ñ∏„Ñ≤„ÖÜ„Öí„Öñ'.includes(nextCharToPress)) {
            isShiftNeeded = true;
        }
    } else {
        if ( (nextCharToPress >= 'A' && nextCharToPress <= 'Z') || ('~!@#$%^&*()_+{}|:"<>?'.includes(nextCharToPress)) ) {
            isShiftNeeded = true;
        }
    }
    
    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}
</script>

</body>
</html>
