<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - 온라인 타자연습 & 게임</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&family=Nanum+Myeongjo:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}

#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}


    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Noto Sans KR', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Nanum Myeongjo', 'Courier New', monospace;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --font-size-typing: 1.15rem;
      --font-size-typing-mobile: 1.05rem;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ub20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --typing-letter-spacing: 0.8px;
      --typing-word-spacing: 2px;
      --typing-letter-spacing-mobile: 0.5px;
      --typing-word-spacing-mobile: 1.5px;
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);

      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;

      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);

      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);


    }
    .light-theme {
      --bg-main: #fdfaf6;
      --bg-container: #fff;
      --bg-typing-area: #f9f5f0;
      --bg-progress-bar: #c0a580;
      --bg-progress-bar-track: #ede7de;
      --text-primary: #524a42;
      --text-secondary: #756A5F;
      --accent-primary: #b89a6c;
      --accent-secondary: #c8ad82;
      --accent-active: #a88a5c;
      --accent-darker: #987b4f;
      --accent-rgb: 184, 154, 108;
      --accent-primary-rgb: 184, 154, 108;
      --input-bg: #fefcf9;
      --input-text: #4a4037;
      --input-border: #dcd3c9;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.25);
      --button-text: #4a4037;
      --button-text-on-accent: #fefcf9;
      --current-line-bg: rgba(var(--accent-rgb), 0.06);
      --current-line-text: #504840;
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.25);
      --current-line-shadow: 0 2px 8px rgba(var(--accent-rgb),0.1);
      --highlight-error: #d3546d;
      --highlight-error-bg: rgba(211, 84, 109, 0.07);
      --shadow-soft: 0 6px 20px rgba(170, 150, 130, 0.08);
      --shadow-inset: inset 0 1px 2px rgba(0,0,0,0.025);
      --shadow-button: 0 3px 8px rgba(170, 150, 130, 0.07);
      --shadow-button-hover: 0 5px 12px rgba(170, 150, 130, 0.1);
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: flex-start;
        padding-top: 3vh;
    }

    .main-content {
      max-width: 1000px;
      width: 100%; background-color: var(--bg-container);
      border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
      display: flex; flex-direction: column; overflow: hidden;
      border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
      transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out;
    }
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }
    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper .practice-mode-controls,
    body.game-mode-active .controls-and-stats-wrapper .feature-toggles,
    body.game-mode-active .controls-and-stats-wrapper #stats,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.game-mode-active .controls-and-stats-wrapper { padding-bottom: 0; }
    body.game-mode-active .settings-container { margin-bottom: 0; }
    body.game-mode-active .main-controls { justify-content: center; gap: 15px; }
    body.game-mode-active .sound-settings,
    body.game-mode-active .theme-settings { display: flex !important; margin-left: 0; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }

    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 35px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      transition: border-radius 0.3s ease;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper { padding: 25px 25px 15px; }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }
    .main-controls { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 12px; }
    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .practice-mode-controls { composes: control-button-group; flex-basis: 100%; order: 1; }
    .practice-mode-controls button { min-width: 100px; }
    .feature-toggles { composes: control-button-group; gap: 10px; justify-content: flex-start; order: 2; flex-grow: 1; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }
    .sound-settings, .theme-settings { display: flex; align-items: center; gap: 8px; order: 3; flex-shrink: 0; }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }
    #soundPackSelect, #themeSelect, #gameLangSelect, #gameLevelSelect {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #soundPackSelect:focus, #themeSelect:focus, #gameLangSelect:focus, #gameLevelSelect:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 15px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 8px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 5px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }


    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        font-size: var(--font-size-typing); line-height: var(--line-height-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc((var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }

    .typing-line, #typing-input-field {
        width: 100%; max-width: 700px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        font-weight: 400;
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        text-align: left;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .typing-line {
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.25s ease, color 0.25s ease, background-color 0.25s ease, box-shadow 0.25s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        display: flex;
        align-items: center;
        background-color: transparent;
        white-space: pre-wrap;
    }

    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }

    .typing-line strong {
        color: var(--current-line-typed-text);
    }

    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }

    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }

    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }

    #typing-input-field-container { width: 100%; max-width: 700px; margin: 2px auto 0 auto; }

#typing-input-field {
  background-color: var(--input-bg);
  color: var(--input-text);
  border: 1px solid var(--input-border);
  font-family: var(--font-typing);
  font-size: calc(var(--font-size-typing) * 0.972);
  line-height: var(--line-height-typing);
  letter-spacing: var(--typing-letter-spacing);
  word-spacing: calc(var(--typing-word-spacing) * 0.82);
  font-weight: 400;
  padding: 12px 16px;
  width: 100%;
  max-width: 700px;
  box-sizing: border-box;
  border-radius: var(--border-radius-small);
  height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
  -webkit-appearance: none;
  appearance: none;
  box-shadow: var(--shadow-inset);
  font-feature-settings: "tnum";
  font-variant-ligatures: none;
}
    #typing-input-field::placeholder {
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        font-weight: 400;
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        color: var(--text-secondary);
        opacity: 0.5;
        line-height: var(--line-height-typing);
    }

    #typing-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }

    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.9);
        padding: 20px;
        border-radius: var(--border-radius-small);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.95); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.97); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 10px;
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.5; max-width: 400px; margin-bottom: 15px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.85em; margin-top: 10px; line-height: 1.7; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 3px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }

    #game-canvas {
        border: 1px solid var(--input-border);
        background-color: var(--input-bg);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item select, #gameToggleSoundBtn { flex-grow: 1; }

#returnToPracticeBtnGame {
  padding: 12px 24px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--accent-primary);
  border: 2px solid rgba(var(--accent-rgb), 0.4);
  background-color: transparent;
  transition: all 0.25s ease;
  box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
}

#returnToPracticeBtnGame:hover {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-active);
  box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
}
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }


#gameToggleSoundBtn {
  padding: 10px 16px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 500;
  font-size: 0.9em;
  border: 1.5px solid var(--accent-secondary);
  background-color: transparent;
  color: var(--accent-secondary);
  transition: all 0.25s ease;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: var(--shadow-button);
}

#gameToggleSoundBtn.active {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-primary);
  font-weight: 600;
}

    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.85);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 20px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.9); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.92); }
    .game-overlay h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2em; margin-bottom: 10px;
    }
    .game-overlay p {
        font-size: 1.1em; color: var(--text-secondary);
        line-height: 1.6; max-width: 450px; margin-bottom: 20px;
    }
    .light-theme .game-overlay h2, .pink-theme .game-overlay h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 10px 5px;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}
      .main-controls { flex-direction: column; align-items: stretch; }
      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings { width: 100%; justify-content: center; }
      .feature-toggles button { min-width: 100px; }
      #soundPackSelect, #themeSelect, #gameLangSelect, #gameLevelSelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }
      .typing-line, #typing-input-field { font-size: var(--font-size-typing-mobile); letter-spacing: var(--typing-letter-spacing-mobile); word-spacing: var(--typing-word-spacing-mobile); }
      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .game-overlay h2 { font-size: 1.6em; }
      .game-overlay p { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .sound-settings, .theme-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }


    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .feature-toggles button { min-width: 90px; }
      .select-label { font-size: 0.85em; }
      #soundPackSelect, #themeSelect, #gameLangSelect, #gameLevelSelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line, #typing-input-field { font-size: calc(var(--font-size-typing-mobile) * 0.95); }
      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .game-overlay h2 { font-size: 1.4em; }
      .game-overlay p { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }
</style>
</head>
<body>
  <div class="main-content-wrapper"> <div class="main-content">
    <div class="hero-section">
        <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
            <h1 class="hero-title">Key Therapy</h1>
            <p class="hero-tagline">🎧 깊은 수면과 집중을 위한<br>키보드 타건 ASMR</p>
        </a>
    </div>
  <div class="controls-and-stats-wrapper">
    <div class="settings-container">
        <div class="main-controls">
            <div class="practice-mode-controls control-button-group">
                <button data-mode="kor"><i class="fas fa-language"></i>한글 단문</button>
                <button data-mode="korLong"><i class="fas fa-align-left"></i>한글 장문</button>
                <button data-mode="eng"><i class="fas fa-font"></i>영어 단문</button>
                <button data-mode="engLong"><i class="fas fa-stream"></i>영어 장문</button>
                <button id="gameModeBtn"><i class="fas fa-gamepad"></i>게임하기</button>
            </div>
            <div class="feature-toggles control-button-group">
                <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
            </div>
            <div class="sound-settings" id="soundSettingsElement">
                <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                <select id="soundPackSelect">
                    <option value="crunchy">서걱서걱</option>
                    <option value="pebbles">조약돌</option>
                    <option value="thocky">도각도각</option>
                </select>
            </div>
            <div class="theme-settings" id="themeSettingsElement">
                <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                <select id="themeSelect">
                    <option value="dark">다크</option>
                    <option value="light">아이보리</option>
                    <option value="pink">핑크</option>
                </select>
            </div>
        </div>
    </div>
    <div id="stats">
        <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
        <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
        <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
        <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
    </div>
</div>
<div class="progress-bar-container">
    <div class="progress-bar"></div>
</div>
<div class="typing-area-container">
    <div id="line-display-area"> </div>
    <div id="typing-input-field-container">
        <input type="text" id="typing-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" inputmode="text" aria-label="타자 입력창">
    </div>
    <div id="upcoming-lines-area"> </div>
</div>
<div id="game-area-container">
</div>
<div id="result"></div>
</div>
</div>
  <div class="footer"> <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> </div>
<script>
// === 전역 변수 및 설정 ===
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;
let sessionResetInProgress = false;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;

let soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameOverlayEl, gameStartMessageEl, itemEffectPopupEl;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;


let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;


let currentSoundPack = 'crunchy';
const soundFiles = {
    pebbles: Array.from({length: 7}, (_, i) => `soundFiles/pebbles/pebble${i + 1}.wav`),
    crunchy: Array.from({length: 11}, (_, i) => `soundFiles/crunchy/crunchy${i + 1}.wav`),
    thocky: Array.from({length: 10}, (_, i) => `soundFiles/thocky/thocky${i + 1}.wav`)
};
let audioPool = {};
const MAX_AUDIO_OBJECTS = 8; // 오디오 객체 수를 늘려 동시 재생 가능성 높임
let audioPointer = {};

let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl;

// === RAINFALL GAME MODE VARIABLES ===
let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "18px 'Noto Sans KR', sans-serif";
let rainfall_preferredGameLanguage = 'kor';
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000 },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE }
};
const rainfall_gameMainLevelsConfig = [
    { subLevels: [ { fallSpeed: 0.20, genRate: 6000, wordMinLen: 2, wordMaxLen: 2, fastWordChance: 0.02, fastWordMultiplier: 1.3 }, { fallSpeed: 0.25, genRate: 5500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.03, fastWordMultiplier: 1.4 }, { fallSpeed: 0.30, genRate: 5000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.04, fastWordMultiplier: 1.5 } ] },
    { subLevels: [ { fallSpeed: 0.35, genRate: 4800, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.6 }, { fallSpeed: 0.42, genRate: 4500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.7 }, { fallSpeed: 0.50, genRate: 4200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.8 } ] },
    { subLevels: [ { fallSpeed: 0.58, genRate: 3900, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.08, fastWordMultiplier: 1.9 }, { fallSpeed: 0.66, genRate: 3600, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.10, fastWordMultiplier: 2.0 }, { fallSpeed: 0.75, genRate: 3300, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.12, fastWordMultiplier: 2.1 } ] },
    { subLevels: [ { fallSpeed: 0.84, genRate: 3000, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.14, fastWordMultiplier: 2.2 }, { fallSpeed: 0.93, genRate: 2700, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.05, genRate: 2400, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.18, fastWordMultiplier: 2.6 } ] },
    { subLevels: [ { fallSpeed: 1.18, genRate: 2100, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.20, fastWordMultiplier: 2.8 }, { fallSpeed: 1.30, genRate: 1800, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.50, genRate: 1500, wordMinLen: 3, wordMaxLen: 5, fastWordChance: 0.30, fastWordMultiplier: 3.4 } ] }
];

// === LETTER BLOCK BATTLE GAME MODE VARIABLES ===
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];

let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };

let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000; // 2분

const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';


const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000 },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;

let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};


const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "미세먼지", "황사", "일기예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "파인애플", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "스무디", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "브랜디", "샴페인", "보드카", "데킬라", "하이볼", "탄산수", "이온음료",
    "비행기", "기차", "버스", "택시", "자전거", "오토바이", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "행글라이더", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "스노보드", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "배드민턴", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "속눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "다섯", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신" , "우주인", "방울뱀", "사막여우"
];
const gameWordsEng = [
    "hello", "sky", "sea", "cloud", "love", "happy", "smile", "wind", "sun", "tree", "petal", "star", "heart", "time", "friend", "wish", "dream", "hope", "idea", "song", "gift", "baby", "coin", "dice", "card", "door", "cake",
    "story", "memory", "thanks", "brave", "faith", "promise", "future", "world", "space", "earth", "moon", "mars", "venus", "comet", "orbit", "galaxy", "dust", "atom", "cell", "gene", "code", "data",
    "nature", "animal", "plant", "flower", "river", "ocean", "beach", "coast", "wave", "sand", "shell", "coral", "fish", "shark", "whale", "bird", "eagle", "lion", "tiger", "bear", "wolf",
    "snack", "candy", "milk", "school", "study", "class", "grade", "exam", "test", "quiz", "score", "point", "award", "prize", "medal", "cup", "flag", "badge", "sign", "logo",
    "effort", "result", "target", "vision", "policy", "market", "value", "price", "trade", "power", "energy", "force", "speed", "light", "sound", "echo", "pulse", "rate", "flow", "zone",
    "game", "play", "desk", "chair", "music", "movie", "trip", "photo", "image", "audio", "video", "chart", "graph", "table", "report", "paper", "letter", "note", "file", "folder", "item",
    "apple", "grape", "melon", "pear", "berry", "juice", "water", "bread", "toast", "butter", "cheese", "yogurt", "sugar", "flour", "yeast", "honey", "syrup", "salt", "rice", "bean", "corn",
    "plane", "train", "bus", "taxi", "bike", "boat", "ship", "yacht", "truck", "ferry", "metro", "rocket", "drone", "cycle", "motor", "engine", "wheel", "road", "path", "lane", "ally",
    "park", "walk", "shop", "book", "debug", "array", "loop", "object", "method", "query", "index", "stack", "queue", "node", "link", "byte", "pixel", "font", "icon", "text",
    "java", "ruby", "swift", "basic", "agent", "alert", "align", "alpha", "angle", "arena", "armor", "arrow", "asset", "atlas", "audio", "avoid", "award", "axis", "azure", "bacon", "magic",
    "baker", "badge", "banjo", "baron", "basin", "baton", "beach", "beard", "beast", "begin", "being", "belly", "below", "bench", "bingo", "birth", "blade", "blame", "blank", "blaze",
    "blast", "blend", "bless", "blind", "blink", "bliss", "block", "blood", "bloom", "bluff", "board", "boast", "bonus", "boost", "booth", "bound", "bowel", "boxer", "brace",
    "brain", "brand", "brass", "bravo", "brawl", "bread", "break", "breed", "breeze", "brick", "bride", "brief", "brine", "bring", "brisk", "broad", "brook", "broom", "brush", "buckle",
    "buddy", "build", "bulge", "bunch", "bunny", "burst", "cabin", "cable", "cache", "camel", "canal", "candy", "canoe", "canyon", "cape", "chaos", "charm", "chase", "chief",
    "carry", "carve", "catch", "cause", "cease", "chain", "chalk", "cheap", "check", "cheek", "cheer", "chess", "chest", "chill", "chimp", "chip", "choir",
    "child", "chime", "china", "choke", "chord", "chunk", "cigar", "civic", "civil", "claim", "clamp", "clash", "clasp", "clean", "clear", "clerk", "click", "cliff", "climax",
    "climb", "cloak", "clock", "clone", "close", "cloth", "clown", "coach", "coast", "cobra", "cocoa", "colon", "color", "combo", "comic", "coral", "count", "court", "cover"
];


function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

const lbb_wordPool = gameWordsKor.filter(word => word.length >= 2 && word.length <= 3);
if (lbb_wordPool.length === 0) {
    console.warn("LBB: 2-3글자 단어 풀이 비어있어 전체 단어 풀을 사용합니다.");
    lbb_wordPool.push(...gameWordsKor);
}


const sentencePool = { kor: ["따뜻한 햇살이 창가에 가득 내린다.", "작은 행복이 모여 큰 기쁨이 된다."], eng: ["The weather is lovely today perfect for a nice walk.", "Start your morning fresh with a warm cup of coffee.", "Listening to your favorite music always lifts the spirits.", "A small smile can brighten up someone's entire day.", "Sometimes it's nice to just gaze at the clear blue sky.", "A good book can be a wonderful and loyal companion.", "You did a great job today have a restful evening.", "Learning something new is always an exciting endeavor.", "Enjoy a delicious dinner together with your family.", "Actions speak louder than words."], korLong: [ "낡은 골목의 초입, 허리 굽은 노파의 손길이 햇살에 바래진 담벼락을 어루만진다. 그녀의 손가락 마디마디에 지난 세월의 주름이 강물처럼 새겨져 있었고, 그 마디 끝에서 스며 나온 이야기들이 무성한 담쟁이덩굴처럼 벽을 휘감았다. 담쟁이 잎사귀들은 바람에 지난날의 속삭임처럼 흔들렸고, 그 사이로 비치는 햇살은 희미한 기억의 파편들을 흩뿌렸다. 노파의 발걸음은 더 이상 빠르지 않았다. 한 걸음, 한 걸음 옮길 때마다 아스팔트 바닥에 찍히는 그림자는 더욱 길고 아득해졌다. 그녀는 문득 걸음을 멈춰 서서, 오래된 전봇대 아래 놓인 작은 벤치에 앉았다. 벤치 옆에는 누군가 심어놓은 듯한 봉숭아 꽃이 붉은 얼굴을 내밀고 있었다. 그 빛깔이 너무나 선명해서, 마치 오래된 흑백사진 속에 홀로 채색된 부분처럼 이질적이었다. 노파는 봉숭아 꽃을 한참 동안 바라보았다. 그 시선 속에는 알 수 없는 그리움과 함께, 어린 시절의 순수한 미소가 언뜻 스쳐 지나갔다. 그녀의 기억 속에는 봉숭아 꽃잎으로 손톱을 물들이며 깔깔대던 작은 소녀의 모습이 선명하게 떠올랐다. 세월은 모든 것을 앗아가지만, 어떤 기억들은 시간의 파도를 거슬러 더욱 또렷하게 남아있는 법이었다. 노파는 주머니에서 빛바랜 손수건을 꺼내 봉숭아 꽃잎을 조심스럽게 감쌌다. 그리고는 다시 천천히 발걸음을 옮겼다. 낡은 골목 끝, 그녀의 그림자가 사라지는 순간까지 담쟁이덩굴은 여전히 바람에 흔들리며, 잊혀진 시간의 노래를 부르고 있었다. 삶이란 어쩌면, 이렇듯 희미해지는 풍경 속에서 선명하게 피어나는 꽃 한 송이 같은 것인지도 모른다. 그 꽃을 가슴에 품고, 우리는 묵묵히 저물어가는 하루를 걸어간다.", "간밤의 꿈은 짙은 안개처럼 형체를 알 수 없었고, 그 희미한 잔상만이 새벽의 고요 속에 떠돈다. 현실의 차가운 공기를 마주하며 침대에서 일어선다. 동이 트기 전의 하늘은 짙은 남색을 띠고 있었고, 그 너머로 희미하게 떠오르는 여명은 마치 거대한 그림자가 서서히 물러나는 듯했다. 밤은 휴식을 주지만, 동시에 가장 깊은 곳에 숨겨진 두려움과 불안을 들추어내는 시간이기도 하다. 꿈속에서 겪었던 알 수 없는 허무함의 정체를 찾아 헤맨다. 그것은 마치 손에 잡히지 않는 연기처럼, 붙잡으려 할수록 더욱 멀어져만 갔다. 어쩌면 그 허무함은 꿈속에서만 존재하는 것이 아니라, 현실 속에도 깊이 뿌리내리고 있는 것인지도 모른다. 삶의 어떤 지점에서 우리는 문득 마주하게 되는 알 수 없는 공허함. 채워지지 않는 갈증과 같은 그것은, 아무리 애써도 사라지지 않고 그림자처럼 따라붙는다. 창문 밖으로 시선을 던진다. 저 멀리 동이 터오고 있다. 빛은 어둠을 몰아내고, 새로운 하루를 약속한다. 차가운 공기를 깊이 들이마신다. 비록 꿈속의 허무함은 여전히 남아있지만, 어쩌면 그 허무함마저도 삶의 일부로 받아들여야 할지도 모른다는 생각이 든다. 완벽하게 채워진 삶은 존재하지 않는 법이니까. 그렇게 미완의 허무함을 끌어안고 새로운 하루를 시작할 준비를 한다. 삶은, 언제나 그렇게 불완전한 채로 이어진다.", "낡은 피아노는 이제 제 음을 내지 못했다. 건반은 누렇게 바랬고, 나무 몸체는 세월의 흔적처럼 군데군데 긁히고 파여 있었다. 그러나 그 낡은 피아노 앞에 앉아 가만히 건반을 눌러보면, 삐걱거리는 소리와 함께 불협화음이 울려 퍼져도, 그 소리 속에는 미처 잊고 지냈던 수많은 기억들이 살아 숨 쉬는 듯했다. 어린 시절, 엄마가 이 피아노 앞에 앉아 동요를 가르쳐주시던 모습, 서툰 솜씨로 젓가락 행진곡을 치며 깔깔대던 친구들의 얼굴, 그리고 처음으로 피아노를 통해 마음을 표현할 수 있다는 사실에 가슴 벅풍경은 언제나 나를 설레게 하고, 잊고 지냈던 동심을 일깨워준다. 어쩌면 눈은, 하늘이 우리에게 보내는 하얀 편지일지도 모른다. 잠시 모든 것을 잊고 순수한 기쁨을 느껴보라고, 그리고 새로운 시작을 준비하라고 속삭이는 아름다운 편지. 나는 코코아의 마지막 한 모금을 마시며, 내일 아침 눈부시게 펼쳐질 하얀 세상을 상상했다. 발자국 하나 없는 깨끗한 눈밭 위를 처음으로 걷는 기분은 얼마나 상쾌할까. 눈이 그치고 아침이 오면, 나는 가장 먼저 하얀 세상 속으로 달려 나가, 겨울이 주는 특별한 선물을 만끽할 것이다.", "오래된 시장을 찾는 것을 좋아한다. 대형마트의 깔끔함과 편리함도 좋지만, 시장에는 그곳에서만 느낄 수 있는 특별한 활기와 정겨움이 있다. 좌판 가득 싱싱한 채소와 과일을 진열해놓고 구성진 목소리로 손님을 부르는 상인들, 흥정을 하며 덤을 얻어가는 손님들의 웃음소리, 맛있는 냄새를 풍기며 발길을 유혹하는 길거리 음식들까지. 시장은 살아있는 사람들의 이야기로 가득한 공간이다. 나는 천천히 시장 골목을 걸으며, 다양한 물건들을 구경하고 사람들의 살아가는 모습을 관찰한다. 그 속에서 나는 잊고 지냈던 인간적인 따뜻함과 소박한 삶의 아름다움을 발견한다. 시장 상인들의 거친 손마디에는 정직한 땀의 가치가 담겨 있고, 그들의 구릿빛 얼굴에는 세월의 흔적과 삶의 지혜가 새겨져 있다. 그들은 단순히 물건을 파는 것이 아니라, 자신의 삶을 나누고 사람들과 정을 주고받는다. 그래서 시장에서의 거래는 단순한 매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다."], engLong: [ "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper dscape, there was a stark, austere beauty that captivated the soul. The way the wind sculpted the sand into ever-changing, sinuous patterns, the resilience of the sparse, thorny vegetation clinging stubbornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding."]
};

document.addEventListener('DOMContentLoaded', () => {
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');

  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  if (![lineDisplayArea, typingInputField, toggleSoundBtn, toggleHighlightBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl].every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }

  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;

  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;

  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';


  initializeAudioPool();

  document.querySelectorAll('.practice-mode-controls button[data-mode]').forEach(button => {
    button.addEventListener('click', function() {
      if (this.id !== 'gameModeBtn') {
        startPractice(this.dataset.mode, true);
      }
    });
  });

  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => activateGameMode('rainfall'));
  }

  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';

  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }

  // input 이벤트는 모든 입력(한글 조합 완료 포함) 시 발생하므로 소리 재생에 적합
  typingInputField.addEventListener('input', handleInputEvent);
  // keydown은 연습/게임 모드 전환 시 각 필드에 동적으로 할당/제거

  document.addEventListener('keydown', (e) => {
    const activeInput = document.activeElement;
    const isTypingFocusable = (currentMode !== '' || currentGameType !== '');
    const isNotInputFocused = (activeInput.tagName !== 'INPUT' && activeInput.tagName !== 'SELECT' && activeInput.tagName !== 'TEXTAREA');
    // 기본적으로 포커스를 주기 위한 것이므로, e.key.length === 1은 유지하되,
    // 실제 입력 소리는 input 이벤트에서 처리
    const isFocusKey = (!e.ctrlKey && !e.altKey && !e.metaKey && e.key.length === 1 && e.key !== ' ');

    if (isTypingFocusable && isNotInputFocused && isFocusKey) {
        if (currentMode === 'game' && gameInputField && !gameInputField.disabled) {
            gameInputField.focus();
        } else if (currentMode !== 'game' && typingInputField && !typingInputField.disabled) {
            typingInputField.focus();
        }
    }
  });


  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });

  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl && linesToPractice[currentDisplayLineIndex] !== undefined) {
        handleHighlightUpdate(currentLineEl, typingInputField.value, linesToPractice[currentDisplayLineIndex]);
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    if (audioPool[currentSoundPack] && (audioPointer[currentSoundPack] === undefined || audioPointer[currentSoundPack] === null) ) {
        audioPointer[currentSoundPack] = 0;
    } else if (!audioPool[currentSoundPack]) {
        initializeAudioPoolForPack(currentSoundPack);
    }
  });

  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });

  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });

  startPractice('kor', true);
});

function applyTheme(theme) {
    document.body.classList.remove('light-theme', 'pink-theme');
    const rootStyle = document.documentElement.style;

    if (theme === 'light') {
        document.body.classList.add('light-theme');
        rootStyle.setProperty('--accent-rgb', '184, 154, 108');
        rootStyle.setProperty('--accent-primary-rgb', '184, 154, 108');
        rootStyle.setProperty('--bg-container-rgb', '255, 255, 255');
        rootStyle.setProperty('--current-lbb-player-color', `var(--lbb-player-color-light)`);
        rootStyle.setProperty('--current-lbb-enemy-color', `var(--lbb-enemy-color-light)`);
        rootStyle.setProperty('--current-lbb-player-highlight-border', `var(--lbb-player-highlight-border-light)`);
        rootStyle.setProperty('--current-lbb-player-block-bg', `var(--lbb-player-block-bg-light)`);
        rootStyle.setProperty('--lbb-score-color', `var(--text-primary)`);
    } else if (theme === 'pink') {
        document.body.classList.add('pink-theme');
        rootStyle.setProperty('--accent-rgb', '232, 93, 117');
        rootStyle.setProperty('--accent-primary-rgb', '232, 93, 117');
        rootStyle.setProperty('--bg-container-rgb', '255, 245, 248');
        rootStyle.setProperty('--current-lbb-player-color', `var(--lbb-player-color-pink)`);
        rootStyle.setProperty('--current-lbb-enemy-color', `var(--lbb-enemy-color-pink)`);
        rootStyle.setProperty('--current-lbb-player-highlight-border', `var(--lbb-player-highlight-border-pink)`);
        rootStyle.setProperty('--current-lbb-player-block-bg', `var(--lbb-player-block-bg-pink)`);
        rootStyle.setProperty('--lbb-score-color', `#FFFFFF`);
    } else {
        document.body.classList.remove('light-theme', 'pink-theme');
        rootStyle.setProperty('--accent-rgb', '212, 175, 122');
        rootStyle.setProperty('--accent-primary-rgb', '212, 175, 122');
        rootStyle.setProperty('--bg-container-rgb', '42, 40, 38');
        rootStyle.setProperty('--current-lbb-player-color', `var(--lbb-player-color-dark)`);
        rootStyle.setProperty('--current-lbb-enemy-color', `var(--lbb-enemy-color-dark)`);
        rootStyle.setProperty('--current-lbb-player-highlight-border', `var(--lbb-player-highlight-border-dark)`);
        rootStyle.setProperty('--current-lbb-player-block-bg', `var(--lbb-player-block-bg-dark)`);
        rootStyle.setProperty('--lbb-score-color', `#FFFFFF`);
    }
    const borderRadiusMain = getComputedStyle(document.documentElement).getPropertyValue(theme === 'pink' ? '--border-radius-main' : '12px').trim();
    const borderRadiusSmall = getComputedStyle(document.documentElement).getPropertyValue(theme === 'pink' ? '--border-radius-small' : '8px').trim();
    rootStyle.setProperty('--border-radius-main', borderRadiusMain || '12px');
    rootStyle.setProperty('--border-radius-small', borderRadiusSmall || '8px');
}


function initializeAudioPoolForPack(packKey) {
    if (soundFiles.hasOwnProperty(packKey) && (!audioPool[packKey] || audioPool[packKey].length === 0)) {
        audioPool[packKey] = [];
        audioPointer[packKey] = 0;
        for (let i = 0; i < MAX_AUDIO_OBJECTS; i++) {
            const audio = new Audio();
            audio.preload = 'auto';
            audioPool[packKey].push(audio);
        }
    }
}

function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}

function startPractice(mode, resetSessionStats = false) {
    if (rainfall_isGameActive || lbb_isGameActive) returnToPracticeMode(false);
    document.body.classList.remove('game-mode-active');
    currentMode = mode;
    currentGameType = '';

    if (mainControlsEl && soundSettingsEl.parentNode !== mainControlsEl) {
        originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
    }


    if (resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';
    document.querySelector('.typing-area-container').style.display = 'flex';
    if (document.getElementById('typing-input-field-container')) {
        document.getElementById('typing-input-field-container').style.display = 'block';
    }
    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.placeholder = '';
        typingInputField.value = '';
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
        // input 이벤트 리스너는 DOMContentLoaded에서 이미 추가됨
    }
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent); // 게임 필드의 input 리스너도 제거
    }
    if (gameAreaContainerEl) gameAreaContainerEl.style.display = 'none';
    if (gameStartMessageEl) gameStartMessageEl.style.display = 'none';
    if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';


    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.mode === mode) btn.classList.add('active');
    });
    if (gameModeBtnEl) {
        gameModeBtnEl.innerHTML = '<i class="fas fa-gamepad"></i>게임하기';
        gameModeBtnEl.classList.remove('active');
    }


    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    sessionResetInProgress = resetSessionStats;
    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }
    startTime = null;
    currentLineStartTime = null;
    currentArticleCorrectChars = 0;
    if (!resetSessionStats && !currentMode.includes('Long')) lastArticleSpeed = 0;

    currentDisplayLineIndex = 0;
    const poolToUse = sentencePool[currentMode];
    let textToPractice = getRandom(poolToUse);
    if (!textToPractice && poolToUse && poolToUse.length > 0) textToPractice = poolToUse[0];
    if (!textToPractice) textToPractice = "예문 로딩에 실패했습니다.";

    linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    if (linesToPractice.length === 0) {
        linesToPractice.push(textToPractice.includes("실패") ? textToPractice : "예문 처리 중 오류가 발생했습니다.");
    }

    if (currentMode.includes('Long') && linesToPractice.length > 1) {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'block';
    } else {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(true);
    updateProgressBar();

    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    sessionResetInProgress = false;
}

function splitTextIntoLines(text, mode, screenWidth) {
    let maxLength;
    if (mode.includes('Long')) {
        if (screenWidth <= 480) maxLength = mode.includes('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.includes('eng') ? 55 : 35;
        else maxLength = mode.includes('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }

    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.includes('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}

function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';

    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();

    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.textContent = passedLineText;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);

    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');

    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        handleHighlightUpdate(currentEl, "", currentLineText);
    } else {
        currentEl.textContent = ' ';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);

    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = upcomingLineText;
            fragmentUpcoming.appendChild(upcomingEl);
        } else {
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = ' ';
            upcomingEl.style.visibility = 'hidden';
            fragmentUpcoming.appendChild(upcomingEl);
        }
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
}

function handleInputEvent(e) {
    // 이 함수는 실제 입력 값이 변경되었을 때 호출됨 (한글 조합 완료 포함)
    // e.isComposing은 input 이벤트에서 항상 false임 (조합 완료 후 발생)
    if ((currentMode !== 'game' && e.target === typingInputField) || (currentMode === 'game' && e.target === gameInputField)) {
        playTypingSound(); // 실제 글자 입력/변경 시 소리 재생
    }

    // 연습 모드일 때 UI 업데이트
    if (currentMode !== 'game' && e.target === typingInputField) {
        const typedValue = typingInputField.value;
        const currentLineEl = document.getElementById('current-typing-line');
        if (!currentLineEl) return;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        handleHighlightUpdate(currentLineEl, typedValue, originalLine);
    }
}


function handleHighlightUpdate(targetElement, typedValue, originalLine) {
    if (!targetElement) return;
    if (typeof originalLine !== 'string') {
        targetElement.textContent = ' ';
        return;
    }
    let builtHTML = "";
    for (let i = 0; i < originalLine.length; i++) {
        const char = originalLine[i];

        if (i < typedValue.length) {
            if (highlightEnabled && typedValue[i] !== originalLine[i]) {
                builtHTML += `<span class="highlight">${char}</span>`;
            } else {
                builtHTML += `<strong>${char}</strong>`;
            }
        } else {
            builtHTML += `<span class="untyped-char">${char}</span>`;
        }
    }
    targetElement.innerHTML = builtHTML || ' ';
}

function handleKeyDownEvent(e) {
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const targetInput = e.target;

    if (e.isComposing) return; // 조합 중인 입력은 무시 (input 이벤트에서 처리)

    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        // 일반 문자 입력 소리는 input 이벤트에서 처리
        return;
    }

    if (currentMode !== 'game' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;

        if (e.key === 'Backspace' || (e.key === 'Shift' && !e.repeat && !isModifierKey)) {
            playTypingSound();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            playTypingSound();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            playTypingSound();
            processCurrentLineCompletion();
        } else if (e.key === ' ' && originalLine !== null) { // 일반 스페이스
            playTypingSound();
        }
        // 일반 문자 입력 소리는 input 이벤트에서 처리
    }
}


function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }

    let lineCorrectCharsThisLine = 0;
    let lineMistypedCharsOnThisLine = 0;

    for (let i = 0; i < originalLine.length; i++) {
        if (i < typedValue.length) {
            if (typedValue[i] === originalLine[i]) {
                lineCorrectCharsThisLine++;
            } else {
                lineMistypedCharsOnThisLine++;
            }
        } else {
            lineMistypedCharsOnThisLine++;
        }
    }
    if (typedValue.length > originalLine.length) {
        lineMistypedCharsOnThisLine += (typedValue.length - originalLine.length);
    }

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;

    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }


    currentDisplayLineIndex++;
    if(typingInputField) typingInputField.value = '';
    currentLineStartTime = null;

    if (!currentMode.includes('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }

    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '장문 완료! 새로운 문제 준비 중...' : '연습 완료! 새로운 문제 준비 중...';
        if (currentMode.includes('Long')) {
            currentArticleCorrectChars = 0;
            startTime = null;
        }
        setTimeout(() => startPractice(currentMode, false), 800);
    }
}

function updateStatsDisplay(isNewArticleOrSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;

  let currentSpeedToShow = 0;
  if (sessionResetInProgress || (isNewArticleOrSessionReset && startTime === null)) {
      currentSpeedToShow = 0;
  } else if (currentMode.includes('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;

  let accuracy = 0;
  if (sessionResetInProgress) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;

  let finalOverallAverageSpeed = 0;
  if (sessionResetInProgress) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;

  statsElements.max.textContent = `${sessionResetInProgress ? 0 : overallMaxSpeed} 타/분`;
}

function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.includes('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}

function playTypingSound() {
  if (!soundEnabled || !currentSoundPack || !soundFiles[currentSoundPack] || !audioPool[currentSoundPack]) return;

  const soundPackSounds = soundFiles[currentSoundPack];
  const currentAudioPoolForPack = audioPool[currentSoundPack];

  if (soundPackSounds.length === 0 || currentAudioPoolForPack.length === 0) return;

  const soundSrc = getRandom(soundPackSounds);
  if (!soundSrc) return;

  let foundAvailableAudio = false;
  for (let i = 0; i < currentAudioPoolForPack.length; i++) {
      const audioIndex = (audioPointer[currentSoundPack] + i) % currentAudioPoolForPack.length;
      let audioToPlay = currentAudioPoolForPack[audioIndex];

      if (audioToPlay && audioToPlay.paused) {
          audioPointer[currentSoundPack] = (audioIndex + 1) % currentAudioPoolForPack.length;
          audioToPlay.src = soundSrc;
          const playPromise = audioToPlay.play();
          if (playPromise !== undefined) {
              playPromise.catch(error => { /* console.warn("Audio play failed:", error); */ });
          }
          foundAvailableAudio = true;
          break;
      }
  }

  if (!foundAvailableAudio) {
      let audioToPlay = currentAudioPoolForPack[audioPointer[currentSoundPack]];
      audioPointer[currentSoundPack] = (audioPointer[currentSoundPack] + 1) % currentAudioPoolForPack.length;
      if (audioToPlay) {
        audioToPlay.src = soundSrc;
        const playPromise = audioToPlay.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => { /* console.warn("Fallback audio play failed:", error); */ });
        }
      }
  }
}

function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// --- GAME MODE ENTRY POINT ---
function activateGameMode(gameType) {
    currentMode = 'game';
    currentGameType = gameType;

    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
        // typingInputField.removeEventListener('input', handleInputEvent); // 이미 DOMContentLoaded에서 추가됨
    }


    document.body.classList.add('game-mode-active');
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);

    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;


    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;
    gameAreaContainerEl.style.display = 'flex';
    gameStartMessageEl = document.getElementById('game-start-message');
    gameCanvas = document.getElementById('game-canvas');
    gameCtx = gameCanvas.getContext('2d');
    gameInputField = document.getElementById('game-input-field');
    gameOverlayEl = document.getElementById('gameOverlay');
    itemEffectPopupEl = document.getElementById('item-effect-popup');
    lbbTimerBarContainerEl = document.getElementById('lbb-timer-bar-container');
    lbbTimerBarEl = document.getElementById('lbb-timer-bar');
    lbbTimerTextEl = document.getElementById('lbb-timer-text');

    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }


    const gameTypeRow = document.getElementById('gameTypeSelectionRow');
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (gameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => activateGameMode('rainfall'));
    gameTypeRow.appendChild(sonagiBtn);

    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (gameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => activateGameMode('letterBlockBattle'));
    gameTypeRow.appendChild(letterBlockBtn);

    const preparingBtn2 = document.createElement('button');
    preparingBtn2.classList.add('game-type-button', 'disabled');
    preparingBtn2.textContent = '준비중';
    preparingBtn2.disabled = true;
    gameTypeRow.appendChild(preparingBtn2);

    const settingsRow1 = document.getElementById('gameSettingsRow1');
    const settingsRow2 = document.getElementById('gameSettingsRow2');
    settingsRow1.innerHTML = ''; settingsRow2.innerHTML = '';

    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);

    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);

    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);

    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelect';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    levelControlItem.appendChild(levelSelectLabel);
    const gameLevelSelect = document.createElement('select');
    gameLevelSelect.id = 'gameLevelSelect';
    const maxLevelForSelect = (gameType === 'rainfall') ? rainfall_gameMainLevelsConfig.length : LBB_MAX_LEVEL;
    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelect.appendChild(option);
    }
    gameLevelSelect.value = (gameType === 'rainfall') ? rainfall_gameLevel : lbb_gameLevel;
    gameLevelSelect.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        if (gameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            rainfall_currentSubLevelIndex = 0;
            if (rainfall_isGameActive) initRainfallGame(false); else rainfall_usedWordsInLevel.clear();
        } else if (gameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            if (lbb_isGameActive) initLetterBlockBattleGame(false);
        }
    });
    levelControlItem.appendChild(gameLevelSelect);
    settingsRow2.appendChild(levelControlItem);

    const langControlItem = document.createElement('div');
    langControlItem.classList.add('game-control-item');
    const langSelectLabel = document.createElement('label');
    langSelectLabel.htmlFor = 'gameLangSelect';
    langSelectLabel.classList.add('select-label');
    langSelectLabel.textContent = '언어:';
    langControlItem.appendChild(langSelectLabel);
    const gameLangSelect = document.createElement('select');
    gameLangSelect.id = 'gameLangSelect';
    const korOption = document.createElement('option');
    korOption.value = 'kor'; korOption.textContent = '한국어';
    const engOption = document.createElement('option');
    engOption.value = 'eng'; engOption.textContent = '영어';
    gameLangSelect.appendChild(korOption);
    gameLangSelect.appendChild(engOption);
    gameLangSelect.value = rainfall_preferredGameLanguage;
    if (gameType === 'letterBlockBattle') {
        gameLangSelect.value = 'kor';
        gameLangSelect.disabled = true;
    } else {
        gameLangSelect.disabled = false;
    }
    gameLangSelect.addEventListener('change', (e) => {
        if (gameType === 'rainfall') {
            rainfall_preferredGameLanguage = e.target.value;
            if (rainfall_isGameActive) initRainfallGame(false); else rainfall_usedWordsInLevel.clear();
        }
    });
    langControlItem.appendChild(gameLangSelect);
    settingsRow2.appendChild(langControlItem);

    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.classList.add('game-button');
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    const returnBtnControlItem = document.createElement('div');
    returnBtnControlItem.classList.add('game-control-item');
    returnBtnControlItem.appendChild(returnBtn);
    settingsRow2.appendChild(returnBtnControlItem);

    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';

    } else {
        gameCanvas.height = Math.max(window.innerHeight * 0.52, 320);
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    }

    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> 생명 +1</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> 3초 멈춤</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> 화면 단어 삭제</div>
             </div>
             <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => initRainfallGame(true));
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>주변 블록의 단어를 입력하고 Enter 또는 Space를 눌러 파괴하세요!<br>블록을 파괴해서 점수를 얻고 적과 나 사이에 막힌 블록이 없다면 점수로 승패가 결정됩니다.<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span style="background-color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};"></span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span style="background-color:${LBB_BLOCK_EFFECT_TYPES.RED.color};"></span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span style="background-color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};"></span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span style="background-color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};"></span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => initLetterBlockBattleGame(true));
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.innerHTML = '<i class="fas fa-gamepad"></i>게임하기';
        gameModeBtnEl.classList.add('active');
    }
}

// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false) {
    if (gameStartMessageEl && fromStartButton) {
        gameStartMessageEl.style.display = 'none';
    }
    if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_levelStartTime = Date.now();
    rainfall_usedWordsInLevel.clear();
    rainfall_currentSubLevelIndex = 0;

    const gameLevelSelectInBar = document.getElementById('gameLevelSelect');
    if (gameLevelSelectInBar) rainfall_gameLevel = parseInt(gameLevelSelectInBar.value);

    const gameLangSelectInBar = document.getElementById('gameLangSelect');
    if (gameLangSelectInBar) rainfall_preferredGameLanguage = gameLangSelectInBar.value;

    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_isTimeStopped = false;

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
      setTimeout(() => gameInputField.focus(), 100);
    }
    startRainfallGameLoop();
    startRainfallWordGeneration();
}


function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (!rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
             if(gameOverlayEl && !gameOverlayEl.classList.contains('visible') && gameStartMessageEl && gameStartMessageEl.style.display !== 'flex'){
                 cancelAnimationFrame(rainfall_gameLoopId);
                 return;
             }
        }
        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }
        if (currentGameType === 'rainfall') drawRainfallGame();
        if (rainfall_isGameActive || rainfall_gamePausedForOverlay || (gameStartMessageEl && gameStartMessageEl.style.display === 'flex' && currentGameType === 'rainfall')) {
             rainfall_gameLoopId = requestAnimationFrame(loop);
        }
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}

function startRainfallWordGeneration() {
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    const mainLevelIndex = Math.max(0, Math.min(rainfall_gameLevel - 1, rainfall_gameMainLevelsConfig.length - 1));
    const mainLevelConfig = rainfall_gameMainLevelsConfig[mainLevelIndex];
    if (!mainLevelConfig || !mainLevelConfig.subLevels || !mainLevelConfig.subLevels[rainfall_currentSubLevelIndex]) {
        rainfallGameOver("configError"); return;
    }
    const currentLevelConfig = mainLevelConfig.subLevels[rainfall_currentSubLevelIndex];
    generateRainfallGameWord();
    rainfall_wordGenerationIntervalId = setInterval(() => {
        if (rainfall_isGameActive && !rainfall_isTimeStopped && !rainfall_gamePausedForOverlay) {
            generateRainfallGameWord();
        }
    }, currentLevelConfig.genRate);
}

function generateRainfallGameWord() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay || rainfall_isTimeStopped) return;
    const mainLevelIndex = Math.max(0, Math.min(rainfall_gameLevel - 1, rainfall_gameMainLevelsConfig.length - 1));
    const mainLevelConfig = rainfall_gameMainLevelsConfig[mainLevelIndex];
    if (!mainLevelConfig || !mainLevelConfig.subLevels || !mainLevelConfig.subLevels[rainfall_currentSubLevelIndex]) return;
    const currentLevelConfig = mainLevelConfig.subLevels[rainfall_currentSubLevelIndex];
    let baseWordPool = rainfall_preferredGameLanguage === 'kor' ? gameWordsKor : gameWordsEng;
    let wordPool = baseWordPool.filter(word => word.length >= currentLevelConfig.wordMinLen && word.length <= Math.min(currentLevelConfig.wordMaxLen, 5));
    if (wordPool.length === 0) wordPool = baseWordPool.filter(word => word.length <=5);
    if (wordPool.length === 0) wordPool = baseWordPool;
    if (wordPool.length === 0) { console.error("Rainfall: Word pool is empty"); return; }

    let newWordText; let attempts = 0; let isDuplicateInLevel; let isDuplicateOnScreen;
    let itemTypeDetails = null;
    if (Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY) {
        const itemKeys = Object.keys(RAINFALL_ITEM_TYPES);
        const randomItemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
        itemTypeDetails = RAINFALL_ITEM_TYPES[randomItemKey];
    }
    do {
        newWordText = getRandom(wordPool);
        if (!newWordText) { attempts = 31; continue; }
        const currentWordLength = newWordText.length;
        if (itemTypeDetails && (currentWordLength < 2 || currentWordLength > 5)) { itemTypeDetails = null; }
        isDuplicateInLevel = rainfall_usedWordsInLevel.has(newWordText);
        isDuplicateOnScreen = rainfall_wordsOnScreen.some(word => word.text === newWordText);
        attempts++;
    } while ( (!newWordText || (!itemTypeDetails && (newWordText.length < currentLevelConfig.wordMinLen || newWordText.length > Math.min(currentLevelConfig.wordMaxLen, 5))) || (!itemTypeDetails && (isDuplicateInLevel || isDuplicateOnScreen)) || (itemTypeDetails && isDuplicateOnScreen) ) && attempts <= 30 );

    if (!newWordText || (!itemTypeDetails && (newWordText.length < currentLevelConfig.wordMinLen || newWordText.length > Math.min(currentLevelConfig.wordMaxLen, 5) || isDuplicateInLevel))) {
        let fallbackAttempts = 0;
        const fallbackPool = baseWordPool.filter(word => word.length >= currentLevelConfig.wordMinLen && word.length <= Math.min(currentLevelConfig.wordMaxLen, 5) && !rainfall_usedWordsInLevel.has(word) && !rainfall_wordsOnScreen.some(w => w.text === word) );
        do {
            newWordText = getRandom(fallbackPool.length > 0 ? fallbackPool : baseWordPool.filter(w => w.length >= currentLevelConfig.wordMinLen && w.length <= Math.min(currentLevelConfig.wordMaxLen, 5)));
            fallbackAttempts++;
        } while ((!newWordText || ( newWordText.length < currentLevelConfig.wordMinLen || newWordText.length > Math.min(currentLevelConfig.wordMaxLen, 5) ) ) && fallbackAttempts < 30);
        if (!newWordText || newWordText.length < currentLevelConfig.wordMinLen || newWordText.length > Math.min(currentLevelConfig.wordMaxLen, 5)) newWordText = rainfall_preferredGameLanguage === 'kor' ? "단어" : "word";
        itemTypeDetails = null;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    const wordWidth = gameCtx.measureText(newWordText).width;
    let fallSpeed = currentLevelConfig.fallSpeed;
    if (Math.random() < currentLevelConfig.fastWordChance) fallSpeed *= currentLevelConfig.fastWordMultiplier;
    fallSpeed += (Math.random() * 0.05 - 0.025);

    const wordObj = { text: newWordText, displayText: newWordText, x: Math.random() * (gameCanvas.width - wordWidth - 20) + 10, y: 45, speed: Math.max(0.1, fallSpeed), color: itemTypeDetails ? itemTypeDetails.color : null, itemType: itemTypeDetails ? itemTypeDetails.type : null, itemDuration: itemTypeDetails ? itemTypeDetails.duration : null };
    rainfall_wordsOnScreen.push(wordObj);
    if (!itemTypeDetails) rainfall_usedWordsInLevel.add(newWordText);
}

function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay || !rainfall_levelStartTime) return;
    const elapsedTimeSinceLevelStart = Date.now() - rainfall_levelStartTime;

    if (rainfall_isTimeStopped) {
         if (elapsedTimeSinceLevelStart >= RAINFALL_LEVEL_DURATION_MS && rainfall_gameLives > 0) {
            if (rainfall_gameLevel < rainfall_gameMainLevelsConfig.length) {
                rainfall_gameLevel++; rainfall_currentSubLevelIndex = 0;
                const gameLevelSelectInBar = document.getElementById('gameLevelSelect'); if (gameLevelSelectInBar) gameLevelSelectInBar.value = rainfall_gameLevel;
                showGameOverlayMessage("levelUp", rainfall_gameScore, rainfall_gameLevel);
            } else { rainfallGameOver("maxLevelReached"); return; }
        } return;
    }
    const newSubLevelIndex = Math.floor(elapsedTimeSinceLevelStart / RAINFALL_SUB_LEVEL_DURATION_MS);
    if (newSubLevelIndex > rainfall_currentSubLevelIndex && newSubLevelIndex < rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1].subLevels.length) {
        rainfall_currentSubLevelIndex = newSubLevelIndex; if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId); startRainfallWordGeneration();
    }
    if (elapsedTimeSinceLevelStart >= RAINFALL_LEVEL_DURATION_MS && rainfall_gameLives > 0) {
        if (rainfall_gameLevel < rainfall_gameMainLevelsConfig.length) {
            rainfall_gameLevel++; rainfall_currentSubLevelIndex = 0;
            const gameLevelSelectInBar = document.getElementById('gameLevelSelect'); if (gameLevelSelectInBar) gameLevelSelectInBar.value = rainfall_gameLevel;
            showGameOverlayMessage("levelUp", rainfall_gameScore, rainfall_gameLevel);
        } else { rainfallGameOver("maxLevelReached"); return; }
    }
    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        rainfall_wordsOnScreen[i].y += rainfall_wordsOnScreen[i].speed;
        if (rainfall_wordsOnScreen[i].y > gameCanvas.height + parseInt(RAINFALL_GAME_FONT)) {
            rainfall_wordsOnScreen.splice(i, 1);
            if (rainfall_gameLives > 0) {
                rainfall_gameLives--; triggerRainfallLifeLostEffect();
                if (rainfall_gameLives <= 0) { rainfallGameOver("lives"); return; }
            }
        }
    }
}

function triggerRainfallLifeLostEffect() {
    if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }
}

function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    if (!rainfall_isGameActive && gameStartMessageEl && gameStartMessageEl.style.display === 'flex' && currentGameType === 'rainfall') return;

    let defaultGameWordColor;
    const currentThemeBodyClass = document.body.classList.contains('light-theme') ? 'light' : (document.body.classList.contains('pink-theme') ? 'pink' : 'dark');
    if (currentThemeBodyClass === 'light') defaultGameWordColor = '#4A443F';
    else if (currentThemeBodyClass === 'pink') defaultGameWordColor = '#4F2E3D';
    else defaultGameWordColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
    gameCtx.font = RAINFALL_GAME_FONT;

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.fillStyle = word.color || defaultGameWordColor;
        gameCtx.fillText(word.displayText, word.x, word.y);
    }
    const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
    const topUiY = 20, timerBarY = 30, timerBarHeight = 8, timerBarWidth = gameCanvas.width * 0.6, timerBarX = (gameCanvas.width - timerBarWidth) / 2;
    let uiTextColor = accentColor;
    if (currentThemeBodyClass !== 'dark') uiTextColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-darker').trim();
    gameCtx.fillStyle = uiTextColor;
    gameCtx.font = "bold 14px " + getComputedStyle(document.documentElement).getPropertyValue('--font-ui').trim();
    gameCtx.textAlign = "left"; gameCtx.fillText(`점수: ${rainfall_gameScore}`, 10, topUiY);
    gameCtx.textAlign = "center"; gameCtx.fillText(`레벨: ${rainfall_gameLevel}`, gameCanvas.width / 2, topUiY);
    gameCtx.textAlign = "right"; let livesDisplay = ""; for(let i=0; i<RAINFALL_INITIAL_LIVES; i++) livesDisplay += (i < rainfall_gameLives ? "❤️" : "🖤"); gameCtx.fillText(`생명: ${livesDisplay}`, gameCanvas.width - 10, topUiY);

    if (rainfall_isGameActive && rainfall_levelStartTime) {
        const currentElapsedTime = Date.now() - rainfall_levelStartTime; const remainingTimeMs = Math.max(0, RAINFALL_LEVEL_DURATION_MS - currentElapsedTime); const totalSeconds = Math.floor(remainingTimeMs / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        gameCtx.textAlign = "center"; let timerTextColor = defaultGameWordColor; if (currentThemeBodyClass !== 'dark') timerTextColor = '#555'; else timerTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
        gameCtx.fillStyle = timerTextColor; gameCtx.fillText(timeString, gameCanvas.width / 2, timerBarY + timerBarHeight + 12);
        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-progress-bar-track').trim(); gameCtx.fillRect(timerBarX, timerBarY, timerBarWidth, timerBarHeight);
        const progressWidth = (remainingTimeMs / RAINFALL_LEVEL_DURATION_MS) * timerBarWidth; gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-progress-bar').trim(); gameCtx.fillRect(timerBarX, timerBarY, progressWidth, timerBarHeight);
    }
    gameCtx.textAlign = "left";
}

function handleRainfallGameInputSubmit() {
    if (currentGameType !== 'rainfall' || !rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
    const typedWord = gameInputField.value.trim();
    if (typedWord === "") return;

    const sortedWordsOnScreen = [...rainfall_wordsOnScreen].sort((a, b) => b.y - a.y);
    let foundMatch = false;
    for (let i = 0; i < sortedWordsOnScreen.length; i++) {
        const wordObj = sortedWordsOnScreen[i];
        const comparisonWord = rainfall_preferredGameLanguage === 'eng' ? typedWord.toLowerCase() : typedWord;
        const wordToMatch = rainfall_preferredGameLanguage === 'eng' ? wordObj.text.toLowerCase() : wordObj.text;

        if (wordToMatch === comparisonWord) {
            rainfall_gameScore += wordObj.text.length * (rainfall_preferredGameLanguage === 'kor' ? 5 : 10);
            const originalIndex = rainfall_wordsOnScreen.findIndex(w => w === wordObj);
            if (originalIndex > -1) rainfall_wordsOnScreen.splice(originalIndex, 1);
            foundMatch = true;
            if (wordObj.itemType) activateRainfallItemEffect(wordObj.itemType, wordObj.itemDuration);
            break;
        }
    }
    if (!foundMatch) {
        if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
        setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    }
    if(gameInputField) gameInputField.value = "";
}


function activateRainfallItemEffect(itemType, duration) {
    switch (itemType) {
        case RAINFALL_ITEM_TYPES.TIME_STOP.type: rainfall_isTimeStopped = true; if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId); window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration || 3000); break;
        case RAINFALL_ITEM_TYPES.CLEAR_SCREEN.type: rainfall_wordsOnScreen = rainfall_wordsOnScreen.filter(word => word.itemType !== null && word.itemType !== RAINFALL_ITEM_TYPES.CLEAR_SCREEN.type); break;
        case RAINFALL_ITEM_TYPES.EXTRA_LIFE.type: if (rainfall_gameLives < RAINFALL_INITIAL_LIVES) rainfall_gameLives++; break;
    }
}

function rainfallGameOver(reason = "lives") {
    rainfall_isGameActive = false; if (gameInputField) gameInputField.disabled = true;
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId); rainfall_wordGenerationIntervalId = null;
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId); rainfall_isTimeStopped = false;
    showGameOverlayMessage("gameOver", rainfall_gameScore, rainfall_gameLevel);
}


// --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false) {
    if (gameStartMessageEl && fromStartButtonOrNextLevel && !lbb_isGameActive) {
        gameStartMessageEl.style.display = 'none';
    }
    if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';

    lbb_isGameActive = true;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_playerScore = 0;
    lbb_enemyScore = 0;
    lbb_playerPos = { r: 0, c: 0 };
    lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
    lbb_enemyPos = { ...lbb_enemyOriginalStartPos };

    lbb_isEnemyFrozen = false;
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);

    const gameLevelSelectInBar = document.getElementById('gameLevelSelect');
    if (gameLevelSelectInBar) {
        if (fromStartButtonOrNextLevel && !lbb_finalBattleAnimation.isActive ) {
             lbb_gameLevel = parseInt(gameLevelSelectInBar.value);
        }
        gameLevelSelectInBar.value = lbb_gameLevel;
    }
    lbb_enemyMoveDelay = lbb_levelDelays[Math.min(lbb_gameLevel - 1, lbb_levelDelays.length - 1)];
    lbb_gameStartTime = Date.now();

    generateLBBGameBoard();

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
      setTimeout(() => gameInputField.focus(), 100);
    }

    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);

    startLetterBlockBattleGameLoop();
}


function generateLBBGameBoard() {
    lbb_gameBoard = [];
    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        const row = [];
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            let blockWord = getRandom(lbb_wordPool) || "단어";
            let blockEffectDetails = LBB_BLOCK_EFFECT_TYPES.NORMAL;

            if (Math.random() < LBB_ITEM_SPAWN_PROBABILITY && !(r === lbb_playerPos.r && c === lbb_playerPos.c) && !(r === lbb_enemyPos.r && c === lbb_enemyPos.c) ) {
                const itemTypeKeys = Object.keys(LBB_BLOCK_EFFECT_TYPES).filter(k => k !== 'NORMAL');
                const randomItemKey = getRandom(itemTypeKeys);
                if (randomItemKey && LBB_BLOCK_EFFECT_TYPES[randomItemKey]) {
                    blockEffectDetails = LBB_BLOCK_EFFECT_TYPES[randomItemKey];
                }
            }
            row.push({
                char: blockWord,
                displayChar: blockWord,
                type: blockEffectDetails.type,
                color: blockEffectDetails.color,
                score: blockEffectDetails.score,
                effect: blockEffectDetails.effect,
                freezeDuration: blockEffectDetails.freezeDuration,
                broken: false
            });
        }
        lbb_gameBoard.push(row);
    }
    if (lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
      lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
      lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].char = ' ';
      lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].displayChar = ' ';
    }
    if (lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
      lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
      lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].char = ' ';
      lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].displayChar = ' ';
    }
}

function getSurroundingLBBBlocks(pos) {
    if (!pos || typeof pos.r === 'undefined' || typeof pos.c === 'undefined') {
        return [];
    }
    const { r, c } = pos;
    const blocks = [];
    const moves = [ {dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1} ];
    for (const move of moves) {
        const nr = r + move.dr;
        const nc = c + move.dc;
        if (nr >= 0 && nr < LBB_BOARD_ROWS && nc >= 0 && nc < LBB_BOARD_COLS && lbb_gameBoard[nr] && lbb_gameBoard[nr][nc] && !lbb_gameBoard[nr][nc].broken) {
            const blockData = lbb_gameBoard[nr][nc];
            blocks.push({...blockData, r: nr, c: nc });
        }
    }
    return blocks;
}

function handleLetterBlockBattleInputSubmit() {
    if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_finalBattleAnimation.isActive) return;

    const typedWord = gameInputField.value.trim();
    if (!typedWord) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    const matchedBlock = surroundingBlocks.find(block => block.char === typedWord);

    if (matchedBlock) {
        lbb_playerMoveAndBreak(matchedBlock);
    } else {
        if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
        setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    }
    gameInputField.value = '';
}


function lbb_playerMoveAndBreak(targetBlock) {
    if (!targetBlock || !lbb_gameBoard[targetBlock.r] || !lbb_gameBoard[targetBlock.r][targetBlock.c] || lbb_gameBoard[targetBlock.r][targetBlock.c].broken) return;

    const blockData = lbb_gameBoard[targetBlock.r][targetBlock.c];
    blockData.broken = true;
    lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
    lbb_playerScore += blockData.score;

    lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, blockData.color || LBB_BLOCK_EFFECT_TYPES.NORMAL.color);


    if (blockData.effect) {
        lbb_applyEffect(blockData.effect, lbb_playerPos, true, blockData.freezeDuration);
    }
    if (checkLBBBattleCondition()) return;
    if (!lbb_gamePausedForEffect) drawLetterBlockBattleGame();
}

let lbb_blockBreakParticles = [];
function lbb_triggerBlockBreakEffect(r, c, color) {
    const particleCount = 5 + Math.floor(Math.random() * 5);
    const blockCenterX = c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + (gameCanvas.width - LBB_BOARD_COLS * LBB_BLOCK_SIZE) / 2;
    const blockCenterY = r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + 30;

    for (let i = 0; i < particleCount; i++) {
        lbb_blockBreakParticles.push({
            x: blockCenterX,
            y: blockCenterY,
            size: Math.random() * 3 + 2,
            color: color || '#ffffff',
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3 - 1,
            life: 20 + Math.random() * 10
        });
    }
}


function lbb_enemyAIAction() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_finalBattleAnimation.isActive) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
    if (surroundingBlocks.length > 0) {
        let targetBlock = null;
        const aggressionLevel = lbb_gameLevel / LBB_MAX_LEVEL;
        const pursuitChance = 0.4 + aggressionLevel * 0.5;

        if (Math.random() < pursuitChance) {
            const dx = lbb_playerPos.c - lbb_enemyPos.c;
            const dy = lbb_playerPos.r - lbb_enemyPos.r;
            let preferredMoves = [];
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) preferredMoves.push(surroundingBlocks.find(b=>(b.c === lbb_enemyPos.c + 1 && b.r === lbb_enemyPos.r)));
                else if (dx < 0) preferredMoves.push(surroundingBlocks.find(b=>(b.c === lbb_enemyPos.c - 1 && b.r === lbb_enemyPos.r)));
                if (dy > 0) preferredMoves.push(surroundingBlocks.find(b=>(b.r === lbb_enemyPos.r + 1 && b.c === lbb_enemyPos.c)));
                else if (dy < 0) preferredMoves.push(surroundingBlocks.find(b=>(b.r === lbb_enemyPos.r - 1 && b.c === lbb_enemyPos.c)));
            } else {
                if (dy > 0) preferredMoves.push(surroundingBlocks.find(b=>(b.r === lbb_enemyPos.r + 1 && b.c === lbb_enemyPos.c)));
                else if (dy < 0) preferredMoves.push(surroundingBlocks.find(b=>(b.r === lbb_enemyPos.r - 1 && b.c === lbb_enemyPos.c)));
                if (dx > 0) preferredMoves.push(surroundingBlocks.find(b=>(b.c === lbb_enemyPos.c + 1 && b.r === lbb_enemyPos.r)));
                else if (dx < 0) preferredMoves.push(surroundingBlocks.find(b=>(b.c === lbb_enemyPos.c - 1 && b.r === lbb_enemyPos.r)));
            }
            targetBlock = preferredMoves.find(b => b);
        }
        if (!targetBlock) {
            targetBlock = getRandom(surroundingBlocks);
        }


        if (targetBlock && lbb_gameBoard[targetBlock.r] && lbb_gameBoard[targetBlock.r][targetBlock.c] && !lbb_gameBoard[targetBlock.r][targetBlock.c].broken) {
            const blockData = lbb_gameBoard[targetBlock.r][targetBlock.c];
            blockData.broken = true;
            lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
            lbb_enemyScore += blockData.score;
            lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, blockData.color || LBB_BLOCK_EFFECT_TYPES.NORMAL.color);

            if (blockData.effect) {
                lbb_applyEffect(blockData.effect, lbb_enemyPos, false, blockData.freezeDuration);
            }
            if(checkLBBBattleCondition()) return;
            if (!lbb_gamePausedForEffect) drawLetterBlockBattleGame();
        }
    }
}

function lbb_applyEffect(effectType, pos, isPlayer, duration) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    let popupText = '';

    switch(effectType) {
        case 'freezeEnemy':
            if (isPlayer) {
                popupText = "적 정지!";
                lbb_isEnemyFrozen = true;
                if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                lbb_enemyFreezeTimeoutId = setTimeout(() => {
                    lbb_isEnemyFrozen = false;
                }, duration || 2000);
            }
            break;
        case 'swapPositions':
            popupText = "위치 변경!";
            lbb_gamePausedForEffect = true;
            lbb_swapEffect.active = true;
            lbb_swapEffect.step = 0;
            lbb_swapEffect.totalSteps = 30;
            lbb_swapEffect.effectDuration = 800;

            lbb_swapEffect.playerOld = {...lbb_playerPos};
            lbb_swapEffect.enemyOld = {...lbb_enemyPos};
            lbb_swapEffect.animPlayerPos = {...lbb_playerPos};
            lbb_swapEffect.animEnemyPos = {...lbb_enemyPos};

            const tempPlayerPos = {...lbb_playerPos};
            const tempEnemyPos = {...lbb_enemyPos};
            lbb_playerPos = tempEnemyPos;
            lbb_enemyPos = tempPlayerPos;

            setTimeout(() => {
                lbb_swapEffect.active = false;
                lbb_gamePausedForEffect = false;
                drawLetterBlockBattleGame();
            }, lbb_swapEffect.effectDuration);
            break;
    }

    if (popupText && itemEffectPopupEl) {
        itemEffectPopupEl.textContent = popupText;
        itemEffectPopupEl.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();
        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            itemEffectPopupEl.classList.remove('visible');
        }, 1200);
    }
}


function checkLBBBattleCondition() {
    if (!lbb_isGameActive || lbb_finalBattleAnimation.isActive || lbb_gamePausedForEffect) return false;

    const queue = [{...lbb_playerPos, path: [`${lbb_playerPos.r}-${lbb_playerPos.c}`]}];
    const visited = new Set([`${lbb_playerPos.r}-${lbb_playerPos.c}`]);
    let pathToEnemy = null;

    while(queue.length > 0) {
        const current = queue.shift();
        if (current.r === lbb_enemyPos.r && current.c === lbb_enemyPos.c) {
            pathToEnemy = current.path;
            break;
        }

        const moves = [ {dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1} ];
        for (const move of moves) {
            const nr = current.r + move.dr;
            const nc = current.c + move.dc;
            const key = `${nr}-${nc}`;

            if (nr >= 0 && nr < LBB_BOARD_ROWS && nc >= 0 && nc < LBB_BOARD_COLS &&
                lbb_gameBoard[nr] && lbb_gameBoard[nr][nc] && lbb_gameBoard[nr][nc].broken && !visited.has(key)) {
                visited.add(key);
                queue.push({r: nr, c: nc, path: [...current.path, key] });
            }
        }
    }

    if (pathToEnemy) {
        lbb_triggerFinalBattleAnimation(pathToEnemy);
        return true;
    }
    return false;
}

function lbb_triggerFinalBattleAnimation(pathToMeet) {
    lbb_isGameActive = false;
    lbb_finalBattleAnimation.isActive = true;
    lbb_finalBattleAnimation.step = 0;
    lbb_finalBattleAnimation.totalSteps = 50;

    lbb_finalBattleAnimation.playerStartPos = {...lbb_playerPos};
    lbb_finalBattleAnimation.enemyStartPos = {...lbb_enemyPos};

    if (!pathToMeet || pathToMeet.length === 0) {
        lbb_finalBattleAnimation.meetingPoint = {
            r: Math.floor(LBB_BOARD_ROWS / 2),
            c: Math.floor(LBB_BOARD_COLS / 2)
        };
    } else {
        const meetingPointIndex = Math.floor(pathToMeet.length / 2);
        if (pathToMeet[meetingPointIndex]) {
            const meetingCoords = pathToMeet[meetingPointIndex].split('-').map(Number);
            lbb_finalBattleAnimation.meetingPoint = { r: meetingCoords[0], c: meetingCoords[1] };
        } else {
            lbb_finalBattleAnimation.meetingPoint = {...lbb_playerPos};
        }
    }

    lbb_finalBattleAnimation.playerAnimPos = {...lbb_finalBattleAnimation.playerStartPos};
    lbb_finalBattleAnimation.enemyAnimPos = {...lbb_finalBattleAnimation.enemyStartPos};


    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
}


function startLetterBlockBattleGameLoop() {
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    function loop() {
        if (!lbb_isGameActive && !lbb_gamePausedForOverlay && !lbb_finalBattleAnimation.isActive && !lbb_gamePausedForEffect) {
             if(gameOverlayEl && !gameOverlayEl.classList.contains('visible') && gameStartMessageEl && gameStartMessageEl.style.display !== 'flex'){
                 cancelAnimationFrame(lbb_gameLoopId); return;
             }
        }

        if (lbb_isGameActive && !lbb_finalBattleAnimation.isActive && !lbb_gamePausedForEffect) {
            const elapsedTime = Date.now() - lbb_gameStartTime;
            if (elapsedTime >= LBB_GAME_DURATION_MS) {
                lbb_triggerFinalBattleAnimation([]);
            }
            if (lbbTimerBarEl && lbbTimerBarContainerEl.style.display === 'block') {
                const progress = Math.max(0, (LBB_GAME_DURATION_MS - elapsedTime) / LBB_GAME_DURATION_MS) * 100;
                lbbTimerBarEl.style.width = `${progress}%`;
                 if (lbbTimerTextEl) {
                    const remainingTimeMs = Math.max(0, LBB_GAME_DURATION_MS - elapsedTime);
                    const totalSeconds = Math.floor(remainingTimeMs / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    lbbTimerTextEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }
        }


        if(lbb_finalBattleAnimation.isActive) {
            updateLBBFinalBattleAnimation();
        } else if (lbb_swapEffect.active) {
            lbb_swapEffect.step++;
        }


        if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();

        if (lbb_isGameActive || lbb_gamePausedForOverlay || lbb_finalBattleAnimation.isActive || lbb_gamePausedForEffect || (gameStartMessageEl && gameStartMessageEl.style.display === 'flex' && currentGameType === 'letterBlockBattle')) {
             lbb_gameLoopId = requestAnimationFrame(loop);
        }
    }
    lbb_gameLoopId = requestAnimationFrame(loop);
}

function updateLBBFinalBattleAnimation() {
    if (!lbb_finalBattleAnimation.isActive) return;

    if (lbb_finalBattleAnimation.step < lbb_finalBattleAnimation.totalSteps) {
        lbb_finalBattleAnimation.step++;
        const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;
        const moveFactor = 0.05 + progress * 0.15;


        if (lbb_finalBattleAnimation.playerStartPos && lbb_finalBattleAnimation.meetingPoint && lbb_finalBattleAnimation.playerAnimPos) {
            lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (lbb_finalBattleAnimation.meetingPoint.r - lbb_finalBattleAnimation.playerStartPos.r) * moveFactor;
            lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (lbb_finalBattleAnimation.meetingPoint.c - lbb_finalBattleAnimation.playerStartPos.c) * moveFactor;
        }
        if (lbb_finalBattleAnimation.enemyStartPos && lbb_finalBattleAnimation.meetingPoint && lbb_finalBattleAnimation.enemyAnimPos) {
            lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (lbb_finalBattleAnimation.meetingPoint.r - lbb_finalBattleAnimation.enemyStartPos.r) * moveFactor;
            lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (lbb_finalBattleAnimation.meetingPoint.c - lbb_finalBattleAnimation.enemyStartPos.c) * moveFactor;
        }

    } else {
        lbb_finalBattleAnimation.isActive = false;
        const gameTimedOut = (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS));
        lbb_letterBlockBattleGameOver(lbb_playerScore > lbb_enemyScore, gameTimedOut ? "timeUp" : "battle");
    }
}


function drawLetterBlockBattleGame() {
    if (!gameCtx || !gameCanvas) return;
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if ((gameStartMessageEl && gameStartMessageEl.style.display === 'flex' && currentGameType === 'letterBlockBattle' && !lbb_isGameActive && !lbb_finalBattleAnimation.isActive && !lbb_gamePausedForEffect)) {
        return;
    }

    const currentTheme = document.body.classList.contains('light-theme') ? 'light' : (document.body.classList.contains('pink-theme') ? 'pink' : 'dark');
    const LBB_CURRENT_PLAYER_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-color').trim();
    const LBB_CURRENT_ENEMY_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-enemy-color').trim();
    const LBB_CURRENT_PLAYER_HIGHLIGHT_BORDER = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
    const LBB_CURRENT_PLAYER_BLOCK_BG = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-block-bg').trim();


    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-typing-area').trim();
    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

    const blockPadding = 1;
    const effectiveBlockSize = LBB_BLOCK_SIZE - blockPadding * 2;
    const boardOffsetY = 30;
    const boardDrawOffsetX = (gameCanvas.width - LBB_BOARD_COLS * LBB_BLOCK_SIZE) / 2;

    const blockTextColorLight = currentTheme === 'pink' ? '#FFFFFF' : '#FAFAFA';
    let blockTextColorDark;

    if (currentTheme === 'light') blockTextColorDark = '#5D4037';
    else if (currentTheme === 'pink') blockTextColorDark = '#6A283A';
    else blockTextColorDark = '#333333';


    const twoCharFontSize = Math.max(8, effectiveBlockSize * 0.28);
    const threeCharFontSize = Math.max(7, effectiveBlockSize * 0.22);


    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const block = lbb_gameBoard[r][c];
            if (!block) continue;
            const x = c * LBB_BLOCK_SIZE + blockPadding + boardDrawOffsetX;
            const y = r * LBB_BLOCK_SIZE + blockPadding + boardOffsetY;

            if (block.broken) {
                let brokenColor = (lbb_playerPos && lbb_playerPos.r === r && lbb_playerPos.c === c && !lbb_finalBattleAnimation.isActive) ? LBB_CURRENT_PLAYER_BLOCK_BG :
                                 (currentTheme === 'light' ? '#EAE0D5' : (currentTheme === 'pink' ? '#FDDDEE' : getComputedStyle(document.documentElement).getPropertyValue(LBB_BROKEN_BLOCK_COLOR_VAR).trim()));


                gameCtx.fillStyle = brokenColor;
                gameCtx.fillRect(x, y, effectiveBlockSize, effectiveBlockSize);
                gameCtx.strokeStyle = currentTheme === 'light' ? '#D0C8BE' : (currentTheme === 'pink' ? '#F0C0D0' : 'rgba(100,100,100,0.1)');

                if(lbb_playerPos && lbb_playerPos.r === r && lbb_playerPos.c === c && !lbb_finalBattleAnimation.isActive && !lbb_gamePausedForEffect) {
                    const highlightStrength = (Math.sin(Date.now() / 120) + 1) / 2;
                    const baseColor = hexToRgb(LBB_CURRENT_PLAYER_HIGHLIGHT_BORDER);
                    if (baseColor) {
                         gameCtx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.6 + highlightStrength * 0.4})`;
                    } else {
                         gameCtx.strokeStyle = LBB_CURRENT_PLAYER_HIGHLIGHT_BORDER;
                    }
                    gameCtx.lineWidth = 3 + highlightStrength * 2;
                }
                gameCtx.strokeRect(x, y, effectiveBlockSize, effectiveBlockSize);
                gameCtx.lineWidth = 1;

            } else {
                let blockBgColor;
                if (block.color) {
                    blockBgColor = block.color;
                } else {
                    if (currentTheme === 'dark') blockBgColor = getComputedStyle(document.documentElement).getPropertyValue('--input-bg').trim();
                    else if (currentTheme === 'light') blockBgColor = '#F7F1E9';
                    else blockBgColor = '#FFF3F6';
                }
                gameCtx.fillStyle = blockBgColor;
                gameCtx.fillRect(x, y, effectiveBlockSize, effectiveBlockSize);

                let blockBorderColor;
                const blockRgbForBorder = hexToRgb(blockBgColor);
                if (currentTheme === 'light') blockBorderColor = block.color && blockRgbForBorder ? `rgba(${blockRgbForBorder.r*0.85}, ${blockRgbForBorder.g*0.85}, ${blockRgbForBorder.b*0.85}, 1)`: '#C8BEB2';
                else if (currentTheme === 'pink') blockBorderColor = block.color && blockRgbForBorder ? `rgba(${blockRgbForBorder.r*0.92}, ${blockRgbForBorder.g*0.92}, ${blockRgbForBorder.b*0.92}, 1)`: '#F4C2D4';
                else blockBorderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();


                gameCtx.strokeStyle = blockBorderColor;
                gameCtx.strokeRect(x, y, effectiveBlockSize, effectiveBlockSize);

                let useLightText = true;
                const rgbForText = hexToRgb(blockBgColor);
                if (rgbForText) {
                    const luminance = (0.299 * rgbForText.r + 0.587 * rgbForText.g + 0.114 * rgbForText.b) / 255;
                    if (luminance > 0.52) useLightText = false;
                } else {
                     if (['#F7F1E9', '#FFF3F6', 'gold', 'deepskyblue', 'limegreen'].includes(blockBgColor) || (blockBgColor && blockBgColor.startsWith("rgba") && blockBgColor.endsWith("0.7)"))) {
                        useLightText = false;
                    }
                }
                gameCtx.fillStyle = useLightText ? blockTextColorLight : blockTextColorDark;

                const currentFontSize = block.displayChar.length >= 3 ? threeCharFontSize : twoCharFontSize;
                gameCtx.font = `bold ${currentFontSize}px 'Noto Sans KR', sans-serif`;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText(block.displayChar, x + effectiveBlockSize / 2, y + effectiveBlockSize / 2 + 1);
            }
        }
    }

    for (let i = lbb_blockBreakParticles.length - 1; i >= 0; i--) {
        const p = lbb_blockBreakParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) {
            lbb_blockBreakParticles.splice(i, 1);
        } else {
            gameCtx.fillStyle = p.color || '#fff';
            gameCtx.globalAlpha = Math.max(0, p.life / 20);
            gameCtx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            gameCtx.globalAlpha = 1.0;
        }
    }


    const charDrawOffsetX = boardDrawOffsetX;
    const playerDrawPos = (lbb_finalBattleAnimation.isActive && lbb_finalBattleAnimation.playerAnimPos) ? lbb_finalBattleAnimation.playerAnimPos :
                          (lbb_swapEffect.active && lbb_swapEffect.animPlayerPos) ? lbb_swapEffect.animPlayerPos : lbb_playerPos;
    const enemyDrawPos = (lbb_finalBattleAnimation.isActive && lbb_finalBattleAnimation.enemyAnimPos) ? lbb_finalBattleAnimation.enemyAnimPos :
                         (lbb_swapEffect.active && lbb_swapEffect.animEnemyPos) ? lbb_swapEffect.animEnemyPos : lbb_enemyPos;


    const charRadius = effectiveBlockSize / 2.8;

    if(playerDrawPos && typeof playerDrawPos.r === 'number' && typeof playerDrawPos.c === 'number') {
        const playerRenderX = playerDrawPos.c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
        const playerRenderY = playerDrawPos.r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + boardOffsetY;
        gameCtx.fillStyle = LBB_CURRENT_PLAYER_COLOR;
        gameCtx.beginPath();
        gameCtx.arc(playerRenderX, playerRenderY, charRadius, 0, Math.PI * 2);
        gameCtx.fill();
        gameCtx.font = `bold ${Math.max(9, LBB_BLOCK_SIZE * 0.32)}px sans-serif`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--lbb-score-color').trim();
        gameCtx.strokeStyle = 'rgba(0,0,0,0.5)'; gameCtx.lineWidth = 1.5;
        gameCtx.strokeText(lbb_playerScore, playerRenderX, playerRenderY);
        gameCtx.fillText(lbb_playerScore, playerRenderX, playerRenderY);
    }


    if(enemyDrawPos && typeof enemyDrawPos.r === 'number' && typeof enemyDrawPos.c === 'number') {
        const enemyRenderX = enemyDrawPos.c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
        const enemyRenderY = enemyDrawPos.r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + boardOffsetY;
        gameCtx.fillStyle = lbb_isEnemyFrozen ? 'rgba(173, 216, 230, 0.7)' : LBB_CURRENT_ENEMY_COLOR;
        gameCtx.beginPath();
        gameCtx.arc(enemyRenderX, enemyRenderY, charRadius, 0, Math.PI * 2);
        gameCtx.fill();
        gameCtx.font = `bold ${Math.max(9, LBB_BLOCK_SIZE * 0.32)}px sans-serif`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--lbb-score-color').trim();
        gameCtx.strokeStyle = 'rgba(0,0,0,0.5)'; gameCtx.lineWidth = 1.5;
        gameCtx.strokeText(lbb_enemyScore, enemyRenderX, enemyRenderY);
        gameCtx.fillText(lbb_enemyScore, enemyRenderX, enemyRenderY);
    }
    gameCtx.lineWidth = 1;



    if (lbb_swapEffect.active && lbb_swapEffect.playerOld && lbb_swapEffect.enemyOld && lbb_swapEffect.animPlayerPos && lbb_swapEffect.animEnemyPos) {
        const animProgress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;
        const easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        const easedProgress = easeInOutQuad(animProgress);

        const playerCurrentX = (lbb_swapEffect.playerOld.c + (lbb_swapEffect.animEnemyPos.c - lbb_swapEffect.playerOld.c) * easedProgress) * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
        const playerCurrentY = (lbb_swapEffect.playerOld.r + (lbb_swapEffect.animEnemyPos.r - lbb_swapEffect.playerOld.r) * easedProgress) * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + boardOffsetY;
        const enemyCurrentX = (lbb_swapEffect.enemyOld.c + (lbb_swapEffect.animPlayerPos.c - lbb_swapEffect.enemyOld.c) * easedProgress) * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
        const enemyCurrentY = (lbb_swapEffect.enemyOld.r + (lbb_swapEffect.animPlayerPos.r - lbb_swapEffect.enemyOld.r) * easedProgress) * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + boardOffsetY;


        const effectRadius = LBB_BLOCK_SIZE * 1.2 * Math.sin(Math.PI * easedProgress);
        gameCtx.globalAlpha = 0.7 * (1 - easedProgress);

        gameCtx.fillStyle = LBB_BLOCK_EFFECT_TYPES.GREEN.color;
        gameCtx.beginPath();
        gameCtx.arc(playerCurrentX, playerCurrentY, effectRadius, 0, Math.PI * 2);
        gameCtx.fill();

        gameCtx.beginPath();
        gameCtx.arc(enemyCurrentX, enemyCurrentY, effectRadius, 0, Math.PI * 2);
        gameCtx.fill();

        gameCtx.globalAlpha = 1.0;
    }


    if (lbb_finalBattleAnimation.isActive && lbb_finalBattleAnimation.playerStartPos && lbb_finalBattleAnimation.enemyStartPos && lbb_finalBattleAnimation.meetingPoint) {
        gameCtx.lineWidth = Math.max(2, LBB_BLOCK_SIZE * 0.1);
        const pathOffset = LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
        const pathYOffset = LBB_BLOCK_SIZE / 2 + boardOffsetY;

        const playerAnimPos = lbb_finalBattleAnimation.playerAnimPos;
        const enemyAnimPos = lbb_finalBattleAnimation.enemyAnimPos;


        if (playerAnimPos) {
             gameCtx.strokeStyle = LBB_CURRENT_PLAYER_COLOR.replace(')', ', 0.7)').replace(/rgb/i, 'rgba');
             gameCtx.beginPath();
             gameCtx.moveTo(lbb_finalBattleAnimation.playerStartPos.c * LBB_BLOCK_SIZE + pathOffset, lbb_finalBattleAnimation.playerStartPos.r * LBB_BLOCK_SIZE + pathYOffset);
             gameCtx.lineTo(playerAnimPos.c * LBB_BLOCK_SIZE + pathOffset, playerAnimPos.r * LBB_BLOCK_SIZE + pathYOffset);
             gameCtx.stroke();
        }
        if (enemyAnimPos) {
             gameCtx.strokeStyle = LBB_CURRENT_ENEMY_COLOR.replace(')', ', 0.7)').replace(/rgb/i, 'rgba');
             gameCtx.beginPath();
             gameCtx.moveTo(lbb_finalBattleAnimation.enemyStartPos.c * LBB_BLOCK_SIZE + pathOffset, lbb_finalBattleAnimation.enemyStartPos.r * LBB_BLOCK_SIZE + pathYOffset);
             gameCtx.lineTo(enemyAnimPos.c * LBB_BLOCK_SIZE + pathOffset, enemyAnimPos.r * LBB_BLOCK_SIZE + pathYOffset);
             gameCtx.stroke();
        }


        if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps / 2) {
            const meetX = lbb_finalBattleAnimation.meetingPoint.c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + charDrawOffsetX;
            const meetY = lbb_finalBattleAnimation.meetingPoint.r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2 + boardOffsetY;
            gameCtx.fillStyle = 'rgba(255, 223, 0, 0.8)';
            gameCtx.beginPath();
            const explosionRadius = LBB_BLOCK_SIZE * (0.5 + ( (lbb_finalBattleAnimation.step - lbb_finalBattleAnimation.totalSteps/2) / (lbb_finalBattleAnimation.totalSteps/2) ) * 0.7);
            gameCtx.arc(meetX, meetY, explosionRadius, 0, Math.PI * 2);
            gameCtx.fill();
        }
        gameCtx.lineWidth = 1;
    }

    const topUiY = 18;
    let uiTextColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
    if (currentTheme !== 'dark') {
        uiTextColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-darker').trim();
    }
    gameCtx.fillStyle = uiTextColor;
    gameCtx.font = "bold 13px " + getComputedStyle(document.documentElement).getPropertyValue('--font-ui').trim();

    gameCtx.textAlign = "left"; gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 10, topUiY);
    gameCtx.textAlign = "center"; gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, topUiY);
    gameCtx.textAlign = "right"; gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 10, topUiY);

    gameCtx.textAlign = "left"; gameCtx.textBaseline = 'alphabetic';
}


function lbb_letterBlockBattleGameOver(playerWins, reason = "battle") {
    lbb_isGameActive = false;
    lbb_gamePausedForOverlay = true;
    if (gameInputField) gameInputField.disabled = true;
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if(lbb_gameLoopId) {
        cancelAnimationFrame(lbb_gameLoopId);
        lbb_gameLoopId = null;
    }


    let messageTitle = "";
    let messageBody = `플레이어 점수: ${lbb_playerScore}<br>적 점수: ${lbb_enemyScore}`;
    let nextStepButtonText = '<i class="fas fa-redo"></i> 현재 레벨 다시 시작';
    let nextStepAction = () => {
        gameOverlayEl.classList.remove('visible');
        lbb_gamePausedForOverlay = false;
        initLetterBlockBattleGame(true);
    };

    if (reason === "timeUp") {
        messageTitle = `<i class="far fa-clock"></i> 시간 종료!`;
         if (lbb_playerScore === lbb_enemyScore && playerWins) {
             playerWins = lbb_playerScore > lbb_enemyScore;
         } else if (lbb_playerScore === lbb_enemyScore) {
             playerWins = false;
         }
    }


    if (playerWins) {
        messageTitle = reason === "battle" ? `<i class="fas fa-crown"></i> 전투 승리!` : messageTitle + ` (승리!)`;
        if (lbb_gameLevel < LBB_MAX_LEVEL) {
            nextStepButtonText = `<i class="fas fa-arrow-right"></i> 다음 레벨 (${lbb_gameLevel + 1})`;
            nextStepAction = () => {
                lbb_gameLevel++;
                const gameLevelSelect = document.getElementById('gameLevelSelect');
                if (gameLevelSelect) gameLevelSelect.value = lbb_gameLevel;
                gameOverlayEl.classList.remove('visible');
                lbb_gamePausedForOverlay = false;
                initLetterBlockBattleGame(true);
            };
        } else {
            messageTitle = `<i class="fas fa-trophy"></i> 모든 레벨 클리어!`;
            nextStepButtonText = '<i class="fas fa-redo"></i> 처음부터 다시';
             nextStepAction = () => {
                lbb_gameLevel = 1;
                const gameLevelSelect = document.getElementById('gameLevelSelect');
                if (gameLevelSelect) gameLevelSelect.value = 1;
                gameOverlayEl.classList.remove('visible');
                lbb_gamePausedForOverlay = false;
                initLetterBlockBattleGame(true);
            };
        }
    } else {
        messageTitle = reason === "battle" ? `<i class="fas fa-skull-crossbones"></i> 전투 패배...` : messageTitle + ` (패배...)`;
        if (lbb_playerScore === lbb_enemyScore && reason === "timeUp") {
            messageBody += "<br>시간 종료 시 동점은 패배로 처리됩니다.";
        }
    }


    gameOverlayEl.innerHTML = `
        <h2>${messageTitle}</h2>
        <p>${messageBody}</p>
        <button id="lbbNextStepBtnOverlay" class="game-button">${nextStepButtonText}</button>
        <button id="lbbReturnToPracticeOverlayBtn" class="game-button" style="background: var(--text-secondary); border-color: var(--text-secondary);"><i class="fas fa-keyboard"></i> 타자연습 가기</button>
    `;
    gameOverlayEl.classList.add('visible');

    document.getElementById('lbbNextStepBtnOverlay').addEventListener('click', nextStepAction);
    document.getElementById('lbbReturnToPracticeOverlayBtn').addEventListener('click', () => returnToPracticeMode(true));
}


// --- 공통 게임 함수 (오버레이, 연습모드 복귀 등) ---
function showGameOverlayMessage(type, score = 0, level = 1) {
    let currentPauseStateUpdate = () => {};
    if (currentGameType === 'rainfall') {
        rainfall_gamePausedForOverlay = true;
        currentPauseStateUpdate = () => { rainfall_gamePausedForOverlay = false; };
    } else if (currentGameType === 'letterBlockBattle') {
        if (type !== "levelUp") {
             lbb_gamePausedForOverlay = true;
             currentPauseStateUpdate = () => { lbb_gamePausedForOverlay = false; };
        } else return;
    } else { return; }

    let content = '';
    switch(type) {
        case "gameOver":
            content = `
                <h2><i class="fas fa-skull-crossbones"></i> 게임 오버 (소나기)</h2>
                <p>최종 점수: ${score}<br>달성 레벨: ${level}</p>
                <button id="playAgainBtnOverlay" class="game-button"><i class="fas fa-redo"></i> 다시 시작</button>
                <button id="returnToPracticeOverlayBtn" class="game-button" style="background: var(--text-secondary); border-color: var(--text-secondary);"><i class="fas fa-keyboard"></i> 타자연습 가기</button>
            `;
            break;
        case "levelUp":
            gameOverlayEl.innerHTML = `<h2>레벨 ${level} 달성!</h2>`;
            gameOverlayEl.classList.add('visible');
            setTimeout(() => {
                gameOverlayEl.classList.remove('visible');
                currentPauseStateUpdate();
                 if (currentGameType === 'rainfall' && rainfall_isGameActive) {
                    rainfall_levelStartTime = Date.now();
                    rainfall_usedWordsInLevel.clear();
                    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
                    startRainfallWordGeneration();
                }
            }, 1500);
            return;
    }

    if (type !== "levelUp") {
        gameOverlayEl.innerHTML = content;
        gameOverlayEl.classList.add('visible');
    }

    if (type === "gameOver") {
        const playAgainBtn = document.getElementById('playAgainBtnOverlay');
        if (playAgainBtn) {
            playAgainBtn.addEventListener('click', () => {
                gameOverlayEl.classList.remove('visible');
                if (currentGameType === 'rainfall') {
                    rainfall_gamePausedForOverlay = false;
                    initRainfallGame(true);
                }
            });
        }
        const returnToPracticeBtn = document.getElementById('returnToPracticeOverlayBtn');
        if (returnToPracticeBtn) {
            returnToPracticeBtn.addEventListener('click', () => returnToPracticeMode(true));
        }
    }
}

function returnToPracticeMode(resetSessionStats = true) {
    currentMode = '';
    currentGameType = '';
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    rainfall_gamePausedForOverlay = false;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_finalBattleAnimation.isActive = false;


    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);

    rainfall_gameLoopId = null; rainfall_wordGenerationIntervalId = null;
    lbb_gameLoopId = null; lbb_enemyActionIntervalId = null; lbb_gameStartTime = null;
    if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';


    if (gameOverlayEl) gameOverlayEl.classList.remove('visible');
    if (gameStartMessageEl) gameStartMessageEl.style.display = 'none';
    if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');

    document.body.classList.remove('game-mode-active');

    if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl) {
        const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
        if (gameInternalControlsBar && soundSettingsEl.parentNode !== originalSoundParent) {
            originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        }
        if (gameInternalControlsBar && themeSettingsEl.parentNode !== originalThemeParent) {
            originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
        }
        if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode && gameInternalControlsBar && gameInternalControlsBar.contains(gameToggleSoundBtn)) {
             if (gameToggleSoundBtn.parentNode) gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
            gameToggleSoundBtn = null;
        }
    }
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
    }


    let lastPracticeMode = 'kor';
    const activePracticeButton = document.querySelector('.practice-mode-controls button.active[data-mode]');
    if(activePracticeButton && activePracticeButton.id !== 'gameModeBtn'){
        lastPracticeMode = activePracticeButton.dataset.mode;
    } else {
        const firstPracticeBtn = document.querySelector('.practice-mode-controls button[data-mode]:not(#gameModeBtn)');
        if (firstPracticeBtn) {
            lastPracticeMode = firstPracticeBtn.dataset.mode;
        }
    }
    startPractice(lastPracticeMode, resetSessionStats);
}
</script>
</body>
</html>
