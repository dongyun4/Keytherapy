<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - 온라인 타자연습 & 게임</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}


#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}


    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Noto Sans KR', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Noto Sans KR', 'Courier New', monospace;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ub20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);

      --font-size-typing: 1.15rem;
      --typing-letter-spacing: 0.85px;
      --typing-word-spacing: 1.9px;
      --font-size-typing-mobile: 1.05rem;
      --typing-letter-spacing-mobile: 0.5px;
      --typing-word-spacing-mobile: 1.5px;

      --font-size-input: 1.13rem;
      --letter-spacing-input: 0.4px;
      --font-size-input-mobile: 1.03rem;
      --letter-spacing-input-mobile: 0.4px;


      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;

      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);

      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);

      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;

    }
    .light-theme {
      --bg-main: #fdfaf6;
      --bg-container: #fff;
      --bg-typing-area: #f9f5f0;
      --bg-progress-bar: #c0a580;
      --bg-progress-bar-track: #ede7de;
      --text-primary: #524a42;
      --text-secondary: #756A5F;
      --accent-primary: #b89a6c;
      --accent-secondary: #c8ad82;
      --accent-active: #a88a5c;
      --accent-darker: #987b4f;
      --accent-rgb: 184, 154, 108;
      --accent-primary-rgb: 184, 154, 108;
      --input-bg: #fefcf9;
      --input-text: #4a4037;
      --input-border: #dcd3c9;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.25);
      --button-text: #4a4037;
      --button-text-on-accent: #fefcf9;
      --current-line-bg: rgba(var(--accent-rgb), 0.06);
      --current-line-text: #504840;
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.25);
      --current-line-shadow: 0 2px 8px rgba(var(--accent-rgb),0.1);
      --highlight-error: #d3546d;
      --highlight-error-bg: rgba(211, 84, 109, 0.07);
      --shadow-soft: 0 6px 20px rgba(170, 150, 130, 0.08);
      --shadow-inset: inset 0 1px 2px rgba(0,0,0,0.025);
      --shadow-button: 0 3px 8px rgba(170, 150, 130, 0.07);
      --shadow-button-hover: 0 5px 12px rgba(170, 150, 130, 0.1);
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: flex-start;
        padding-top: 3vh;
    }

    /* ▼▼▼ 집중 모드 CSS 추가 ▼▼▼ */
    body.focus-mode-active {
        overflow: hidden;
    }
    body.focus-mode-active .main-content-wrapper {
        padding: 0;
        align-items: stretch;
    }
    body.focus-mode-active .main-content {
        max-width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    body.focus-mode-active .hero-section,
    body.focus-mode-active .controls-and-stats-wrapper,
    body.focus-mode-active .footer {
        display: none !important;
    }
    body.focus-mode-active #freestyle-area-container {
        height: 100%;
        border-radius: 0;
    }
    /* ▲▲▲ 집중 모드 CSS 추가 ▲▲▲ */


    .main-content {
      max-width: 1000px;
      width: 100%; background-color: var(--bg-container);
      border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
      display: flex; flex-direction: column; overflow: hidden;
      border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
      transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out;
    }
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }

    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper .practice-mode-controls,
    body.game-mode-active .controls-and-stats-wrapper .feature-toggles,
    body.game-mode-active .controls-and-stats-wrapper .selection-controls,
    body.game-mode-active .controls-and-stats-wrapper #stats,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #freestyle-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.freestyle-mode-active .typing-area-container,
    body.freestyle-mode-active .progress-bar-container,
    body.freestyle-mode-active #game-area-container,
    body.freestyle-mode-active #keyboard-guide.visible {
        display: none !important;
    }
    #freestyle-area-container { display: none; }
    body.freestyle-mode-active #freestyle-area-container { display: flex; }


    body.game-mode-active .controls-and-stats-wrapper { padding-bottom: 0; }
    body.game-mode-active .settings-container { margin-bottom: 0; }
    body.game-mode-active .main-controls { justify-content: center; gap: 15px; }
    body.game-mode-active .sound-settings,
    body.game-mode-active .theme-settings { display: flex !important; margin-left: 0; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }

    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 35px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      transition: border-radius 0.3s ease;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper { padding: 25px 25px 15px; }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }

    .main-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }

    .control-button-group button.disabled,
    .selection-controls .disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
        background: transparent !important;
        color: var(--text-secondary) !important;
        border-color: var(--input-border) !important;
        box-shadow: none !important;
        transform: none !important;
    }

    .practice-mode-controls,
    .feature-toggles {
        width: 100%;
        justify-content: center;
    }
    .practice-mode-controls button { min-width: 100px; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }

    .selection-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        width: 100%;
    }

    .language-settings, .sound-settings, .theme-settings {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }

    #languageSelect, #soundPackSelect, #themeSelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #languageSelect:focus, #soundPackSelect:focus, #themeSelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 15px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 8px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }


    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc((var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }

    .typing-line {
        width: 100%; max-width: 700px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        font-weight: 400;
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        text-align: left;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.25s ease, color 0.25s ease, background-color 0.25s ease, box-shadow 0.25s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        display: flex;
        align-items: center;
        background-color: transparent;
        white-space: pre-wrap;
    }

    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }

    .typing-line strong {
        color: var(--current-line-typed-text);
    }

    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }

    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }

    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }

    #typing-input-field-container {
        width: 100%;
        max-width: 700px;
        margin: 2px auto 0 auto;
        position: relative;
    }

    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }

    .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;

        font-family: var(--font-typing);
        font-size: var(--font-size-input);
        letter-spacing: var(--letter-spacing-input);
        word-spacing: var(--typing-word-spacing);
        line-height: var(--line-height-typing);
        font-weight: 400;
        box-sizing: border-box;
    }

    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }

    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }

    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-input) * 1.2);
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: middle;
        margin-left: -1px;
    }

    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }

    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}


    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }

#returnToPracticeBtnGame {
  padding: 12px 24px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--accent-primary);
  border: 2px solid rgba(var(--accent-rgb), 0.4);
  background-color: transparent;
  transition: all 0.25s ease;
  box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
}

#returnToPracticeBtnGame:hover {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-active);
  box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
}
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }


#gameToggleSoundBtn {
  padding: 10px 16px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 500;
  font-size: 0.9em;
  border: 1.5px solid var(--accent-secondary);
  background-color: transparent;
  color: var(--accent-secondary);
  transition: all 0.25s ease;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: var(--shadow-button);
}

#gameToggleSoundBtn.active {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-primary);
  font-weight: 600;
}

    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
        backdrop-filter: blur(3px);
        -webkit-backdrop-filter: blur(3px);
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    .game-overlay h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin-bottom: 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .game-overlay p {
        font-size: 1.15em; color: var(--text-secondary);
        line-height: 1.65; max-width: 480px; margin-bottom: 25px;
    }
    .light-theme .game-overlay h2, .pink-theme .game-overlay h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 10px 5px;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}

      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .language-settings,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings { width: 100%; justify-content: center; }
      .feature-toggles button { min-width: 100px; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }

      .typing-line {
          font-size: var(--font-size-typing-mobile);
          letter-spacing: var(--typing-letter-spacing-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      .fake-input-field {
          font-size: var(--font-size-input-mobile);
          letter-spacing: var(--letter-spacing-input-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-input-mobile) * 1.2); }

      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .game-overlay h2 { font-size: 1.6em; }
      .game-overlay p { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .language-settings, .sound-settings, .theme-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }


    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .feature-toggles button { min-width: 90px; }
      .select-label { font-size: 0.85em; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line {
          font-size: calc(var(--font-size-typing-mobile) * 0.95);
      }
      .fake-input-field {
          font-size: calc(var(--font-size-input-mobile) * 0.95);
      }

      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .game-overlay h2 { font-size: 1.4em; }
      .game-overlay p { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }

.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}

.hero-section a:hover {
  transform: scale(1.03);
}

.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}

.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}

.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}

.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}

#keyboard-guide {
    display: none;
    margin-bottom: 25px;
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 800px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}

.keys-wrapper {
    display: flex;
    width: fit-content;
}


.row-1 .keys-wrapper {
    transform: translateX(-29px);
}

.row-2 .keys-wrapper {
    transform: translateX(5px);
}

.row-3 .keys-wrapper {
    transform: translateX(-25px);
}

.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    width: 50px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
}

.keyboard-key .key-main-char {
    font-weight: 600;
    font-size: 1.1em;
    color: var(--text-primary);
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
}

#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char { font-size: 1.2em; }

.keyboard-key[data-key="shift"] { width: 87px; }
.keyboard-key[data-key="enter"] { width: 55px; }
.keyboard-key[data-key="space"] { width: 332px; }

.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.18);
}
.light-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.15);
}
.pink-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.12);
}


.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}

.light-theme .keyboard-key.highlight-key,
.pink-theme .keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
}
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}

@media (max-width: 820px) {
    #keyboard-guide { padding: 10px; }
    .keyboard-key { width: 42px; height: 42px; font-size: 0.8em; }
    .row-1 .keys-wrapper { transform: translateX(-25px); }
    .row-2 .keys-wrapper::before { width: 5px; }
    .row-3 .keys-wrapper::before { width: 10px; }
    .keyboard-key[data-key="shift"] { width: 73px; }
    .keyboard-key[data-key="enter"] { width: 73px; }
    .keyboard-key[data-key="space"] { width: 278px; }
}

@media (max-width: 480px) {
    #keyboard-guide { padding: 5px; }
    .keyboard-key { width: 28px; height: 35px; font-size: 0.7em; margin: 0 2px; border-radius: 4px;}
    .row-1 .keys-wrapper { transform: translateX(-16px); }
    .row-2 .keys-wrapper::before { width: 5px; }
    .row-3 .keys-wrapper::before { width: 10px; }
    .keyboard-key[data-key="shift"] { width: 48px; }
    .keyboard-key[data-key="enter"] { width: 48px; }
    .keyboard-key[data-key="space"] { width: 184px; }
}

/* ▼▼▼ 글쓰기 모드 개선 CSS ▼▼▼ */
#freestyle-area-container {
    padding: 20px 25px 28px;
    background-color: var(--bg-typing-area);
    border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    flex-grow: 1;
    display: none; /* <--- 이렇게 'none'으로 변경해주세요. */
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
    min-height: 400px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
}

#freestyle-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    position: relative;
    align-items: center;
}
.freestyle-tool-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.toolbar-divider {
    width: 1px;
    height: 20px;
    background-color: var(--input-border);
    margin: 0 4px;
}

.freestyle-tool-btn {
    background-color: var(--input-bg);
    color: var(--text-secondary);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 8px 12px;
    font-family: var(--font-ui);
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.freestyle-tool-btn:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
    border-color: var(--accent-secondary);
}
.freestyle-tool-btn i {
    margin-right: 6px;
    width: 14px;
    text-align: center;
}
#focusModeBtn { margin-left: auto; } /* 집중 모드 버튼을 오른쪽으로 */

#emoji-picker {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    transform: translateY(5px);
    background-color: var(--bg-container);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    padding: 10px;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    z-index: 10;
}
#emoji-picker.visible {
    display: grid;
}
#emoji-picker span {
    font-size: 1.4em;
    cursor: pointer;
    text-align: center;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
#emoji-picker span:hover {
    background-color: var(--bg-main);
}


#freestyle-input-area {
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 15px;
    font-family: var(--font-typing);
    font-size: var(--font-size-input);
    line-height: var(--line-height-typing);
    resize: vertical;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    box-sizing: border-box;
}
#freestyle-input-area:focus {
    outline: none;
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#freestyle-input-area::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
    transition: opacity 0.3s;
}
#freestyle-input-area:focus::placeholder {
    opacity: 0.3;
}

#freestyle-stats-bar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 15px;
    padding: 8px 5px;
    font-size: 0.85em;
    color: var(--text-secondary);
    font-family: var(--font-ui);
}

.freestyle-download-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin-top: 15px;
}
#freestyle-filename-input {
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 10px 12px;
    font-family: var(--font-ui);
    font-size: 0.9em;
    outline: none;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    width: 200px;
}
#freestyle-filename-input:focus {
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#download-freestyle-btn {
    padding: 10px 20px;
    font-size: 0.9em;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    border: 1.5px solid var(--accent-primary);
    background: var(--accent-primary);
    color: var(--button-text-on-accent);
    box-shadow: var(--shadow-button);
    transition: all 0.2s ease;
}
#download-freestyle-btn:hover {
    background: var(--accent-active);
    border-color: var(--accent-active);
    transform: translateY(-1px);
    box-shadow: var(--shadow-button-hover);
}
#download-freestyle-btn i {
    margin-right: 8px;
}

@media (max-width: 768px) {
    #freestyle-area-container {
        padding: 15px;
        min-height: 350px;
    }
    #freestyle-input-area {
        min-height: 250px;
    }
}
@media (max-width: 480px) {
    .freestyle-download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    #freestyle-filename-input, #download-freestyle-btn {
        width: 100%;
        box-sizing: border-box;
    }
    #freestyle-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    .freestyle-tool-group {
        justify-content: space-around;
    }
    #focusModeBtn { margin-left: 0; }
}
/* ▲▲▲ 글쓰기 모드 개선 CSS ▲▲▲ */
</style>
</head>
<body class=""> <!-- body에 active 클래스 제거 -->
  <div class="main-content-wrapper"> <div class="main-content">
    <div class="hero-section">
        <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
            <h1 class="hero-title">Key Therapy</h1>
            <p class="hero-tagline">깊은 수면과 집중을 위한<br>🎧키보드 타건 ASMR🎧</p>
        </a>
    </div>
  <div class="controls-and-stats-wrapper">
    <div class="settings-container">
        <div class="main-controls">
            <div class="practice-mode-controls control-button-group">
                <button data-practice-type="short"><i class="fas fa-language"></i> 단문 연습</button>
                <button data-practice-type="long"><i class="fas fa-align-left"></i> 장문 연습</button>
                <button data-practice-type="freestyle"><i class="fas fa-pencil-alt"></i> 글쓰기</button>
                <button id="gameModeBtn"><i class="fas fa-gamepad"></i> 게임하기</button>
            </div>

            <div class="feature-toggles control-button-group">
                <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
                <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> 자리연습 OFF</button>
            </div>

            <div class="selection-controls">
                <div class="sound-settings" id="soundSettingsElement">
                    <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                    <select id="soundPackSelect">
                        <option value="crunchy">서걱서걱</option>
                        <option value="pebbles">조약돌</option>
                        <option value="thocky">도각도각</option>
                    </select>
                </div>
                <div class="language-settings">
                    <label for="languageSelect" class="select-label">언어:</label>
                    <select id="languageSelect">
                        <option value="kor">한글</option>
                        <option value="eng">영어</option>
                    </select>
                </div>
                <div class="theme-settings" id="themeSettingsElement">
                    <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                    <select id="themeSelect">
                        <option value="dark">다크</option>
                        <option value="light">아이보리</option>
                        <option value="pink">핑크</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    <div id="stats">
        <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
        <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
        <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
        <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
    </div>
</div>
<div class="progress-bar-container">
    <div class="progress-bar"></div>
</div>
<div class="typing-area-container">
    <div id="keyboard-guide"></div>
    <div id="line-display-area"> </div>
    <div id="typing-input-field-container">
        <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
        <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
    </div>
    <div id="upcoming-lines-area"> </div>
</div>
<!-- ▼▼▼ 글쓰기 모드 컨테이너 (개선됨) ▼▼▼ -->
<div id="freestyle-area-container">
    <div id="freestyle-toolbar">
        <div class="freestyle-tool-group">
            <button id="insertDateBtn" class="freestyle-tool-btn" title="오늘 날짜 삽입"><i class="fas fa-calendar-alt"></i></button>
            <button id="insertTimeBtn" class="freestyle-tool-btn" title="현재 시간 삽입"><i class="fas fa-clock"></i></button>
            <button id="emojiBtn" class="freestyle-tool-btn" title="이모티콘"><i class="far fa-smile"></i></button>
             <div id="emoji-picker">
                <span>😊</span><span>😂</span><span>😍</span><span>🤔</span><span>👍</span><span>❤️</span>
                <span>🎉</span><span>✨</span><span>🔥</span><span>😭</span><span>🙏</span><span>⭐</span>
            </div>
        </div>
        <div class="toolbar-divider"></div>
        <div class="freestyle-tool-group">
            <button id="formatBoldBtn" class="freestyle-tool-btn" title="굵게"><i class="fas fa-bold"></i></button>
            <button id="formatItalicBtn" class="freestyle-tool-btn" title="기울임꼴"><i class="fas fa-italic"></i></button>
            <button id="insertHrBtn" class="freestyle-tool-btn" title="구분선"><i class="fas fa-minus"></i></button>
        </div>
        <button id="focusModeBtn" class="freestyle-tool-btn" title="집중 모드 (ESC로 해제)"><i class="fas fa-expand"></i></button>
    </div>
    <textarea id="freestyle-input-area" placeholder="오늘 하루는 어땠나요? 당신의 이야기를 자유롭게 기록해보세요..."></textarea>
    <div id="freestyle-stats-bar">
        <span id="charCount">0자</span>
        <span id="wordCount">0단어</span>
    </div>
    <div class="freestyle-download-controls">
        <input type="text" id="freestyle-filename-input" placeholder="파일 이름 (선택사항)">
        <button id="download-freestyle-btn"><i class="fas fa-download"></i> 텍스트 파일로 저장</button>
    </div>
</div>
<!-- ▲▲▲ 글쓰기 모드 컨테이너 (개선됨) ▲▲▲ -->
<div id="game-area-container">
</div>
<div id="result"></div>
</div>
</div>
  <div class="footer"> <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> </div>

<script>
// === 전역 변수 및 설정 ===
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = [];

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;

// ▼▼▼ 글쓰기 모드 관련 전역 변수 추가 ▼▼▼
let freestyleStatsInterval = null;
let freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl;
let freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker;
let formatBoldBtn, formatItalicBtn, insertHrBtn, focusModeBtn;
let charCountEl, wordCountEl;
// ▲▲▲ 글쓰기 모드 관련 전역 변수 추가 ▲▲▲

// DOM 요소 참조 변수들
let languageSelectEl, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameOverlayEl, gameStartMessageEl, itemEffectPopupEl;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;

let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;
let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;


let currentSoundPack = 'crunchy';
const soundFiles = {
    pebbles: Array.from({length: 7}, (_, i) => `soundFiles/pebbles/pebble${i + 1}.wav`),
    crunchy: Array.from({length: 11}, (_, i) => `soundFiles/crunchy/crunchy${i + 1}.wav`),
    thocky: Array.from({length: 10}, (_, i) => `soundFiles/thocky/thocky${i + 1}.wav`)
};
let audioPool = {};
const MAX_AUDIO_OBJECTS = 8;
let audioPointer = {};

// === RAINFALL GAME MODE VARIABLES ===
let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: '시간', icon: '⏱️' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: '소멸', icon: '💨' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: '생명', icon: '❤️' }
};
const rainfall_gameMainLevelsConfig = [
    // Level 1: Very Easy
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    // Level 2
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    // Level 3
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    // Level 4
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    // Level 5
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    // Level 6
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    // Level 7
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    // Level 8
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    // Level 9
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    // Level 10: Very Hard
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];

// === LETTER BLOCK BATTLE GAME MODE VARIABLES ===
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];

let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };

let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;

const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';

let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;


const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '⭐' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: '🔥' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '❄️' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '↔️' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;

let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
// === TYPING BATTLE GAME MODE VARIABLES ===
let gb_isGameActive = false;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000;
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;


const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
// --- END TYPING BATTLE ---

const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "황사", "일기", "예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "보드카", "데킬라", "하이볼", "탄산수",
    "비행기", "기차", "버스", "택시", "자전거", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신", "우주인", "방울뱀", "사막여우",
    "가로등", "가위질", "가정교사", "가족사진", "가지각색", "갈림길", "갈림돌", "감사패", "감정표현", "강강술래", "개발자", "거북선", "건강검진", "건널목", "검정고시", "결혼기념", "경기장", "경찰관", "경호원", "계란후라이", "고속도로", "고인돌", "골목대장", "공기놀이", "공중전화", "공휴일", "과일가게", "과학상자", "관광버스", "광화문", "구급상자", "국회의원", "군고구마", "그림일기", "극장", "기념품", "기상캐스터", "기차여행", "긴급상황", "김장독", "까마귀", "까치밥", "꽃다발", "꿀벌", "꿈나라", "끝말잇기", "나무늘보", "나비넥타이", "낙하산", "낚시꾼", "난센스퀴즈", "날개", "남대문", "낭떠러지", "내비게이션", "냉장고", "네잎클로버", "노랫소리", "노트북", "놀이공원", "농구공", "눈사람", "다리미", "다람쥐", "다이아몬드", "단풍잎", "달리기", "닭꼬치", "담벼락", "당근", "대통령", "대한민국", "도서관", "독수리", "돈가스", "돌고래", "동물원", "두부", "두통약", "드라이기", "등산화", "디지털카메라", "라면", "라디오", "로봇", "리모컨", "마라톤", "마법사", "만두", "만리장성"
].map(word => word.trim());

function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

const sentencePool = { kor: ["따뜻한 햇살이 창가에 가득 내린다.", "반짝이는 별빛 아래 소중한 추억을 그려본다.", "대한민국 서울특별시 아름다운 우리 강산 푸르게 푸르게."], eng: ["The weather is lovely today perfect for a nice walk.", "Actions speak louder than words."], korLong: [ "낡은 골목의 초입, 허리 굽은 노파의 손길이 햇살에 바래진 담벼락을 어루만진다. 그녀의 손가락 마디마디에 지난 세월의 주름이 강물처럼 새겨져 있었고, 그 마디 끝에서 스며 나온 이야기들이 무성한 담쟁이덩굴처럼 벽을 휘감았다. 담쟁이 잎사귀들은 바람에 지난날의 속삭임처럼 흔들렸고, 그 사이로 비치는 햇살은 희미한 기억의 파편들을 흩뿌렸다. 노파의 발걸음은 더 이상 빠르지 않았다. 한 걸음, 한 걸음 옮길 때마다 아스팔트 바닥에 찍히는 그림자는 더욱 길고 아득해졌다. 그녀는 문득 걸음을 멈춰 서서, 오래된 전봇대 아래 놓인 작은 벤치에 앉았다. 벤치 옆에는 누군가. 그 꽃을 가슴에 품고, 우리는 묵묵히 저물어가는 하루를매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다."], engLong: [ "The old attic window, streaked with theornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding."]
};

function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}

document.addEventListener('DOMContentLoaded', () => {
  // DOM 요소 참조 변수 초기화 (let -> const로 변경하여 안정성 향상)
  languageSelectEl = document.getElementById('languageSelect');
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');

  // 글쓰기 모드 요소 초기화
  freestyleAreaContainerEl = document.getElementById('freestyle-area-container');
  freestyleInputAreaEl = document.getElementById('freestyle-input-area');
  downloadFreestyleBtnEl = document.getElementById('download-freestyle-btn');
  freestyleFilenameInputEl = document.getElementById('freestyle-filename-input');
  freestyleToolbarEl = document.getElementById('freestyle-toolbar');
  insertDateBtn = document.getElementById('insertDateBtn');
  insertTimeBtn = document.getElementById('insertTimeBtn');
  emojiBtn = document.getElementById('emojiBtn');
  emojiPicker = document.getElementById('emoji-picker');
  formatBoldBtn = document.getElementById('formatBoldBtn');
  formatItalicBtn = document.getElementById('formatItalicBtn');
  insertHrBtn = document.getElementById('insertHrBtn');
  focusModeBtn = document.getElementById('focusModeBtn');
  charCountEl = document.getElementById('charCount');
  wordCountEl = document.getElementById('wordCount');

  // 기타 UI 요소
  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  const allElements = [languageSelectEl, lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl, freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl, freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker, formatBoldBtn, formatItalicBtn, insertHrBtn, focusModeBtn, charCountEl, wordCountEl];
  if (!allElements.every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다. 누락된 요소를 확인해주세요.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }

  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;

  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;

  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';


  initializeAudioPool();
  buildKeyboard();

  document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(button => {
    button.addEventListener('click', function() {
      const type = this.dataset.practiceType;
      if (type === 'freestyle') {
          startFreestyleMode();
      } else {
          const lang = languageSelectEl.value;
          const mode = (type === 'long') ? `${lang}Long` : lang;
          startPractice(mode, true);
      }
    });
  });

  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => activateGameMode('rainfall'));
  }

  languageSelectEl.addEventListener('change', () => {
    if (currentMode !== 'freestyle') {
      const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
      const type = activePracticeBtn ? activePracticeBtn.dataset.practiceType : 'short';
      if(type !== 'freestyle'){
          const lang = languageSelectEl.value;
          const mode = (type === 'long') ? `${lang}Long` : lang;
          startPractice(mode, true);
      }
    }
  });

  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';

  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }

  typingInputField.addEventListener('input', handleInputEvent);

  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }

  document.body.addEventListener('click', function(e) {
    if (emojiPicker.classList.contains('visible') && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
        emojiPicker.classList.remove('visible');
    }

    const isInteractiveElement = e.target.closest('button, a, select, input, textarea, #emoji-picker span');

    if (!isInteractiveElement) {
      if (document.body.classList.contains('game-mode-active')) {
        if (gameInputField && !gameInputField.disabled) gameInputField.focus();
      } else if (document.body.classList.contains('freestyle-mode-active')) {
        if (freestyleInputAreaEl) freestyleInputAreaEl.focus();
      } else {
        if (typingInputField && !typingInputField.disabled) typingInputField.focus();
      }
    }
  });

  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });

  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl && linesToPractice[currentDisplayLineIndex] !== undefined) {
        handleHighlightUpdate(currentLineEl, typingInputField.value, linesToPractice[currentDisplayLineIndex]);
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    if (audioPool[currentSoundPack] && (audioPointer[currentSoundPack] === undefined || audioPointer[currentSoundPack] === null) ) {
        audioPointer[currentSoundPack] = 0;
    } else if (!audioPool[currentSoundPack]) {
        initializeAudioPoolForPack(currentSoundPack);
    }
  });

  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });

  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });

  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> 자리연습 ON' : '<i class="far fa-keyboard"></i> 자리연습 OFF';

    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }

    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });

  // ▼▼▼ 글쓰기 모드 이벤트 리스너 추가 ▼▼▼
  freestyleInputAreaEl.addEventListener('input', () => {
      playTypingSound();
      if (!startTime) {
          startTime = Date.now();
      }
      updateFreestyleStats();
  });
  freestyleInputAreaEl.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
          playTypingSound();
      }
  });
  downloadFreestyleBtnEl.addEventListener('click', handleFreestyleDownload);
  insertDateBtn.addEventListener('click', insertDate);
  insertTimeBtn.addEventListener('click', insertTime);
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('visible');
  });
  emojiPicker.querySelectorAll('span').forEach(emoji => {
    emoji.addEventListener('click', () => {
        insertAtCursor(freestyleInputAreaEl, emoji.textContent);
        emojiPicker.classList.remove('visible');
        freestyleInputAreaEl.focus();
    });
  });
  formatBoldBtn.addEventListener('click', () => wrapSelectionWithTag(freestyleInputAreaEl, '**'));
  formatItalicBtn.addEventListener('click', () => wrapSelectionWithTag(freestyleInputAreaEl, '*'));
  insertHrBtn.addEventListener('click', () => insertAtCursor(freestyleInputAreaEl, '\n\n---\n\n'));
  focusModeBtn.addEventListener('click', toggleFocusMode);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.body.classList.contains('focus-mode-active')) {
        toggleFocusMode();
    }
  });
  // ▲▲▲ 글쓰기 모드 이벤트 리스너 추가 ▲▲▲

  startPractice('kor', true);
});

function cleanupActiveModes() {
    document.body.classList.remove('game-mode-active', 'freestyle-mode-active', 'focus-mode-active');

    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);
    if (freestyleStatsInterval) clearInterval(freestyleStatsInterval);

    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    freestyleStatsInterval = null;
    startTime = null;

    if(typingInputField) typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    if(gameInputField) gameInputField.removeEventListener('keydown', handleKeyDownEvent);

    enablePracticeControls();
}

function disableFreestyleControls() {
    toggleHighlightBtn.classList.add('disabled');
    toggleKeyboardGuideBtn.classList.add('disabled');
    languageSelectEl.closest('.language-settings').classList.add('disabled');
}

function enablePracticeControls() {
    toggleHighlightBtn.classList.remove('disabled');
    toggleKeyboardGuideBtn.classList.remove('disabled');
    languageSelectEl.closest('.language-settings').classList.remove('disabled');
}

function startPractice(mode, resetSessionStats = false) {
    cleanupActiveModes();

    currentMode = mode;
    currentGameType = '';

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === (mode.includes('Long') ? 'long' : 'short'));
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    if(resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';

    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }

    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }

    currentLineStartTime = null;
    currentArticleCorrectChars = 0;

    currentDisplayLineIndex = 0;
    const poolToUse = sentencePool[currentMode];
    let textToPractice = getRandom(poolToUse);
    if (!textToPractice && poolToUse && poolToUse.length > 0) textToPractice = poolToUse[0];
    if (!textToPractice) textToPractice = "예문 로딩에 실패했습니다.";

    linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if (linesToPractice.length === 0) {
        linesToPractice.push(textToPractice.includes("실패") ? textToPractice : "예문 처리 중 오류가 발생했습니다.");
    }

    if (currentMode.includes('Long') && linesToPractice.length > 1) {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'block';
    } else {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();

    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}


function startFreestyleMode() {
    cleanupActiveModes();
    document.body.classList.add('freestyle-mode-active');
    currentMode = 'freestyle';

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === 'freestyle');
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    disableFreestyleControls();

    if (toggleHighlightBtn.classList.contains('active')) toggleHighlightBtn.classList.remove('active');
    if (toggleKeyboardGuideBtn.classList.contains('active')) toggleKeyboardGuideBtn.classList.remove('active');
    highlightEnabled = false;
    keyboardGuideEnabled = false;
    if (keyboardGuideEl) keyboardGuideEl.classList.remove('visible');


    if (resultEl) resultEl.textContent = '자유롭게 글을 작성하고 타건을 즐겨보세요.';

    startTime = null;
    overallMaxSpeed = 0;
    overallAvgSpeedLog = [];
    sessionTotalValidChars = 0;
    sessionTotalCorrectChars = 0;
    sessionTotalMistypedChars = 0;
    lastArticleSpeed = 0;
    updateStatsDisplay(true);

    if (document.getElementById('accuracyStat')) document.getElementById('accuracyStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('avgSpeedStat')) document.getElementById('avgSpeedStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('maxSpeedStat')) document.getElementById('maxSpeedStat').innerHTML = '<span class="value">—</span>';

    freestyleInputAreaEl.value = '';
    freestyleInputAreaEl.focus();

    updateFreestyleStats();
    if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    freestyleStatsInterval = setInterval(updateFreestyleStats, 500);
}

function updateFreestyleStats() {
    if (currentMode !== 'freestyle') {
        if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
        return;
    };
    const text = freestyleInputAreaEl.value;
    const charLength = text.length;
    const wordLength = text.trim().split(/\s+/).filter(Boolean).length;

    charCountEl.textContent = `${charLength}자`;
    wordCountEl.textContent = `${wordLength}단어`;

    if (startTime) { // 시작 시간이 기록되었는지 먼저 확인
        const elapsedMinutes = (Date.now() - startTime) / 60000; // <--- 변수를 여기서 선언합니다.
        if (elapsedMinutes > 0) {
            const speed = Math.round((charLength / elapsedMinutes) * KOR_SPEED_FACTOR);
            if (document.getElementById('speedStat')) {
                document.getElementById('speedStat').textContent = `${speed} 타/분`;
            }
        }
    }
}
function handleFreestyleDownload() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        alert('저장할 내용이 없습니다.');
        return;
    }

    let filename = freestyleFilenameInputEl.value.trim();
    if (filename === '') {
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        filename = `keytherapy_${timestamp}`;
    }

    if (!filename.toLowerCase().endsWith('.txt')) {
        filename += '.txt';
    }

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function insertAtCursor(myField, myValue) {
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length;
        myField.selectionEnd = startPos + myValue.length;
    } else {
        myField.value += myValue;
    }
    updateFreestyleStats();
    myField.focus();
}

function wrapSelectionWithTag(field, tag) {
    const start = field.selectionStart;
    const end = field.selectionEnd;
    const selectedText = field.value.substring(start, end);
    const replacement = tag + selectedText + tag;
    
    field.setRangeText(replacement, start, end, 'end');

    if (selectedText.length === 0) {
        field.setSelectionRange(start + tag.length, start + tag.length);
    }
    updateFreestyleStats();
    field.focus();
}

function insertDate() {
    const now = new Date();
    const dateString = `${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일`;
    insertAtCursor(freestyleInputAreaEl, dateString + " ");
}

function insertTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const formattedHours = (hours % 12) || 12;
    const timeString = `${ampm} ${formattedHours}:${minutes}`;
    insertAtCursor(freestyleInputAreaEl, timeString + " ");
}

function toggleFocusMode() {
    document.body.classList.toggle('focus-mode-active');
    const icon = focusModeBtn.querySelector('i');
    if (document.body.classList.contains('focus-mode-active')) {
        icon.classList.remove('fa-expand');
        icon.classList.add('fa-compress');
    } else {
        icon.classList.remove('fa-compress');
        icon.classList.add('fa-expand');
    }
    freestyleInputAreaEl.focus();
}

function applyTheme(theme) {
    document.body.classList.remove('light-theme', 'pink-theme');
    if (theme === 'light') document.body.classList.add('light-theme');
    else if (theme === 'pink') document.body.classList.add('pink-theme');

    if (gameCanvas && currentGameType) {
        requestAnimationFrame(() => {
            if (currentGameType === 'rainfall') drawRainfallGame();
            else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
            else if (currentGameType === 'giantBattle') drawGiantBattleGame();
        });
    }
}


function initializeAudioPoolForPack(packKey) {
    if (soundFiles.hasOwnProperty(packKey) && (!audioPool[packKey] || audioPool[packKey].length === 0)) {
        audioPool[packKey] = [];
        audioPointer[packKey] = 0;
        for (let i = 0; i < MAX_AUDIO_OBJECTS; i++) {
            const audio = new Audio();
            audio.preload = 'auto';
            audioPool[packKey].push(audio);
        }
    }
}

function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}

function splitTextIntoLines(text, mode, screenWidth) {
    let maxLength;
    if (mode.includes('Long')) {
        if (screenWidth <= 480) maxLength = mode.includes('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.includes('eng') ? 55 : 35;
        else maxLength = mode.includes('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }

    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.includes('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}

function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';

    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();

    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.textContent = passedLineText;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);

    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');

    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        handleHighlightUpdate(currentEl, "", currentLineText);
    } else {
        currentEl.textContent = ' ';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);

    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = upcomingLineText;
            fragmentUpcoming.appendChild(upcomingEl);
        } else {
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = ' ';
            upcomingEl.style.visibility = 'hidden';
            fragmentUpcoming.appendChild(upcomingEl);
        }
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
}

function handleInputEvent(e) {
    if ((currentMode !== 'game' && e.target === typingInputField) || (currentMode === 'game' && e.target === gameInputField)) {
        playTypingSound();
    }

    if (currentMode !== 'game' && currentMode !== 'freestyle' && e.target === typingInputField) {
        const typedValue = typingInputField.value;
        const currentLineEl = document.getElementById('current-typing-line');
        if (!currentLineEl) return;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        handleHighlightUpdate(currentLineEl, typedValue, originalLine);
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight();
    }
}

function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;
    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">타자 연습 시작...</span><span id="cursor"></span>`;
        return;
    }

    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span id="cursor"></span>`;
    } else {
        fakeInputField.innerHTML = `${typedValue}<span id="cursor"></span>`;
    }
}


function handleHighlightUpdate(targetElement, typedValue, originalLine) {
    if (!targetElement) return;
    if (typeof originalLine !== 'string') {
        targetElement.textContent = ' ';
        return;
    }
    let builtHTML = "";
    for (let i = 0; i < originalLine.length; i++) {
        const char = originalLine[i];

        if (i < typedValue.length) {
            if (highlightEnabled && typedValue[i] !== originalLine[i]) {
                builtHTML += `<span class="highlight">${char}</span>`;
            } else {
                builtHTML += `<strong>${char}</strong>`;
            }
        } else {
            builtHTML += `<span class="untyped-char">${char}</span>`;
        }
    }
    targetElement.innerHTML = builtHTML || ' ';
}

function handleKeyDownEvent(e) {
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const targetInput = e.target;

    if (e.isComposing) return;

    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }

    if (currentMode !== 'game' && currentMode !== 'freestyle' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;

        if (e.key === 'Backspace' || (e.key === 'Shift' && !e.repeat && !isModifierKey)) {
            playTypingSound();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            playTypingSound();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            playTypingSound();
            processCurrentLineCompletion();
        } else if (e.key === ' ' && originalLine !== null) {
            playTypingSound();
        }
    }
}


function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }

    let lineCorrectCharsThisLine = 0;
    let lineMistypedCharsOnThisLine = 0;

    for (let i = 0; i < originalLine.length; i++) {
        if (i < typedValue.length) {
            if (typedValue[i] === originalLine[i]) {
                lineCorrectCharsThisLine++;
            } else {
                lineMistypedCharsOnThisLine++;
            }
        } else {
            lineMistypedCharsOnThisLine++;
        }
    }
    if (typedValue.length > originalLine.length) {
        lineMistypedCharsOnThisLine += (typedValue.length - originalLine.length);
    }

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;

    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }


    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;

    if (!currentMode.includes('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }

    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '장문 완료! 새로운 문제 준비 중...' : '연습 완료! 새로운 문제 준비 중...';
        if (currentMode.includes('Long')) {
            currentArticleCorrectChars = 0;
            startTime = null;
        }
        setTimeout(() => startPractice(currentMode, false), 200);
    }
}

function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;

  let currentSpeedToShow = 0;
  if (isSessionReset) {
      currentSpeedToShow = 0;
  } else if (startTime === null && !currentMode.includes('Long')) {
      currentSpeedToShow = lastArticleSpeed;
  } else if (currentMode.includes('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;

  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;

  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;

  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} 타/분`;
}


function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.includes('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}

function playTypingSound() {
  if (!soundEnabled || !currentSoundPack || !soundFiles[currentSoundPack] || !audioPool[currentSoundPack]) return;

  const soundPackSounds = soundFiles[currentSoundPack];
  const currentAudioPoolForPack = audioPool[currentSoundPack];

  if (soundPackSounds.length === 0 || currentAudioPoolForPack.length === 0) return;

  const soundSrc = getRandom(soundPackSounds);
  if (!soundSrc) return;

  let foundAvailableAudio = false;
  for (let i = 0; i < currentAudioPoolForPack.length; i++) {
      const audioIndex = (audioPointer[currentSoundPack] + i) % currentAudioPoolForPack.length;
      let audioToPlay = currentAudioPoolForPack[audioIndex];

      if (audioToPlay && audioToPlay.paused) {
          audioPointer[currentSoundPack] = (audioIndex + 1) % currentAudioPoolForPack.length;
          audioToPlay.src = soundSrc;
          const playPromise = audioToPlay.play();
          if (playPromise !== undefined) {
              playPromise.catch(error => { /* console.warn("Audio play failed:", error); */ });
          }
          foundAvailableAudio = true;
          break;
      }
  }

  if (!foundAvailableAudio) {
      let audioToPlay = currentAudioPoolForPack[audioPointer[currentSoundPack]];
      audioPointer[currentSoundPack] = (audioPointer[currentSoundPack] + 1) % currentAudioPoolForPack.length;
      if (audioToPlay) {
        audioToPlay.src = soundSrc;
        const playPromise = audioToPlay.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => { /* console.warn("Fallback audio play failed:", error); */ });
        }
      }
  }
}

function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// --- GAME MODE ENTRY POINT ---
function activateGameMode(gameType) {
    cleanupActiveModes();
    document.body.classList.add('game-mode-active');

    currentMode = 'game';
    currentGameType = gameType;

    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }

    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);

    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;


    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;

    gameStartMessageEl = document.getElementById('game-start-message');
    gameCanvas = document.getElementById('game-canvas');
    if (gameCanvas) gameCtx = gameCanvas.getContext('2d');
    else console.error("activateGameMode: game-canvas 요소를 찾을 수 없습니다.");

    gameInputField = document.getElementById('game-input-field');
    gameOverlayEl = document.getElementById('gameOverlay');
    itemEffectPopupEl = document.getElementById('item-effect-popup');
    lbbTimerBarContainerEl = document.getElementById('lbb-timer-bar-container');
    lbbTimerBarEl = document.getElementById('lbb-timer-bar');
    lbbTimerTextEl = document.getElementById('lbb-timer-text');

    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }

    const gameTypeRow = document.getElementById('gameTypeSelectionRow');
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => activateGameMode('rainfall'));
    gameTypeRow.appendChild(sonagiBtn);

    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => activateGameMode('letterBlockBattle'));
    gameTypeRow.appendChild(letterBlockBtn);

    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> 타이핑 배틀';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => activateGameMode('giantBattle'));
    gameTypeRow.appendChild(typingBattleBtn);

    const settingsRow1 = document.getElementById('gameSettingsRow1');
    const settingsRow2 = document.getElementById('gameSettingsRow2');
    settingsRow1.innerHTML = ''; settingsRow2.innerHTML = '';

    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);

    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);

    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);

    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';

    let maxLevelForSelect;
    let currentLevelForSelect;

    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }

    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
    gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }
        if (isActive) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);

    settingsRow2.appendChild(levelControlItem);

    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);

    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);

    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }

    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 생명)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3초 멈춤)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (화면 정리)</div>
             </div>
             <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>상하좌우 블록의 단어를 입력하여 이동하고, 적과 빈 칸으로 연결되면 승리합니다!<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> 타이핑 배틀</h2>
            <p>쏟아지는 단어들을 정확히 입력하여 적의 공격을 막아내고,<br>당신의 공격 단어로 적을 격파하세요! 2분 안에 승리하세요!</p>
            <p>레벨을 선택하고 게임 시작 버튼을 누르세요.</p>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";

    document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.classList.add('active');
    }
}

function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}


// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);

    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}

function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }

        drawRainfallGame();

        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }

        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}

function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }

    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error("Rainfall: Invalid game level configuration for level " + rainfall_gameLevel);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) {
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}

function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }

    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`점수: ${rainfall_gameScore}`, 15, 30);

    gameCtx.textAlign = 'center';
    gameCtx.fillText(`레벨: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);

    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`생명: ${'❤️'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;

        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;

        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}


function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    function generateWord() {
        if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;

        let newWordText;
        let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
        let itemDetails = null;

        if (isItem) {
            const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
            itemDetails = getRandom(itemTypes);
            newWordText = itemDetails.text;
        } else {
            const wordPool = gameWordsKor.filter(w => w.length <= 4);
            const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
            newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
            if (!newWordText) newWordText = '단어';
        }

        rainfall_usedWordsInLevel.add(newWordText);
        if (rainfall_usedWordsInLevel.size > 100) {
            const oldestWord = rainfall_usedWordsInLevel.values().next().value;
            rainfall_usedWordsInLevel.delete(oldestWord);
        }

        const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

        rainfall_wordsOnScreen.push({
            text: newWordText,
            x: Math.random() * (gameCanvas.width - 100) + 50,
            y: -20,
            speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
            isFast: isFast,
            itemType: isItem ? itemDetails.type : null,
            color: isItem ? itemDetails.color : null,
            duration: isItem ? itemDetails.duration : 0
        });
    }

    generateWord();
    rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
}


function handleRainfallGameInputSubmit() {
    if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
    const typedWord = gameInputField.value.trim();
    if (typedWord === "") return;

    let wordFound = false;
    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        const wordToMatch = word.text;

        if (typedWord === wordToMatch) {
            if (word.itemType) {
                activateRainfallItemEffect(word.itemType, word.duration);
            } else {
                rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
            }

            rainfall_wordsOnScreen.splice(i, 1);
            wordFound = true;
            break;
        }
    }

    if (!wordFound) {
        if(gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    gameInputField.value = "";
}

function activateRainfallItemEffect(itemType, duration) {
    let popupText = "";
    const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
    if (!itemInfo) return;

    switch(itemType) {
        case 'extraLife':
            if (rainfall_gameLives < 10) rainfall_gameLives++;
            popupText = `생명 +1 ${itemInfo.icon}`;
            break;
        case 'timeStop':
            rainfall_isTimeStopped = true;
            popupText = `시간 정지! ${itemInfo.icon}`;
            if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
            window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
            break;
        case 'clearScreen':
            popupText = `화면 정리! ${itemInfo.icon}`;
            for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                if (!rainfall_wordsOnScreen[j].itemType) {
                    rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                    rainfall_wordsOnScreen.splice(j, 1);
                }
            }
            break;
    }
    if (popupText) showGamePopup(popupText, 1500);
}


function triggerRainfallLifeLostEffect() {
    if (gameCanvas) {
        gameCanvas.classList.add('flash-effect');
        setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
    }
}


// --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
    if(level) lbb_gameLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    lbb_playerNoPlayableBlocksTimerId = null;
    if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    lbb_relocationCountdownIntervalId = null;

    lbb_isGameActive = true;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_isRelocating = false;

    lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];

    lbb_playerScore = 0;
    lbb_enemyScore = 0;

    generateLBBGameBoard();
    lbb_playerPos = { r: 0, c: 0 };
    lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
    lbb_enemyOriginalStartPos = { ...lbb_enemyPos };

    if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
        lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
    }
    if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
        lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
    }

    if (gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    lbb_gameStartTime = Date.now();
    lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
    startLBBGameLoop();
}

function startLBBGameLoop() {
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    function loop() {
        if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
            cancelAnimationFrame(lbb_gameLoopId);
            lbb_gameLoopId = null;
            return;
        }
        drawLetterBlockBattleGame();
        if(lbb_isGameActive && !lbb_gamePausedForOverlay){
            updateLBBGameLogic();
        }
        lbb_gameLoopId = requestAnimationFrame(loop);
    }
    lbb_gameLoopId = requestAnimationFrame(loop);
}

function updateLBBGameLogic() {
    if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

    if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
        return;
    }

    if (lbb_swapEffect.active) {
        updateLBBSwapAnimation();
    } else if (lbb_finalBattleAnimation.isActive) {
        updateLBBFinalBattleAnimation();
    } else {
        if (!lbb_isRelocating) {
             checkAndTriggerPlayerLBBRelocation();
        }
    }

    lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
    lbb_blockBreakParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.alpha -= 0.02;
    });
}

function drawLetterBlockBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
    const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
    const boardX = (gameCanvas.width - boardWidth) / 2;
    const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

    const bodyClasses = document.body.classList;
    let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
        inputBgColor = '#fefcf9';
        brokenColor = '#f9f5f0';
        playerBlockBg = '#fffacd';
        playerColor = '#4A90E2';
        enemyColor = '#D0021B';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
        inputBgColor = '#fffafa';
        brokenColor = '#fff5f8';
        playerBlockBg = '#ffe8f0';
        playerColor = '#E91E63';
        enemyColor = '#7B1FA2';
    } else {
        textColor = '#e8e0d8';
        inputBgColor = '#33302e';
        brokenColor = '#262422';
        playerBlockBg = 'rgba(212, 175, 122, 0.08)';
        playerColor = 'dodgerblue';
        enemyColor = 'tomato';
    }

    const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
            if (!block) continue;

            const x = boardX + c * LBB_BLOCK_SIZE;
            const y = boardY + r * LBB_BLOCK_SIZE;

            gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

            if (!block.broken) {
                const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                if (isPlayerAdjacent) {
                    gameCtx.fillStyle = playerBlockBg;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }

                gameCtx.font = lbb_blockTextFont;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillStyle = block.effect.color || textColor;
                gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                if (block.effect.icon) {
                    gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                    gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                }
            }
            gameCtx.strokeStyle = borderColor;
            gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
        }
    }

    lbb_blockBreakParticles.forEach(p => {
        gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
        gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
    });

    function drawCharacter(pos, color, isPlayer) {
        const x = boardX + pos.c * LBB_BLOCK_SIZE;
        const y = boardY + pos.r * LBB_BLOCK_SIZE;
        gameCtx.fillStyle = color;
        gameCtx.beginPath();
        gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
        gameCtx.fill();
        if (isPlayer) {
            gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.lineWidth = 1;
        }
    }

    if (lbb_swapEffect.active) {
        drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
        drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
    } else if (lbb_finalBattleAnimation.isActive) {
        drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
        drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
    } else {
        drawCharacter(lbb_playerPos, playerColor, true);
        drawCharacter(lbb_enemyPos, enemyColor, false);
    }

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.textAlign = 'left';
    gameCtx.fillStyle = playerColor;
    gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 15, 30);
    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = enemyColor;
    gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
    gameCtx.textAlign = 'center';
    gameCtx.fillStyle = textColor;
    gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);

    if (lbb_relocationCountdown > 0) {
        gameCtx.font = "bold 16px 'Poppins', sans-serif";
        gameCtx.fillStyle = 'orange';
        gameCtx.textAlign = 'center';
        gameCtx.fillText(`길을 찾는 중... ${lbb_relocationCountdown}초`, gameCanvas.width / 2, gameCanvas.height - 20);
    }

    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && lbb_isGameActive) {
        const elapsedTime = Date.now() - lbb_gameStartTime;
        const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
        if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
        const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}


function generateLBBGameBoard() {
    lbb_gameBoard = [];
    const wordPoolSource = gameWordsKor;
    const wordPool = wordPoolSource.filter(word => word.length >= 2 && word.length <= 3);

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        lbb_gameBoard[r] = [];
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const effectRoll = Math.random();
            let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
            if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                const itemRoll = Math.random();
                if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
            }
            lbb_gameBoard[r][c] = {
                word: getRandom(wordPool.length > 0 ? wordPool : wordPoolSource),
                broken: false,
                effect: effectType
            };
        }
    }
}

function getSurroundingLBBBlocks(pos, checkBroken = true) {
    const blocks = [];
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    for (const [dr, dc] of directions) {
        const r = pos.r + dr;
        const c = pos.c + dc;

        if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
            const block = lbb_gameBoard[r][c];
            if (!checkBroken || (block && !block.broken)) {
                blocks.push({ ...block, r, c });
            }
        }
    }
    return blocks;
}

function handleLetterBlockBattleInputSubmit() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
    const typedWord = gameInputField.value.trim();
    if (!typedWord) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);

    const matchedBlock = surroundingBlocks.find(block => {
        if (!block) return false;
        return block.word === typedWord;
    });

    if (matchedBlock) {
        lbb_playerMoveAndBreak(matchedBlock);
        checkLBBBattleCondition();
    } else {
        if (gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    if (gameInputField) gameInputField.value = '';
}

function lbb_playerMoveAndBreak(targetBlock) {
    lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
    const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
    block.broken = true;

    lbb_playerScore += block.effect.score;
    lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
    if (block.effect.effect) {
        lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
    }
}

function lbb_enemyAIAction() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
    if(surroundingBlocks.length > 0) {
        if (lbb_enemyNoPlayableBlocksTimerId) {
            clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
            lbb_enemyNoPlayableBlocksTimerId = null;
        }
        const targetBlock = getRandom(surroundingBlocks);
        lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
        const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
        block.broken = true;
        lbb_enemyScore += block.effect.score;
        lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
        if (block.effect.effect) {
             lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
        }
        checkLBBBattleCondition();
    } else {
        if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
            lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(false);
                lbb_enemyNoPlayableBlocksTimerId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
        }
    }
}

function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
    lbb_gamePausedForEffect = true;
    let popupText = '';

    switch (effect) {
        case 'freezeEnemy':
            if (isPlayer) {
                lbb_isEnemyFrozen = true;
                popupText = `적 정지! ${icon}`;
                if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
            }
            break;
        case 'swapPositions':
            lbb_swapEffect.active = true;
            lbb_swapEffect.step = 0;
            lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
            lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
            lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
            lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
            popupText = `위치 변경! ${icon}`;
            break;
    }

    if (popupText) {
        showGamePopup(popupText, 1500);
    }

    setTimeout(() => {
        if(effect !== 'swapPositions') lbb_gamePausedForEffect = false;
    }, 500);
}

function updateLBBSwapAnimation() {
    if (!lbb_swapEffect.active) return;

    lbb_swapEffect.step++;
    const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

    const playerTarget = lbb_swapEffect.enemyOld;
    const enemyTarget = lbb_swapEffect.playerOld;

    lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
    lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;

    lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
    lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;

    if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
        lbb_swapEffect.active = false;
        lbb_playerPos = { ...playerTarget };
        lbb_enemyPos = { ...enemyTarget };
        lbb_gamePausedForEffect = false;
    }
}
function lbb_triggerBlockBreakEffect(r, c, colorHex) {
    const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
    for (let i = 0; i < 15; i++) {
        lbb_blockBreakParticles.push({
            x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            ...colorRgb,
            alpha: 1
        });
    }
}

function checkLBBBattleCondition() {
    const path = findPath(lbb_playerPos, lbb_enemyPos);
    if (path) {
        lbb_triggerFinalBattleAnimation(path);
    }
}

function findPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([`${start.r},${start.c}`]);

    while (queue.length > 0) {
        const [current, path] = queue.shift();

        if (current.r === end.r && current.c === end.c) {
            return path;
        }

        const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);

        for (const neighbor of neighbors) {
            const posKey = `${neighbor.r},${neighbor.c}`;
            if (!visited.has(posKey)) {
                visited.add(posKey);
                const newPath = [...path, neighbor];
                queue.push([neighbor, newPath]);
            }
        }
    }
    return null;
}

function lbb_triggerFinalBattleAnimation(pathToMeet) {
    if (lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.isActive = true;
    lbb_finalBattleAnimation.step = 0;
    lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
}

function updateLBBFinalBattleAnimation() {
    if (!lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.step++;
    const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;

    const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
    const meetingC = lbb_finalBattleAnimation.meetingPoint.c;

    lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
    lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;

    if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
        lbb_finalBattleAnimation.isActive = false;
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
    }
}

function checkAndTriggerPlayerLBBRelocation() {
    if(lbb_isRelocating) return;
    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    if(surroundingBlocks.length === 0){
        if(!lbb_playerNoPlayableBlocksTimerId) {
            lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
            lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(true);
                lbb_playerNoPlayableBlocksTimerId = null;
                clearInterval(lbb_relocationCountdownIntervalId);
                lbb_relocationCountdownIntervalId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

            lbb_relocationCountdownIntervalId = setInterval(() => {
                lbb_relocationCountdown--;
                if(lbb_relocationCountdown <= 0) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
            }, 1000);
        }
    } else {
        if (lbb_playerNoPlayableBlocksTimerId) {
            clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
        }
        if(lbb_relocationCountdownIntervalId) {
            clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;
        }
        lbb_relocationCountdown = 0;
    }
}
function lbb_initiateRelocation(isPlayerRelocation) {
    if (isPlayerRelocation) {
        lbb_isRelocating = true;
        showGamePopup("길이 막혔습니다! 재배치합니다...", 2000);
        setTimeout(() => lbb_performRelocation(true), 1000);
    } else {
        lbb_performRelocation(false);
    }
}

function lbb_performRelocation(isPlayerRelocation) {
    const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
    const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);

    if(newPos) {
        if(isPlayerRelocation) {
            lbb_playerPos = newPos;
        } else {
            lbb_enemyPos = newPos;
        }
        lbb_gameBoard[newPos.r][newPos.c].broken = true;
    } else {
        handleGameEnd(false, "stuck");
    }
    if (isPlayerRelocation) {
       lbb_isRelocating = false;
    }
}

function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
    const allSpots = [];
    for(let r=0; r<boardRows; r++){
        for(let c=0; c<boardCols; c++){
            if(!lbb_gameBoard[r][c].broken){
                 const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                 if(dist >= minDistanceFromOpponent){
                    allSpots.push({r, c});
                 }
            }
        }
    }
    return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
}


// === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
    if (level) gb_currentLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    }

    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);

    gb_isGameActive = true;
    gb_gamePausedForOverlay = false;
    gb_playerHealth = GB_MAX_PLAYER_HEALTH;
    gb_enemyAttacks = [];
    gb_gameStartTime = Date.now();
    gb_enemyHitEffectTimer = 0;

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    gb_enemyHealth = currentLevelConfig.enemyHealth;

    gb_spawnPlayerAttackWord();

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
      setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    gb_enemyAttackIntervalId = setInterval(gb_spawnEnemyAttack, currentLevelConfig.attackInterval);

    startGiantBattleGameLoop();
}

function startGiantBattleGameLoop() {
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    function loop() {
        if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
             cancelAnimationFrame(gb_gameLoopId);
             gb_gameLoopId = null;
             return;
        }
        drawGiantBattleGame();
        if (gb_isGameActive && !gb_gamePausedForOverlay) {
            updateGiantBattleGameLogic();
        }
        gb_gameLoopId = requestAnimationFrame(loop);
    }
    gb_gameLoopId = requestAnimationFrame(loop);
}

function updateGiantBattleGameLogic() {
    if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

    if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
        handleGameEnd(gb_playerHealth > gb_enemyHealth, "timeUp");
        return;
    }

    if (gb_enemyHitEffectTimer > 0) {
        gb_enemyHitEffectTimer -= 1000 / 60;
        if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
    }

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
        const attack = gb_enemyAttacks[i];
        attack.y += currentLevelConfig.attackSpeed;

        const attackObjectHeight = 40;
        const playerHpBarY = gameCanvas.height - 35 - 18;
        const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;


        if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
            gb_enemyAttacks.splice(i, 1);
            gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
            const damageText = attack.isSpecial ? `특별 공격 피격! 🔥` : `피격! 🤕`;
            showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
            if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

            if (gb_playerHealth <= 0) {
                gb_playerHealth = 0;
                handleGameEnd(false, "hp");
                return;
            }
        } else if (attack.y > gameCanvas.height + attackObjectHeight) {
             gb_enemyAttacks.splice(i, 1);
        }
    }

    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
        return;
    }
}

function drawGiantBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let mainTextColor, accentColor, specialAttackColor;
    if (bodyClasses.contains('light-theme')) {
        mainTextColor = '#524a42';
        accentColor = '#b89a6c';
        specialAttackColor = '#b89a6c';
    } else if (bodyClasses.contains('pink-theme')) {
        mainTextColor = '#4F333D';
        accentColor = '#E85D75';
        specialAttackColor = '#E85D75';
    } else {
        mainTextColor = '#e8e0d8';
        accentColor = '#d4af7a';
        specialAttackColor = '#d4af7a';
    }

    function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
        const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();

        gameCtx.fillStyle = bgColor;
        gameCtx.fillRect(x, y, width, height);

        const healthPercentage = Math.max(0, currentHealth) / maxHealth;
        const currentHealthWidth = width * healthPercentage;

        const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, healthColor);
        gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
        gameCtx.fillStyle = gradient;
        gameCtx.fillRect(x, y, currentHealthWidth, height);

        gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
        gameCtx.fillRect(x, y, currentHealthWidth, height / 2);

        if (label) {
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 12px 'Poppins', sans-serif";
            gameCtx.textAlign = textAlign;
            gameCtx.textBaseline = "bottom";
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
            gameCtx.shadowBlur = 0;
        }
    }

    function hexToDarker(hex, percent) {
      let { r, g, b } = hexToRgb(hex);
      r = parseInt(r * (1 - percent));
      g = parseInt(g * (1 - percent));
      b = parseInt(b * (1 - percent));
      return `rgb(${r}, ${g}, ${b})`;
    }

    const topUiY = 30;
    const uiMargin = 15;
    const healthBarHeight = 18;

    const enemyHealthBarWidth = gameCanvas.width * 0.3;
    drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "적 HP", 'right');

    const playerAreaBottomMargin = 50;
    const playerHpBarWidth = gameCanvas.width * 0.3;
    const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
    const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
    drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "플레이어 HP", 'right');

    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = mainTextColor;
    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(`레벨: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

    if (gb_gameStartTime) {
        const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
        const minutes = Math.floor(remainingTime / 60000);
        const seconds = Math.floor((remainingTime % 60000) / 1000);
        gameCtx.font = "bold 14px 'Poppins', sans-serif";
        gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
    }

    const attackWordBoxHeight = 40;
    const attackWordBoxWidth = gameCanvas.width * 0.3;
    const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
    const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20;

    gameCtx.strokeStyle = accentColor;
    gameCtx.lineWidth = 2;
    gameCtx.beginPath();
    gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
    gameCtx.stroke();
    gameCtx.lineWidth = 1;

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.fillStyle = accentColor;
    gameCtx.textAlign = "center";
    gameCtx.textBaseline = "middle";
    gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
    gameCtx.shadowBlur = 2;
    gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);

    gameCtx.font = "bold 24px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
    gameCtx.shadowBlur = 5;
    gameCtx.shadowOffsetX = 1;
    gameCtx.shadowOffsetY = 1;

    for (const attack of gb_enemyAttacks) {
        gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
        if (attack.isSpecial) {
            gameCtx.shadowColor = accentColor;
            gameCtx.shadowBlur = 10;
        } else {
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
        }
        gameCtx.fillText(attack.word, attack.x, attack.y);
    }
    gameCtx.shadowBlur = 0;
    gameCtx.shadowOffsetX = 0;
    gameCtx.shadowOffsetY = 0;
}

function gb_spawnPlayerAttackWord() {
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "공격";
}

function gb_spawnDefenseWord(currentLevelConfig) {
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "수비";
}


function gb_spawnEnemyAttack() {
    if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;

    let word = "";
    let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
    let originalWordForSpecial = "";
    const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);


    if (isSpecialAttack) {
        const specialMinLen = 4;
        const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
        word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || "강타";
        originalWordForSpecial = word;
    } else {
        const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
        word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || "돌격";
    }

    const startY = -20;

    gb_enemyAttacks.push({
        word: word,
        originalWord: isSpecialAttack ? originalWordForSpecial : word,
        x: Math.random() * (gameCanvas.width - 100) + 50,
        y: startY,
        speed: currentLevelConfig.attackSpeed,
        element: 'rock',
        isSpecial: isSpecialAttack
    });
}

function handleGiantBattleInputSubmit() {
    if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
    const typedWordFull = gameInputField.value.trim();
    if (typedWordFull === "") return;

    const typedWord = typedWordFull;

    const playerAttackWordToMatch = gb_playerAttackWord;
    if (typedWord === playerAttackWordToMatch) {
        gb_playerAttack();
        if(gameInputField) gameInputField.value = "";
        return;
    }

    const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
    for (let i = 0; i < sortedEnemyAttacks.length; i++) {
        const enemyAttack = sortedEnemyAttacks[i];
        const enemyWordToMatch = enemyAttack.word;

        if (typedWord === enemyWordToMatch) {
            if (enemyAttack.isSpecial) {
                enemyAttack.isSpecial = false;
                const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                showGamePopup("특수 공격 무력화! 🛡️", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
            } else {
                gb_playerDefend(enemyAttack);
            }
            if(gameInputField) gameInputField.value = "";
            return;
        }
    }

    if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
    setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    if(gameInputField) gameInputField.value = "";
}

function gb_playerAttack() {
    gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
    gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
    showGamePopup(`명중! 💥`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
    gb_spawnPlayerAttackWord();
    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
    }
}

function gb_playerDefend(rock) {
    const index = gb_enemyAttacks.indexOf(rock);
    if (index > -1) {
        gb_enemyAttacks.splice(index, 1);
        showGamePopup("방어! 🛡️", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
    }
}

// --- 공통 게임 함수 (오버레이, 연습모드 복귀 등) ---
function handleGameEnd(playerWins, reason = "") {
    rainfall_isGameActive = false; lbb_isGameActive = false; gb_isGameActive = false;
    rainfall_gamePausedForOverlay = true; lbb_gamePausedForOverlay = true; gb_gamePausedForOverlay = true;
    if (gameInputField) gameInputField.disabled = true;

    if (rainfall_gameLoopId) { cancelAnimationFrame(rainfall_gameLoopId); rainfall_gameLoopId = null; }
    if (lbb_gameLoopId) { cancelAnimationFrame(lbb_gameLoopId); lbb_gameLoopId = null; }
    if (gb_gameLoopId) { cancelAnimationFrame(gb_gameLoopId); gb_gameLoopId = null; }
    if (rainfall_wordGenerationIntervalId) { clearInterval(rainfall_wordGenerationIntervalId); rainfall_wordGenerationIntervalId = null; }
    if (lbb_enemyActionIntervalId) { clearInterval(lbb_enemyActionIntervalId); lbb_enemyActionIntervalId = null; }
    if (gb_enemyAttackIntervalId) { clearInterval(gb_enemyAttackIntervalId); gb_enemyAttackIntervalId = null; }

    let gameConfig, currentLevel, score;
    const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

    if (currentGameType === 'rainfall') {
        gameConfig = { name: '소나기', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
        currentLevel = rainfall_gameLevel;
        score = rainfall_gameScore;
    } else if (currentGameType === 'letterBlockBattle') {
        gameConfig = { name: '블록 배틀', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
        currentLevel = lbb_gameLevel;
        score = lbb_playerScore;
    } else if (currentGameType === 'giantBattle') {
        gameConfig = { name: '타이핑 배틀', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
        currentLevel = gb_currentLevel;
        score = Math.round(gb_playerHealth);
    } else {
        return;
    }

    const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;

    if (reason === 'level_change') {
        showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
        return;
    }

    if (playerWins && currentLevel < gameConfig.maxLevel) {
        const nextLevel = currentLevel + 1;
        const title = `<i class="fas fa-crown"></i> 레벨 ${currentLevel} 클리어!`;
        const body = `잠시 후 다음 레벨(${nextLevel})을 시작합니다...`;

        gameOverlayEl.innerHTML = `<h2>${title}</h2><p>${body}</p>`;
        gameOverlayEl.classList.add('visible');

        setTimeout(() => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = nextLevel;
            updateDropdown(nextLevel);
            showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
        }, 2500);
        return;
    }

    let title, body, nextStepButtonText, nextStepAction;

    if (playerWins) {
        title = `<i class="fas fa-trophy"></i> 모든 레벨 클리어!`;
        if (currentGameType === 'letterBlockBattle') {
            body = `플레이어 점수: ${lbb_playerScore}<br>적 점수: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `플레이어 HP: ${score}<br>적 HP: ${gb_enemyHealth}`;
        } else {
             body = `최종 점수: ${score}`;
        }
        nextStepButtonText = '<i class="fas fa-redo"></i> 처음부터 다시';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = 1;
            updateDropdown(1);
            showCountdownThenStart(gameConfig.initFunc, [true, 1]);
        };
    } else {
        title = `<i class="fas fa-skull-crossbones"></i> 게임 오버`;
        if (reason === 'timeUp' && ( (currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > gb_enemyHealth) )) {
             title = `<i class="far fa-clock"></i> 시간 종료! (판정승)`;
        } else if (reason === 'timeUp') {
            title = `<i class="far fa-clock"></i> 시간 종료!`;
        }

        if (currentGameType === 'letterBlockBattle') {
            body = `플레이어 점수: ${lbb_playerScore}<br>적 점수: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `플레이어 HP: ${Math.round(gb_playerHealth)}<br>적 HP: ${Math.round(gb_enemyHealth)}`;
        } else {
            body = `최종 점수: ${score}<br>달성 레벨: ${currentLevel}`;
        }

        nextStepButtonText = '<i class="fas fa-redo"></i> 다시 도전';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            const levelToRetry = selectedLevelInDropdown;
            window[gameConfig.levelVarName] = levelToRetry;
            updateDropdown(levelToRetry);
            showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
        };
    }

    gameOverlayEl.innerHTML = `
        <h2>${title}</h2><p>${body}</p>
        <button id="nextStepBtnOverlay" class="game-button">${nextStepButtonText}</button>
        <button id="returnToPracticeOverlayBtn" class="game-button" style="background: var(--text-secondary); border-color: var(--text-secondary);"><i class="fas fa-keyboard"></i> 타자연습 가기</button>`;
    gameOverlayEl.classList.add('visible');
    document.getElementById('nextStepBtnOverlay').addEventListener('click', nextStepAction);
    document.getElementById('returnToPracticeOverlayBtn').addEventListener('click', () => returnToPracticeMode(true));
}


function showCountdownThenStart(startGameFunction, args = [true, 1]) {
    if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';

    let count = 3;
    const countdown = () => {
        const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];

        if (drawFunc) drawFunc();

        if (count > 0) {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 80px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            count--;
            setTimeout(countdown, 1000);
        } else {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 70px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            setTimeout(() => {
                startGameFunction(...args);
            }, 500);
        }
    };
    countdown();
}


function returnToPracticeMode(resetSessionStats = true) {
    cleanupActiveModes();

    const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
    if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
        if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
             originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        }
        if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
            originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
        }
    }
    if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
        gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
        gameToggleSoundBtn = null;
    }

    let lastPracticeMode = 'kor';
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (activePracticeBtn && languageSelectEl) {
        const type = activePracticeBtn.dataset.practiceType;
        const lang = languageSelectEl.value;
        if(type !== 'freestyle' && type !== 'game'){
            lastPracticeMode = (type === 'long') ? `${lang}Long` : lang;
        }
    }

    updateKeyboardDisplay();
    updateKeyboardHighlight();
    startPractice(lastPracticeMode, resetSessionStats);
}
const charToKeyMap = {
    'ㅂ': 'q', 'ㅈ': 'w', 'ㄷ': 'e', 'ㄱ': 'r', 'ㅅ': 't', 'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅔ': 'p',
    'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l',
    'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
    'ㅃ': 'q', 'ㅉ': 'w', 'ㄸ': 'e', 'ㄲ': 'r', 'ㅆ': 't', 'ㅒ': 'o', 'ㅖ': 'p',
    '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
    '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?' : '/'
};

const Hangul = (() => {
    const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
    const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const HANGUL_OFFSET = 0xAC00;

    const disassemble = (str) => {
        return str.split('').map(char => {
            const code = char.charCodeAt(0);
            if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                const uniValue = code - HANGUL_OFFSET;
                const jong = uniValue % 28;
                const jung = Math.floor((uniValue - jong) / 28) % 21;
                const cho = Math.floor(uniValue / (21 * 28));
                
                const result = [CHO[cho]];
                const jungJamo = JUNG[jung];
                
                switch(jungJamo) {
                    case 'ㅘ': result.push('ㅗ', 'ㅏ'); break;
                    case 'ㅙ': result.push('ㅗ', 'ㅐ'); break;
                    case 'ㅚ': result.push('ㅗ', 'ㅣ'); break;
                    case 'ㅝ': result.push('ㅜ', 'ㅓ'); break;
                    case 'ㅞ': result.push('ㅜ', 'ㅔ'); break;
                    case 'ㅟ': result.push('ㅜ', 'ㅣ'); break;
                    case 'ㅢ': result.push('ㅡ', 'ㅣ'); break;
                    default: result.push(jungJamo); break;
                }
                
                if (jong > 0) {
                    const jongJamo = JONG[jong];
                    switch(jongJamo) {
                        case 'ㄳ': result.push('ㄱ', 'ㅅ'); break;
                        case 'ㄵ': result.push('ㄴ', 'ㅈ'); break;
                        case 'ㄶ': result.push('ㄴ', 'ㅎ'); break;
                        case 'ㄺ': result.push('ㄹ', 'ㄱ'); break;
                        case 'ㄻ': result.push('ㄹ', 'ㅁ'); break;
                        case 'ㄼ': result.push('ㄹ', 'ㅂ'); break;
                        case 'ㄽ': result.push('ㄹ', 'ㅅ'); break;
                        case 'ㄾ': result.push('ㄹ', 'ㅌ'); break;
                        case 'ㄿ': result.push('ㄹ', 'ㅍ'); break;
                        case 'ㅀ': result.push('ㄹ', 'ㅎ'); break;
                        case 'ㅄ': result.push('ㅂ', 'ㅅ'); break;
                        default: result.push(jongJamo); break;
                    }
                }
                return result;
            }
            return [char];
        }).flat();
    };
    return { disassemble };
})();

function buildKeyboard() {
    keyboardGuideEl.innerHTML = '';
    const layout = [
        ['q','w','e','r','t','y','u','i','o','p','[',']'],
        ['a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
        ['z','x','c','v','b','n','m',',','.','/'],
        ['ShiftLeft', 'Space','ShiftRight']
    ];
    const keyInfo = {
        'q': { eng: 'Q', kor: 'ㅂ', shiftKor: 'ㅃ' }, 'w': { eng: 'W', kor: 'ㅈ', shiftKor: 'ㅉ' },
        'e': { eng: 'E', kor: 'ㄷ', shiftKor: 'ㄸ' }, 'r': { eng: 'R', kor: 'ㄱ', shiftKor: 'ㄲ' },
        't': { eng: 'T', kor: 'ㅅ', shiftKor: 'ㅆ' }, 'y': { eng: 'Y', kor: 'ㅛ' }, 'u': { eng: 'U', kor: 'ㅕ' },
        'i': { eng: 'I', kor: 'ㅑ' }, 'o': { eng: 'O', kor: 'ㅐ', shiftKor: 'ㅒ' }, 'p': { eng: 'P', kor: 'ㅔ', shiftKor: 'ㅖ' },
        'a': { eng: 'A', kor: 'ㅁ' }, 's': { eng: 'S', kor: 'ㄴ' }, 'd': { eng: 'D', kor: 'ㅇ' },
        'f': { eng: 'F', kor: 'ㄹ' }, 'g': { eng: 'G', kor: 'ㅎ' }, 'h': { eng: 'H', kor: 'ㅗ' },
        'j': { eng: 'J', kor: 'ㅓ' }, 'k': { eng: 'K', kor: 'ㅏ' }, 'l': { eng: 'L', kor: 'ㅣ' },
        'z': { eng: 'Z', kor: 'ㅋ' }, 'x': { eng: 'X', kor: 'ㅌ' }, 'c': { eng: 'C', kor: 'ㅊ' },
        'v': { eng: 'V', kor: 'ㅍ' }, 'b': { eng: 'B', kor: 'ㅠ' }, 'n': { eng: 'N', kor: 'ㅜ' }, 'm': { eng: 'M', kor: 'ㅡ' },
        '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, ';': { base: ';', shift: ':' },
        "'": { base: "'", shift: '"' }, ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' },
        '/': { base: '/', shift: '?' }
    };

    layout.forEach((row, index) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = `keyboard-row row-${index + 1}`;
        
        const keysWrapper = document.createElement('div');
        keysWrapper.className = 'keys-wrapper';

        row.forEach(keyId => {
            const keyDiv = document.createElement('div');
            const dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
            keyDiv.dataset.key = dataKey;
            keyDiv.classList.add('keyboard-key');

            const data = keyInfo[keyId];
            if (data) {
                const engMain = data.base || data.eng.toLowerCase();
                const engShift = data.shift || data.eng.toUpperCase();
                const korMain = data.kor || data.base || '';
                const korShift = data.shiftKor || data.shift || '';
                
                keyDiv.innerHTML = `
                    <div class="key-eng">
                        <span class="key-main-char">${engMain}</span>
                        <span class="key-shift-char">${engShift}</span>
                    </div>
                    <div class="key-kor">
                        <span class="key-main-char">${korMain}</span>
                        <span class="key-shift-char">${korShift}</span>
                    </div>
                `;
            } else {
                 keyDiv.classList.add('special');
                 keyDiv.textContent = keyId.replace(/Left|Right/, '');
            }
             if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId)) {
                keyDiv.classList.add('home-row-base');
            }
            keysWrapper.appendChild(keyDiv);
        });
        rowDiv.appendChild(keysWrapper);
        keyboardGuideEl.appendChild(rowDiv);
    });
}
function updateKeyboardDisplay() {
    if (!keyboardGuideEl) return;
    const isKorMode = currentMode.startsWith('kor');
    
    keyboardGuideEl.className = 'keyboard-guide';
    if (keyboardGuideEnabled) {
        keyboardGuideEl.classList.add('visible');
    }
    keyboardGuideEl.classList.add(isKorMode ? 'lang-kor' : 'lang-eng');
}

function clearKeyboardHighlight() {
    if (!keyboardGuideEl) return;
    const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
    highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
}

function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game' || currentMode === 'freestyle') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();
    
    const isKorMode = currentMode.startsWith('kor');
    let nextCharToPress;

    if (isKorMode) {
        const disassembledTyped = Hangul.disassemble(typingInputField.value);
        if (disassembledTyped.length < disassembledLine.length) {
            nextCharToPress = disassembledLine[disassembledTyped.length];
        }
    } else {
        const originalLine = linesToPractice[currentDisplayLineIndex];
        if (!originalLine) return;
        const typedValue = typingInputField.value;
        if (typedValue.length < originalLine.length) {
            nextCharToPress = originalLine[typedValue.length];
        }
    }
    
    if (!nextCharToPress) return;

    let keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    let isShiftNeeded = false;

    if (isKorMode) {
        if ('ㅃㅉㄸㄲㅆㅒㅖ'.includes(nextCharToPress)) {
            isShiftNeeded = true;
        }
    } else {
        if ( (nextCharToPress >= 'A' && nextCharToPress <= 'Z') || ('~!@#$%^&*()_+{}|:"<>?'.includes(nextCharToPress)) ) {
            isShiftNeeded = true;
        }
    }
    
    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}
</script>

</body>
</html>
```
