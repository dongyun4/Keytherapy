<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - 온라인 타자연습 & 게임</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}


#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}


    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Noto Sans KR', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Noto Sans KR', 'Courier New', monospace;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ub20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);

      --font-size-typing: 1.15rem;
      --typing-letter-spacing: 0.85px;
      --typing-word-spacing: 1.9px;
      --font-size-typing-mobile: 1.05rem;
      --typing-letter-spacing-mobile: 0.5px;
      --typing-word-spacing-mobile: 1.5px;

      --font-size-input: 1.13rem;
      --letter-spacing-input: 0.4px;
      --font-size-input-mobile: 1.03rem;
      --letter-spacing-input-mobile: 0.4px;


      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;

      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);

      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);

      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;

    }
    .light-theme {
      --bg-main: #fdfaf6;
      --bg-container: #fff;
      --bg-typing-area: #f9f5f0;
      --bg-progress-bar: #c0a580;
      --bg-progress-bar-track: #ede7de;
      --text-primary: #524a42;
      --text-secondary: #756A5F;
      --accent-primary: #b89a6c;
      --accent-secondary: #c8ad82;
      --accent-active: #a88a5c;
      --accent-darker: #987b4f;
      --accent-rgb: 184, 154, 108;
      --accent-primary-rgb: 184, 154, 108;
      --input-bg: #fefcf9;
      --input-text: #4a4037;
      --input-border: #dcd3c9;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.25);
      --button-text: #4a4037;
      --button-text-on-accent: #fefcf9;
      --current-line-bg: rgba(var(--accent-rgb), 0.06);
      --current-line-text: #504840;
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.25);
      --current-line-shadow: 0 2px 8px rgba(var(--accent-rgb),0.1);
      --highlight-error: #d3546d;
      --highlight-error-bg: rgba(211, 84, 109, 0.07);
      --shadow-soft: 0 6px 20px rgba(170, 150, 130, 0.08);
      --shadow-inset: inset 0 1px 2px rgba(0,0,0,0.025);
      --shadow-button: 0 3px 8px rgba(170, 150, 130, 0.07);
      --shadow-button-hover: 0 5px 12px rgba(170, 150, 130, 0.1);
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: flex-start;
        padding-top: 3vh;
    }

    /* ▼▼▼ 집중 모드 CSS 추가 ▼▼▼ */
    body.focus-mode-active {
        overflow: hidden;
    }
    body.focus-mode-active .main-content-wrapper {
        padding: 0;
        align-items: stretch;
    }
    body.focus-mode-active .main-content {
        max-width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    body.focus-mode-active .hero-section,
    body.focus-mode-active .controls-and-stats-wrapper,
    body.focus-mode-active .footer {
        display: none !important;
    }
    body.focus-mode-active #freestyle-area-container {
        height: 100%;
        border-radius: 0;
    }
    /* ▲▲▲ 집중 모드 CSS 추가 ▲▲▲ */


    .main-content {
      max-width: 1000px;
      width: 100%; background-color: var(--bg-container);
      border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
      display: flex; flex-direction: column; overflow: hidden;
      border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
      transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out;
    }
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }

    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper .practice-mode-controls,
    body.game-mode-active .controls-and-stats-wrapper .feature-toggles,
    body.game-mode-active .controls-and-stats-wrapper .selection-controls,
    body.game-mode-active .controls-and-stats-wrapper #stats,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #freestyle-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.freestyle-mode-active .typing-area-container,
    body.freestyle-mode-active .progress-bar-container,
    body.freestyle-mode-active #game-area-container,
    body.freestyle-mode-active #keyboard-guide.visible {
        display: none !important;
    }
    #freestyle-area-container { display: none; }
    body.freestyle-mode-active #freestyle-area-container { display: flex; }


    body.game-mode-active .controls-and-stats-wrapper { padding-bottom: 0; }
    body.game-mode-active .settings-container { margin-bottom: 0; }
    body.game-mode-active .main-controls { justify-content: center; gap: 15px; }
    body.game-mode-active .sound-settings,
    body.game-mode-active .theme-settings { display: flex !important; margin-left: 0; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }

    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 35px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      transition: border-radius 0.3s ease;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper { padding: 25px 25px 15px; }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }

    .main-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }

    .control-button-group button.disabled,
    .selection-controls .disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
        background: transparent !important;
        color: var(--text-secondary) !important;
        border-color: var(--input-border) !important;
        box-shadow: none !important;
        transform: none !important;
    }

    .practice-mode-controls,
    .feature-toggles {
        width: 100%;
        justify-content: center;
    }
    .practice-mode-controls button { min-width: 100px; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }

    .selection-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        width: 100%;
    }

    .language-settings, .sound-settings, .theme-settings {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }

    #languageSelect, #soundPackSelect, #themeSelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #languageSelect:focus, #soundPackSelect:focus, #themeSelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 15px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 8px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }


    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc((var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }

    .typing-line {
        width: 100%; max-width: 700px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        font-weight: 400;
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        text-align: left;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.25s ease, color 0.25s ease, background-color 0.25s ease, box-shadow 0.25s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        display: flex;
        align-items: center;
        background-color: transparent;
        white-space: pre-wrap;
    }

    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }

    .typing-line strong {
        color: var(--current-line-typed-text);
    }

    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }

    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }

    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }

    #typing-input-field-container {
        width: 100%;
        max-width: 700px;
        margin: 2px auto 0 auto;
        position: relative;
    }

    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }

    .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;

        font-family: var(--font-typing);
        font-size: var(--font-size-input);
        letter-spacing: var(--letter-spacing-input);
        word-spacing: var(--typing-word-spacing);
        line-height: var(--line-height-typing);
        font-weight: 400;
        box-sizing: border-box;
    }

    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }

    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }

    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-input) * 1.2);
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: middle;
        margin-left: -1px;
    }

    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }

    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}


    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }

#returnToPracticeBtnGame {
  padding: 12px 24px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--accent-primary);
  border: 2px solid rgba(var(--accent-rgb), 0.4);
  background-color: transparent;
  transition: all 0.25s ease;
  box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
}

#returnToPracticeBtnGame:hover {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-active);
  box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
}
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }


#gameToggleSoundBtn {
  padding: 10px 16px;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 500;
  font-size: 0.9em;
  border: 1.5px solid var(--accent-secondary);
  background-color: transparent;
  color: var(--accent-secondary);
  transition: all 0.25s ease;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: var(--shadow-button);
}

#gameToggleSoundBtn.active {
  background-color: var(--accent-primary);
  color: var(--button-text-on-accent);
  border-color: var(--accent-primary);
  font-weight: 600;
}

    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
        backdrop-filter: blur(3px);
        -webkit-backdrop-filter: blur(3px);
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    .game-overlay h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin-bottom: 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .game-overlay p {
        font-size: 1.15em; color: var(--text-secondary);
        line-height: 1.65; max-width: 480px; margin-bottom: 25px;
    }
    .light-theme .game-overlay h2, .pink-theme .game-overlay h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 10px 5px;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}

      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .language-settings,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings { width: 100%; justify-content: center; }
      .feature-toggles button { min-width: 100px; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }

      .typing-line {
          font-size: var(--font-size-typing-mobile);
          letter-spacing: var(--typing-letter-spacing-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      .fake-input-field {
          font-size: var(--font-size-input-mobile);
          letter-spacing: var(--letter-spacing-input-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-input-mobile) * 1.2); }

      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .game-overlay h2 { font-size: 1.6em; }
      .game-overlay p { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .language-settings, .sound-settings, .theme-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }


    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .feature-toggles button { min-width: 90px; }
      .select-label { font-size: 0.85em; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line {
          font-size: calc(var(--font-size-typing-mobile) * 0.95);
      }
      .fake-input-field {
          font-size: calc(var(--font-size-input-mobile) * 0.95);
      }

      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .game-overlay h2 { font-size: 1.4em; }
      .game-overlay p { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }

.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}

.hero-section a:hover {
  transform: scale(1.03);
}

.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}

.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}

.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}

.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}

#keyboard-guide {
    display: none;
    margin-bottom: 25px;
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 800px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}

.keys-wrapper {
    display: flex;
    width: fit-content;
}


.row-1 .keys-wrapper {
    transform: translateX(-29px);
}

.row-2 .keys-wrapper {
    transform: translateX(5px);
}

.row-3 .keys-wrapper {
    transform: translateX(-25px);
}

.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    width: 50px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
}

.keyboard-key .key-main-char {
    font-weight: 600;
    font-size: 1.1em;
    color: var(--text-primary);
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
}

#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char { font-size: 1.2em; }

.keyboard-key[data-key="shift"] { width: 87px; }
.keyboard-key[data-key="enter"] { width: 55px; }
.keyboard-key[data-key="space"] { width: 332px; }

.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.18);
}
.light-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.15);
}
.pink-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.12);
}


.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}

.light-theme .keyboard-key.highlight-key,
.pink-theme .keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
}
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}

@media (max-width: 820px) {
    #keyboard-guide { padding: 10px; }
    .keyboard-key { width: 42px; height: 42px; font-size: 0.8em; }
    .row-1 .keys-wrapper { transform: translateX(-25px); }
    .row-2 .keys-wrapper::before { width: 5px; }
    .row-3 .keys-wrapper::before { width: 10px; }
    .keyboard-key[data-key="shift"] { width: 73px; }
    .keyboard-key[data-key="enter"] { width: 73px; }
    .keyboard-key[data-key="space"] { width: 278px; }
}

@media (max-width: 480px) {
    #keyboard-guide { padding: 5px; }
    .keyboard-key { width: 28px; height: 35px; font-size: 0.7em; margin: 0 2px; border-radius: 4px;}
    .row-1 .keys-wrapper { transform: translateX(-16px); }
    .row-2 .keys-wrapper::before { width: 5px; }
    .row-3 .keys-wrapper::before { width: 10px; }
    .keyboard-key[data-key="shift"] { width: 48px; }
    .keyboard-key[data-key="enter"] { width: 48px; }
    .keyboard-key[data-key="space"] { width: 184px; }
}

/* ▼▼▼ 글쓰기 모드 개선 CSS ▼▼▼ */
#freestyle-area-container {
    padding: 20px 25px 28px;
    background-color: var(--bg-typing-area);
    border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    flex-grow: 1;
    display: none; /* <--- 이렇게 'none'으로 변경해주세요. */
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
    min-height: 400px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
}

#freestyle-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    position: relative;
    align-items: center;
}
.freestyle-tool-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.toolbar-divider {
    width: 1px;
    height: 20px;
    background-color: var(--input-border);
    margin: 0 4px;
}

.freestyle-tool-btn {
    background-color: var(--input-bg);
    color: var(--text-secondary);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 8px 12px;
    font-family: var(--font-ui);
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.freestyle-tool-btn:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
    border-color: var(--accent-secondary);
}
.freestyle-tool-btn i {
    margin-right: 6px;
    width: 14px;
    text-align: center;
}
#focusModeBtn { margin-left: auto; } /* 집중 모드 버튼을 오른쪽으로 */

#emoji-picker {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    transform: translateY(5px);
    background-color: var(--bg-container);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    padding: 10px;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    z-index: 10;
}
#emoji-picker.visible {
    display: grid;
}
#emoji-picker span {
    font-size: 1.4em;
    cursor: pointer;
    text-align: center;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
#emoji-picker span:hover {
    background-color: var(--bg-main);
}


#freestyle-input-area {
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 15px;
    font-family: var(--font-typing);
    font-size: var(--font-size-input);
    line-height: var(--line-height-typing);
    resize: vertical;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    box-sizing: border-box;
}
#freestyle-input-area:focus {
    outline: none;
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#freestyle-input-area::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
    transition: opacity 0.3s;
}
#freestyle-input-area:focus::placeholder {
    opacity: 0.3;
}

#freestyle-stats-bar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 15px;
    padding: 8px 5px;
    font-size: 0.85em;
    color: var(--text-secondary);
    font-family: var(--font-ui);
}

.freestyle-download-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin-top: 15px;
}
#freestyle-filename-input {
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 10px 12px;
    font-family: var(--font-ui);
    font-size: 0.9em;
    outline: none;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    width: 200px;
}
#freestyle-filename-input:focus {
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#download-freestyle-btn {
    padding: 10px 20px;
    font-size: 0.9em;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    border: 1.5px solid var(--accent-primary);
    background: var(--accent-primary);
    color: var(--button-text-on-accent);
    box-shadow: var(--shadow-button);
    transition: all 0.2s ease;
}
#download-freestyle-btn:hover {
    background: var(--accent-active);
    border-color: var(--accent-active);
    transform: translateY(-1px);
    box-shadow: var(--shadow-button-hover);
}
#download-freestyle-btn i {
    margin-right: 8px;
}

@media (max-width: 768px) {
    #freestyle-area-container {
        padding: 15px;
        min-height: 350px;
    }
    #freestyle-input-area {
        min-height: 250px;
    }
}
@media (max-width: 480px) {
    .freestyle-download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    #freestyle-filename-input, #download-freestyle-btn {
        width: 100%;
        box-sizing: border-box;
    }
    #freestyle-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    .freestyle-tool-group {
        justify-content: space-around;
    }
    #focusModeBtn { margin-left: 0; }
}
/* ▲▲▲ 글쓰기 모드 개선 CSS ▲▲▲ */
</style>
</head>
<body class=""> <!-- body에 active 클래스 제거 -->
  <div class="main-content-wrapper"> <div class="main-content">
    <div class="hero-section">
        <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
            <h1 class="hero-title">Key Therapy</h1>
            <p class="hero-tagline">깊은 수면과 집중을 위한<br>🎧키보드 타건 ASMR🎧</p>
        </a>
    </div>
  <div class="controls-and-stats-wrapper">
    <div class="settings-container">
        <div class="main-controls">
            <div class="practice-mode-controls control-button-group">
                <button data-practice-type="short"><i class="fas fa-language"></i> 단문 연습</button>
                <button data-practice-type="long"><i class="fas fa-align-left"></i> 장문 연습</button>
                <button data-practice-type="freestyle"><i class="fas fa-pencil-alt"></i> 글쓰기</button>
                <button id="gameModeBtn"><i class="fas fa-gamepad"></i> 게임하기</button>
            </div>

            <div class="feature-toggles control-button-group">
                <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
                <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> 자리연습 OFF</button>
            </div>

            <div class="selection-controls">
                <div class="sound-settings" id="soundSettingsElement">
                    <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                    <select id="soundPackSelect">
                        <option value="crunchy">서걱서걱</option>
                        <option value="pebbles">조약돌</option>
                        <option value="thocky">도각도각</option>
                    </select>
                </div>
                <div class="language-settings">
                    <label for="languageSelect" class="select-label">언어:</label>
                    <select id="languageSelect">
                        <option value="kor">한글</option>
                        <option value="eng">영어</option>
                    </select>
                </div>
                <div class="theme-settings" id="themeSettingsElement">
                    <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                    <select id="themeSelect">
                        <option value="dark">다크</option>
                        <option value="light">아이보리</option>
                        <option value="pink">핑크</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    <div id="stats">
        <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
        <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
        <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
        <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
    </div>
</div>
<div class="progress-bar-container">
    <div class="progress-bar"></div>
</div>
<div class="typing-area-container">
    <div id="keyboard-guide"></div>
    <div id="line-display-area"> </div>
    <div id="typing-input-field-container">
        <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
        <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
    </div>
    <div id="upcoming-lines-area"> </div>
</div>
<!-- ▼▼▼ 글쓰기 모드 컨테이너 (개선됨) ▼▼▼ -->
<div id="freestyle-area-container">
    <div id="freestyle-toolbar">
        <div class="freestyle-tool-group">
            <button id="insertDateBtn" class="freestyle-tool-btn" title="오늘 날짜 삽입"><i class="fas fa-calendar-alt"></i></button>
            <button id="insertTimeBtn" class="freestyle-tool-btn" title="현재 시간 삽입"><i class="fas fa-clock"></i></button>
            <button id="emojiBtn" class="freestyle-tool-btn" title="이모티콘"><i class="far fa-smile"></i></button>
             <div id="emoji-picker">
                <span>😊</span><span>😂</span><span>😍</span><span>🤔</span><span>👍</span><span>❤️</span>
                <span>🎉</span><span>✨</span><span>🔥</span><span>😭</span><span>🙏</span><span>⭐</span>
            </div>
        </div>
        <div class="toolbar-divider"></div>
        <div class="freestyle-tool-group">
            <button id="formatBoldBtn" class="freestyle-tool-btn" title="굵게"><i class="fas fa-bold"></i></button>
            <button id="formatItalicBtn" class="freestyle-tool-btn" title="기울임꼴"><i class="fas fa-italic"></i></button>
            <button id="insertHrBtn" class="freestyle-tool-btn" title="구분선"><i class="fas fa-minus"></i></button>
        </div>
        <button id="focusModeBtn" class="freestyle-tool-btn" title="집중 모드 (ESC로 해제)"><i class="fas fa-expand"></i></button>
    </div>
    <textarea id="freestyle-input-area" placeholder="오늘 하루는 어땠나요? 당신의 이야기를 자유롭게 기록해보세요..."></textarea>
    <div id="freestyle-stats-bar">
        <span id="charCount">0자</span>
        <span id="wordCount">0단어</span>
    </div>
    <div class="freestyle-download-controls">
        <input type="text" id="freestyle-filename-input" placeholder="파일 이름 (선택사항)">
        <button id="download-freestyle-btn"><i class="fas fa-download"></i> 텍스트 파일로 저장</button>
    </div>
</div>
<!-- ▲▲▲ 글쓰기 모드 컨테이너 (개선됨) ▲▲▲ -->
<div id="game-area-container">
</div>
<div id="result"></div>
</div>
</div>
  <div class="footer"> <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> </div>

<script>
// === 전역 변수 및 설정 ===
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = [];

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;

// ▼▼▼ 글쓰기 모드 관련 전역 변수 추가 ▼▼▼
let freestyleStatsInterval = null;
let freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl;
let freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker;
let formatBoldBtn, formatItalicBtn, insertHrBtn, focusModeBtn;
let charCountEl, wordCountEl;
// ▲▲▲ 글쓰기 모드 관련 전역 변수 추가 ▲▲▲

let languageSelectEl, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameOverlayEl, gameStartMessageEl, itemEffectPopupEl;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;


let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;


let currentSoundPack = 'crunchy';
const soundFiles = {
    pebbles: Array.from({length: 7}, (_, i) => `soundFiles/pebbles/pebble${i + 1}.wav`),
    crunchy: Array.from({length: 11}, (_, i) => `soundFiles/crunchy/crunchy${i + 1}.wav`),
    thocky: Array.from({length: 10}, (_, i) => `soundFiles/thocky/thocky${i + 1}.wav`)
};
let audioPool = {};
const MAX_AUDIO_OBJECTS = 8;
let audioPointer = {};

let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;

// === RAINFALL GAME MODE VARIABLES ===
let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_preferredGameLanguage = 'kor'; // 기본값 한글, 변경되지 않음
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: '시간', icon: '⏱️' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: '소멸', icon: '💨' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: '생명', icon: '❤️' }
};
const rainfall_gameMainLevelsConfig = [
    // Level 1: Very Easy
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    // Level 2
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    // Level 3
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    // Level 4
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    // Level 5
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    // Level 6
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    // Level 7
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    // Level 8
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    // Level 9
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    // Level 10: Very Hard
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];

// === LETTER BLOCK BATTLE GAME MODE VARIABLES ===
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
let lbb_preferredGameLanguage = 'kor'; // 기본값 한글, 변경되지 않음
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];

let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };

let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;

const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';

let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;


const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '⭐' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: '🔥' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '❄️' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '↔️' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;

let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
// === TYPING BATTLE GAME MODE VARIABLES ===
let gb_isGameActive = false;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_preferredGameLanguage = 'kor'; // 기본값 한글, 변경되지 않음
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000;
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;


const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
// --- END TYPING BATTLE ---

const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "황사", "일기", "예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "보드카", "데킬라", "하이볼", "탄산수",
    "비행기", "기차", "버스", "택시", "자전거", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신", "우주인", "방울뱀", "사막여우",
    "가로등", "가위질", "가정교사", "가족사진", "가지각색", "갈림길", "갈림돌", "감사패", "감정표현", "강강술래", "개발자", "거북선", "건강검진", "건널목", "검정고시", "결혼기념", "경기장", "경찰관", "경호원", "계란후라이", "고속도로", "고인돌", "골목대장", "공기놀이", "공중전화", "공휴일", "과일가게", "과학상자", "관광버스", "광화문", "구급상자", "국회의원", "군고구마", "그림일기", "극장", "기념품", "기상캐스터", "기차여행", "긴급상황", "김장독", "까마귀", "까치밥", "꽃다발", "꿀벌", "꿈나라", "끝말잇기", "나무늘보", "나비넥타이", "낙하산", "낚시꾼", "난센스퀴즈", "날개", "남대문", "낭떠러지", "내비게이션", "냉장고", "네잎클로버", "노랫소리", "노트북", "놀이공원", "농구공", "눈사람", "다리미", "다람쥐", "다이아몬드", "단풍잎", "달리기", "닭꼬치", "담벼락", "당근", "대통령", "대한민국", "도서관", "독수리", "돈가스", "돌고래", "동물원", "두부", "두통약", "드라이기", "등산화", "디지털카메라", "라면", "라디오", "로봇", "리모컨", "마라톤", "마법사", "만두", "만리장성"
].map(word => word.trim());
const gameWordsEng = [
    "hello", "world", "galaxy", "planet", "comet", "orbit", "nebula", "quasar", "pulsar", "meteor", "asteroid", "gravity", "energy", "force", "speed", "light", "sound", "echo", "pulse", "wave", "quantum", "field", "charge",
    "nature", "animal", "plant", "flower", "river", "ocean", "beach", "coast", "forest", "jungle", "desert", "mountain", "valley", "canyon", "island", "volcano", "glacier", "meadow", "prairie", "savanna", "swamp", "marsh", "reef",
    "summer", "winter", "spring", "autumn", "season", "weather", "climate", "cloud", "storm", "breeze", "hurricane", "typhoon", "tornado", "rainbow", "sunrise", "sunset", "twilight", "day", "night", "morning", "evening", "midnight", "noon",
    "people", "person", "human", "family", "friend", "enemy", "neighbor", "stranger", "guest", "host", "child", "adult", "teenager", "baby", "woman", "man", "girl", "boy", "king", "queen", "prince", "princess", "knight",
    "school", "college", "university", "student", "teacher", "professor", "class", "grade", "exam", "test", "quiz", "score", "point", "award", "prize", "medal", "trophy", "champion", "winner", "loser", "team", "coach", "player",
    "game", "play", "sport", "match", "race", "competition", "tournament", "hobby", "music", "movie", "theater", "concert", "opera", "ballet", "dance", "song", "melody", "rhythm", "harmony", "art", "painting", "drawing", "sculpture",
    "apple", "orange", "banana", "grape", "melon", "lemon", "lime", "peach", "pear", "plum", "cherry", "berry", "strawberry", "blueberry", "raspberry", "blackberry", "kiwi", "mango", "pineapple", "coconut", "avocado", "tomato", "potato",
    "computer", "keyboard", "mouse", "monitor", "screen", "laptop", "desktop", "server", "network", "internet", "website", "software", "hardware", "program", "code", "debug", "algorithm", "database", "interface", "protocol", "security", "backup", "firewall",
    "function", "variable", "constant", "array", "object", "string", "number", "boolean", "null", "undefined", "class", "constructor", "method", "property", "module", "import", "export", "async", "await", "promise", "callback", "event", "listener",
    "system", "design", "architecture", "component", "framework", "library", "package", "version", "control", "branch", "merge", "commit", "push", "pull", "request", "issue", "bug", "feature", "release", "deploy", "build", "test", "automation"
].map(word => word.trim());


function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

const lbb_wordPool = gameWordsKor.filter(word => word.length >= 2 && word.length <= 3);
if (lbb_wordPool.length === 0) {
    console.warn("LBB: 2-3글자 단어 풀이 비어있어 전체 단어 풀을 사용합니다.");
    lbb_wordPool.push(...gameWordsKor);
}

const sentencePool = { kor: ["따뜻한 햇살이 창가에 가득 내린다.", "작은 행복이 모여 큰 기쁨이 된다.", "오늘 하루도 수고했어요 당신 최고.", "좋아하는 노래를 들으며 힐링해요.", "푸른 하늘을 보며 마음껏 숨 쉬세요.", "예쁜 꽃 한 송이가 미소를 선물해요.", "가끔은 모든 걸 잊고 푹 쉬어요.", "좋은 친구는 삶의 큰 보물 같아요.", "새로운 시작은 언제나 설레는 법이죠.", "오늘 저녁은 맛있는 음식을 드세요.", "고요한 밤 별들이 속삭이는 소리.", "작은 친절이 세상을 따뜻하게 해요.", "주말엔 늦잠을 자며 여유를 즐겨요.", "새로운 길을 걷는 건 멋진 도전이야.", "마음속 작은 빛을 따라 나아가세요.", "오늘 하루 감사한 일을 떠올려봐요.", "사랑하는 사람에게 마음을 전하세요.", "힘든 날엔 잠시 하늘을 올려다봐요.", "달콤한 디저트는 기분 전환에 최고죠.", "아침 공기가 상쾌하게 느껴지네요.", "밤하늘의 별들은 저마다의 이야기를 간직하고 있다.", "바람결에 실려 온 꽃 향기가 마음을 간지럽힌다.", "익숙한 골목길에서 문득 새로운 풍경을 발견한다.", "가을비 내리는 날엔 따뜻한 차 한 잔이 위로가 된다.", "오래된 책갈피에서 잊고 지냈던 추억을 만났다.", "마음의 창을 열면 세상은 더 아름답게 보인다.", "작은 연못에 비친 달 그림자가 고요히 흔들린다.", "새벽녘 풀잎에 맺힌 이슬처럼 영롱한 순간들.", "구름 한 점 없는 하늘은 끝없는 가능성을 닮았다.", "모든 끝은 새로운 시작을 의미하기도 한다.", "삶이라는 여행길에서 가장 소중한 것은 경험이다.", "마음이 가는 대로 발길이 이끄는 대로.", "한 줄기 빛이 어둠을 가르듯 희망은 절망 속에서 피어난다.", "소리 없이 내리는 눈처럼 조용한 위로가 필요한 날.", "따뜻한 눈빛 하나가 얼어붙은 마음을 녹인다.", "시간의 강물은 쉼 없이 흐르지만 추억은 그 자리에 남는다.", "나뭇잎 사이로 부서지는 햇살이 보석처럼 반짝인다.", "낯선 곳에서의 우연한 만남은 예기치 못한 선물이다.", "가끔은 길을 잃어야 새로운 길을 찾을 수 있다.", "진정한 아름다움은 꾸밈없는 자연스러움에 있다.", "오늘 걷지 않으면 내일은 뛰어야 한다.", "백지장도 맞들면 낫다.", "뜻이 있는 곳에 길이 있다.", "시작이 반이다.", "하늘은 스스로 돕는 자를 돕는다.", "인내는 쓰지만 그 열매는 달다.", "구슬이 서 말이라도 꿰어야 보배다.", "세 살 버릇 여든까지 간다.", "젊어서 고생은 사서도 한다.", "콩 심은 데 콩 나고 팥 심은 데 팥 난다.", "키읔 티읕 피읖 히읗 거센소리 연습.", "쌍기역 쌍디귿 쌍비읍 쌍시옷 쌍지읒 된소리 연습.", "맑고 높은 가을 하늘 아래 코스모스 한들한들.", "반짝이는 별빛 아래 소중한 추억을 그려본다.", "찹쌀떡 맵쌀떡 온갖 떡들이 가득하다.", "깎아지른 절벽 아래 펼쳐진 푸른 바다.", "닭볶음탕과 칡넝쿨은 최고의 궁합이다.", "읊조리는 시 한 수가 마음을 촉촉하게 적신다.", "빠른 갈색 여우가 게으른 개 위로 뛰어넘는다.",  "외계생명체 존재 여부는 아직 밝혀지지 않았다.", "안녕하세요 만나서 반갑습니다 좋은 하루 되세요.", "대한민국 서울특별시 아름다운 우리 강산 푸르게 푸르게."], eng: ["The weather is lovely today perfect for a nice walk.", "Start your morning fresh with a warm cup of coffee.", "Listening to your favorite music always lifts the spirits.", "A small smile can brighten up someone's entire day.", "Sometimes it's nice to just gaze at the clear blue sky.", "A good book can be a wonderful and loyal companion.", "You did a great job today have a restful evening.", "Learning something new is always an exciting endeavor.", "Enjoy a delicious dinner together with your family.", "How about sending a warm greeting to an old friend?", "All that glitters is not gold.", "To be or not to be that is the question.", "The woods are lovely dark and deep.", "Hope is the thing with feathers that perches in the soul.", "It was the best of times it was the worst of times.", "The only thing we have to fear is fear itself.", "Stay hungry. Stay foolish.", "I have a dream that one day this nation will rise up.", "Two roads diverged in a wood and I I took the one less traveled by.", "The journey of a thousand miles begins with a single step.", "Be the change that you wish to see in the world.", "Not all those who wander are lost.", "That which does not kill us makes us stronger.", "Ask not what your country can do for you ask what you can do for your country.", "The unexamined life is not worth living.", "Where there is love there is life.", "The quick brown fox jumps over the lazy dog.", "Pack my box with five dozen liquor jugs.", "Sphinx of black quartz judge my vow.", "Amazingly few discotheques provide jukeboxes.", "How vexingly quick daft zebras jump.", "Bright vixens jump dozy fowl quack.", "Quick wafting zephyrs vex bold Jim.", "Crazy Fredrick bought many very exquisite opal jewels.", "Hello how are you today?", "Thank you very much for your help.", "Pleased to meet you.", "Practice makes perfect.", "Have a wonderful day ahead.", "Good morning sunshine.", "Keep up the good work.", "See you later alligator.", "What a beautiful surprise.", "Actions speak louder than words."], korLong: [ "낡은 골목의 초입, 허리 굽은 노파의 손길이 햇살에 바래진 담벼락을 어루만진다. 그녀의 손가락 마디마디에 지난 세월의 주름이 강물처럼 새겨져 있었고, 그 마디 끝에서 스며 나온 이야기들이 무성한 담쟁이덩굴처럼 벽을 휘감았다. 담쟁이 잎사귀들은 바람에 지난날의 속삭임처럼 흔들렸고, 그 사이로 비치는 햇살은 희미한 기억의 파편들을 흩뿌렸다. 노파의 발걸음은 더 이상 빠르지 않았다. 한 걸음, 한 걸음 옮길 때마다 아스팔트 바닥에 찍히는 그림자는 더욱 길고 아득해졌다. 그녀는 문득 걸음을 멈춰 서서, 오래된 전봇대 아래 놓인 작은 벤치에 앉았다. 벤치 옆에는 누군가 심어놓은 듯한 봉숭아 꽃이 붉은 얼굴을 내밀고 있었다. 그 빛깔이 너무나 선명해서, 마치 오래된 흑백사진 속에 홀로 채색된 부분처럼 이질적이었다. 노파는 봉숭아 꽃을 한참 동안 바라보았다. 그 시선 속에는 알 수 없는 그리움과 함께, 어린 시절의 순수한 미소가 언뜻 스쳐 지나갔다. 그녀의 기억 속에는 봉숭아 꽃잎으로 손톱을 물들이며 깔깔대던 작은 소녀의 모습이 선명하게 떠올랐다. 세월은 모든 것을 앗아가지만, 어떤 기억들은 시간의 파도를 거슬러 더욱 또렷하게 남아있는 법이었다. 노파는 주머니에서 빛바랜 손수건을 꺼내 봉숭아 꽃잎을 조심스럽게 감쌌다. 그리고는 다시 천천히 발걸음을 옮겼다. 낡은 골목 끝, 그녀의 그림자가 사라지는 순간까지 담쟁이덩굴은 여전히 바람에 흔들리며, 잊혀진 시간의 노래를 부르고 있었다. 삶이란 어쩌면, 이렇듯 희미해지는 풍경 속에서 선명하게 피어나는 꽃 한 송이 같은 것인지도 모른다. 그 꽃을 가슴에 품고, 우리는 묵묵히 저물어가는 하루를 걸어간다.", "간밤의 꿈은 짙은 안개처럼 형체를 알 수 없었고, 그 희미한 잔상만이 새벽의 고요 속에 떠돈다. 현실의 차가운 공기를 마주하며 침대에서 일어선다. 동이 트기 전의 하늘은 짙은 남색을 띠고 있었고, 그 너머로 희미하게 떠오르는 여명은 마치 거대한 그림자가 서서히 물러나는 듯했다. 밤은 휴식을 주지만, 동시에 가장 깊은 곳에 숨겨진 두려움과 불안을 들추어내는 시간이기도 하다. 꿈속에서 겪었던 알 수 없는 허무함의 정체를 찾아 헤맨다. 그것은 마치 손에 잡히지 않는 연기처럼, 붙잡으려 할수록 더욱 멀어져만 갔다. 어쩌면 그 허무함은 꿈속에서만 존재하는 것이 아니라, 현실 속에도 깊이 뿌리내리고 있는 것인지도 모른다. 삶의 어떤 지점에서 우리는 문득 마주하게 되는 알 수 없는 공허함. 채워지지 않는 갈증과 같은 그것은, 아무리 애써도 사라지지 않고 그림자처럼 따라붙는다. 창문 밖으로 시선을 던진다. 저 멀리 동이 터오고 있다. 빛은 어둠을 몰아내고, 새로운 하루를 약속한다. 차가운 공기를 깊이 들이마신다. 비록 꿈속의 허무함은 여전히 남아있지만, 어쩌면 그 허무함마저도 삶의 일부로 받아들여야 할지도 모른다는 생각이 든다. 완벽하게 채워진 삶은 존재하지 않는 법이니까. 그렇게 미완의 허무함을 끌어안고 새로운 하루를 시작할 준비를 한다. 삶은, 언제나 그렇게 불완전한 채로 이어진다.", "낡은 피아노는 이제 제 음을 내지 못했다. 건반은 누렇게 바랬고, 나무 몸체는 세월의 흔적처럼 군데군데 긁히고 파여 있었다. 그러나 그 낡은 피아노 앞에 앉아 가만히 건반을 눌러보면, 삐걱거리는 소리와 함께 불협화음이 울려 퍼져도, 그 소리 속에는 미처 잊고 지냈던 수많은 기억들이 살아 숨 쉬는 듯했다. 어린 시절, 엄마가 이 피아노 앞에 앉아 동요를 가르쳐주시던 모습, 서툰 솜씨로 젓가락 행진곡을 치며 깔깔대던 친구들의 얼굴, 그리고 처음으로 피아노를 통해 마음을 표현할 수 있다는 사실에 가슴 벅찼던 순간들까지. 피아노 건반 하나하나에는 유년 시절의 모든 감정들이 응축되어 있었다. 시간은 모든 것을 변화시키지만, 어떤 기억들은 이렇게 낡은 사물 속에 고스란히 저장되어 우리를 기다리는 법이었다. 조심스럽게 피아노 뚜껑을 열었다. 먼지 쌓인 현들은 희미한 빛을 머금고 있었고, 그 사이로 햇살이 스며들어 작은 무도회를 열고 있는 듯했다. 이제는 피아노를 제대로 연주할 수 없지만, 이 낡은 악기가 주는 위안을 사랑했다. 그것은 지나간 시간의 아름다움을 상기시켜주었고, 잃어버린 줄 알았던 순수한 감정들을 다시금 일깨워주었다. 피아노는 묵묵히 그 자리에 앉아, 과거와 현재를 연결하는 조용한 매개체가 되어주었다. 낡은 피아노 앞에서 조용히 미소 지었다. 여전히 삶의 한가운데서 불협화음을 내고 있지만, 그 모든 순간이 아름다운 선율로 채색되고 있다는 것을 깨달으면서.", "숲속 깊은 곳, 이끼 낀 지붕과 낡은 나무벽을 가진 오래된 오두막이 숨겨져 있었다. 오랜 세월의 흔적을 고스란히 담은 그곳의 굳게 닫힌 문은 마치 미지의 세계로 통하는 입구처럼 느껴졌다. 세상의 모든 소음으로부터 멀리 떨어진 그곳에서, 오직 바람 소리와 새들의 지저귐만이 고요를 깨뜨렸다. 조심스럽게 오두막 문을 열자, 삐걱거리는 소리와 함께 내부에서 훅 하고 흙냄새와 나무 냄새가 섞인 오래된 공기가 새어 나왔다. 오두막 안은 먼지로 가득했지만, 창문으로 스며드는 햇살은 그 모든 먼지를 황금빛으로 물들이며 춤을 추게 했다. 벽에는 오래된 그림들이 걸려 있었고, 한쪽 구석에는 낡은 책들이 쌓여 있었다. 그 모든 것이 마치 누군가의 삶의 조각들을 전시해 놓은 박물관 같았다. 오두막 안에 있는 작은 의자에 앉아, 고요함 속에서 자신에게 귀 기울였다. 이 오두막은 마치 자신을 온전히 마주할 수 있는 성소와 같았다. 세상의 모든 기대와 압박으로부터 벗어나, 오롯이 자신으로 존재할 수 있는 공간. 그 속에서 잃어버린 줄 알았던 진짜 목소리를 다시 들을 수 있었다. 오두막은 말없이 가르쳐주었다. 때로는 모든 것을 내려놓고 혼자만의 시간을 가질 필요가 있다고. 세상의 소음에서 벗어나 자신에게 귀 기울일 때, 비로소 진정한 평화를 찾을 수 있다고. 오두막 문을 닫고 다시 숲속을 걸어 나왔다. 햇살은 여전히 따뜻했고, 새들은 노래를 불렀다. 오두막에서 얻은 고요함과 깨달음은 오랫동안 마음속에 남아, 삶의 복잡함 속에서 든든한 뿌리가 되어줄 것 같았다.", "시계 초침 소리마저 크게 들리는 고요한 밤, 나는 불면의 시간을 보냈다. 침대에 누워 뒤척이며 수많은 생각들이 머릿속을 스쳐 지나갔다. 해결되지 않은 문제들, 지나간 후회들, 다가올 미래에 대한 막연한 불안감까지. 잠은 나를 외면하는 듯했고, 끝없는 생각의 미로 속에서 헤매고 있었다. 창밖으로는 도시의 불빛들이 꺼지지 않은 채 희미하게 빛나고 있었다. 저 불빛들 속에서 잠 못 이루는 사람은 나 혼자만이 아닐 것이라는 생각에 작은 위안을 얻기도 했다. 불면은 단순한 잠의 부재가 아니었다. 그것은 마치 나 자신과 가장 깊이 마주하는 시간과 같았다. 가면을 벗어던지고 내면의 가장 어두운 곳까지 들여다볼 수밖에 없는 잔인하면서도 솔직한 시간. 그 속에서 나의 가장 취약한 부분들을 마주하고, 그 약함조차도 나의 일부임을 받아들이는 법을 배웠다. 새벽이 오기 직전, 문득 잠이 들었다. 짧은 잠이었지만, 깊은 잠이었다. 꿈속에서 어떤 평화를 느꼈다. 눈을 떴을 때, 창문 밖으로는 여명이 밝아오고 있었다. 불면의 밤을 보내고 난 뒤의 새벽은 늘 경이로웠다. 세상은 다시 새로운 하루를 시작할 준비를 하고 있었고, 나 또한 어제의 불안감을 조금은 내려놓고 다시 일어설 준비를 했다. 불면의 밤은 나를 지치게 했지만, 동시에 나를 더 강하고 깊은 사람으로 만들었다. 밤은 끝없이 우리에게 질문을 던지고, 그 질문 속에서 우리는 조금씩 답을 찾아가는 것인지도 모른다. 나는 나의 불면의 밤을 통해 성숙해졌다.", "낡은 찻잔은 나의 오랜 벗이다. 손때 묻은 표면에는 수많은 시간의 흔적이 새겨져 있고, 살짝 이가 나간 손잡이에는 함께한 추억들이 담겨 있다. 그 찻잔에 따뜻한 차를 내리고 창가에 앉아 조용히 차를 마신다. 차의 은은한 향기가 온몸에 퍼지고, 따뜻한 온기가 손끝에서부터 마음속까지 스며들면, 세상의 모든 시끄러움은 잠시 멀어지고 고요한 평화가 찾아든다. 이 찻잔 속에는 단순히 차만 담겨 있는 것이 아니다. 함께 웃고 울었던 수많은 날들의 기억, 혼자만의 사색 속에서 얻었던 작은 깨달음들, 그리고 미래에 대한 막연한 희망들이 함께 담겨 있다. 찻잔은 묵묵히 나의 모든 감정을 받아주고, 그 속에서 나는 자신을 온전히 만날 수 있었다. 삶은 때로 거친 파도처럼 휘몰아치지만, 이렇게 작은 찻잔 속에서 찾는 고요함은 나를 지탱해주는 든든한 힘이 된다. 빠르고 편리한 것들이 넘쳐나는 세상 속에서, 나는 일부러 느리고 소박한 것들을 찾는다. 그 속에는 디지털이 결코 줄 수 없는 인간적인 온기와 시간의 깊이가 존재하기 때문이다. 찻잔 속의 차가 식어갈수록, 마음은 더욱 깊어지고 단단해지는 것을 느낀다. 찻잔은 나에게 멈춤의 미학을 가르쳐주고, 일상 속 작은 행복을 발견하는 지혜를 선물해 준다. 나는 오늘도 이 낡은 찻잔과 함께, 나만의 고요한 시간을 만끽한다.", "어느 날 꿈속에서 잃어버린 퍼즐 조각 하나를 찾아 헤매고 있었다. 수많은 조각들이 뒤섞인 바닥에서, 나는 간절한 마음으로 그 조각을 찾았다. 하지만 아무리 찾아도 그 조각은 보이지 않았고, 알 수 없는 불안감에 휩싸였다. 꿈에서 깨어나자, 내 삶이 마치 완성되지 않은 퍼즐 같다는 생각이 들었다. 지금까지 살아오면서 많은 조각들을 맞춰왔지만, 여전히 채워지지 않은 빈 공간이 존재했다. 그것은 때로는 이루지 못한 꿈일 수도 있고, 떠나간 사람과의 관계일 수도 있으며, 혹은 나 자신조차 알 수 없는 어떤 공허함일 수도 있었다. 우리는 삶의 모든 조각을 완벽하게 맞추려 애쓰지만, 어쩌면 삶은 애초에 완벽하게 맞춰지지 않는 미완의 퍼즐일지도 모른다. 모든 조각을 다 찾을 수 없음을 인정하고, 때로는 빈 공간마저도 나의 일부로 받아들이는 지혜가 필요한 것이다. 그 빈 공간이야말로 우리가 앞으로 무엇을 채워나가야 할지 알려주는 희망의 공간이 될 수 있으니까. 침대에서 일어나 창가로 향했다. 동이 트기 시작하는 하늘은 여전히 회색빛이었지만, 그 너머로 희미하게 빛이 스며들고 있었다. 아직 채워지지 않은 퍼즐 조각은 여전히 나의 삶 속에 존재하겠지만, 더 이상 그것을 불안해하지 않기로 했다. 그 빈 공간을 통해 나는 앞으로 더 많은 것을 배우고, 더 많은 경험을 채워나갈 것이다. 나의 삶은 미완의 퍼즐이지만, 그 자체가 이미 아름답고 의미 있는 작품이다.", "밤하늘의 별들이 언제나 나에게 질문을 던진다. 저 무수한 별들 중 나는 어떤 별일까. 홀로 빛나는 작은 별일까, 아니면 은하수의 일부로 희미하게 존재하는 별일까. 삶은 때로 광활한 우주 속에서 나의 존재가 한없이 작게 느껴질 때가 있다. 내가 사라져도 세상은 아무렇지 않게 흘러갈 것이라는 생각에 허무해지기도 한다. 하지만 동시에 깨달았다. 모든 별은 저마다의 고유한 빛을 가지고 있다는 것을. 크고 작음에 상관없이, 모든 별은 우주의 일부로 존재하며, 그 자체로 의미를 가진다는 것을. 나의 존재 또한 이와 같을 것이다. 나는 누군가에게는 희미한 존재일지라도, 누군가에게는 밝은 길을 밝혀주는 등대와 같은 존재일 수도 있다. 중요한 것은 내가 가진 작은 빛을 잃지 않고, 나만의 방식으로 빛을 발하는 것이다. 밤이 깊어지면 별빛은 더욱 선명해진다. 어둠이 짙을수록 빛의 가치는 더욱 커지는 법이다. 나는 창가에 서서 밤하늘의 별들을 한참 동안 바라보았다. 그리고 나 자신에게 조용히 속삭였다. 나는 나의 별이다. 그리고 나의 빛은 영원할 것이다. 이 넓은 우주 속에서 나만의 빛을 밝히며, 나만의 길을 걸어갈 것이다. 나의 존재는 이미 충분히 의미 있다.", "낡은 오르골은 더 이상 아름다운 선율을 연주하지 못했다. 태엽은 삐걱거렸고, 멜로디는 군데군데 끊기며 불협화음을 냈다. 하지만 나는 그 오르골을 버릴 수 없었다. 그것은 어린 시절 가장 소중했던 기억의 조각들을 담고 있었기 때문이다. 오르골을 감으면, 희미한 멜로디와 함께 엄마의 다정했던 목소리, 아빠의 따뜻했던 손길, 그리고 친구들과 함께 깔깔대던 웃음소리가 들려오는 듯했다. 오르골은 나의 유년 시절 모든 감정들을 고스란히 담고 있는 타임캡슐과 같았다. 시간은 모든 것을 변화시키지만, 어떤 기억들은 이렇게 낡은 사물 속에 고스란히 저장되어 우리를 기다리는 법이었다. 조심스럽게 오르골 뚜껑을 열었다. 먼지 쌓인 태엽들은 희미한 빛을 머금고 있었고, 그 사이로 햇살이 스며들어 작은 무도회를 열고 있는 듯했다. 이제는 오르골이 완벽한 선율을 연주하지 못하지만, 이 낡은 악기가 주는 위안을 사랑했다. 그것은 지나간 시간의 아름다움을 상기시켜주었고, 잃어버린 줄 알았던 순수한 감정들을 다시금 일깨워주었다. 오르골은 묵묵히 그 자리에 앉아, 나의 과거와 현재를 연결하는 조용한 매개체가 되어주었다. 낡은 오르골 앞에서 조용히 미소 지었다. 여전히 삶의 한가운데서 불협화음을 내고 있지만, 그 모든 순간이 아름다운 선율로 채색되고 있다는 것을 깨달으면서.", "텅 빈 미술관, 나는 홀로 그림들 사이를 천천히 걸었다. 캔버스 위에는 수많은 색깔과 형태로 그려진 이야기들이 펼쳐져 있었고, 각각의 그림들은 저마다 다른 침묵의 언어로 말을 걸어왔다. 어떤 그림은 밝고 경쾌한 에너지로 나를 미소 짓게 했고, 어떤 그림은 깊은 슬픔과 고독을 담고 있어 마음을 아릿하게 만들었다. 한 그림 앞에서 발걸음을 멈췄다. 붓질의 흔적이 거칠게 남아있는 추상화였다. 처음에는 그 그림이 무엇을 의미하는지 알 수 없었다. 하지만 한참 동안 그림을 바라보자, 그 안에 숨겨진 작가의 고뇌와 열정이 희미하게 느껴졌다. 그리고 문득, 그 그림이 나의 삶과 닮아 있다는 생각이 들었다. 삶은 어쩌면 하나의 거대한 추상화와 같은 것인지도 모른다. 명확한 형태도, 정해진 답도 없는. 하지만 그 속에서 우리는 각자의 색깔과 의미를 부여하며 나만의 그림을 완성해 나간다. 때로는 이해하기 힘든 색깔들이 뒤섞여 혼란스럽기도 하고, 때로는 의도치 않은 선들이 그려져 당황스럽기도 하다. 하지만 그 모든 불완전함과 혼돈마저도 나의 그림을 더욱 풍성하고 독특하게 만드는 요소가 된다. 그림 앞에서 조용히 미소 지었다. 이제는 더 이상 완벽한 그림을 그리려 애쓰지 않을 것이다. 그저 내가 가진 색깔과 붓질로, 나만의 이야기를 솔직하게 표현해 나갈 것이다. 나의 삶은 내가 그려가는 미완의 추상화이다. 그리고 그 추상화는 나만의 방식으로 아름답다.", "바닷가 작은 마을에 등대지기 할아버지가 살았다. 굵은 주름이 깊게 패인 그의 얼굴에는 지난 세월의 풍파가 고스란히 새겨져 있었지만, 그의 눈빛만큼은 언제나 깊고 따뜻했다. 매일 저녁 어김없이 등대 불을 밝히는 것이 그의 일이었다. 파도가 아무리 거칠어도, 바람이 아무리 세차게 불어도 단 한 번도 등대 불을 끄는 법이 없었다. 그에게 등대 불은 단순한 빛이 아니었다. 그것은 바다 위에서 길을 잃은 이들에게 희망을 주고, 무사히 집으로 돌아올 수 있도록 안내하는 생명의 빛이었다. 할아버지는 등대 불을 밝힐 때마다, 먼 바다 위에서 헤매는 배들을 떠올리며 조용히 기도했다. 그들의 안전한 항해를 빌고, 무사귀환을 염원했다. 그의 삶은 오직 등대 불을 밝히는 것에 집중되어 있었다. 화려하지도, 주목받지도 못하는 삶이었지만, 그는 자신의 역할에 충실하며 묵묵히 자신의 자리를 지켰다. 어느 날 할아버지를 찾아가 물었다. '할아버지, 매일 같은 일을 반복하는 것이 지겹지는 않으세요?' 할아버지는 잔잔한 미소를 지으며 대답했다. '이 작은 불빛 하나가 누군가의 삶을 지키고, 누군가의 꿈을 지켜준다고 생각하면, 결코 지겹지 않단다. 오히려 매일 새로운 의미를 발견하게 되지.' 할아버지의 말에서 깊은 깨달음을 얻었다. 삶의 진정한 가치는 거창한 곳에 있는 것이 아니라, 매일 반복하는 작은 행동 속에서 찾을 수 있다는 것을. 그리고 그 작은 행동들이 모여 누군가의 삶에 큰 영향을 미칠 수 있다는 것을. 등대지기 할아버지는 오늘도 변함없이 등대 불을 밝히고 있을 것이다. 그의 삶은 바다 위를 항해하는 수많은 배들에게 영원히 꺼지지 않는 희망의 등불이 될 것이다.", "낯선 도시의 뒷골목을 헤매던 날이었다. 화려한 대로변과는 달리, 이곳은 빛바랜 간판과 낡은 건물들로 가득했다. 사람들의 발길이 뜸한 그곳에서, 나는 마치 시간이 멈춘 듯한 묘한 고요함을 느꼈다. 벽에는 오래된 낙서와 희미한 그림들이 흐릿하게 남아있었고, 그 사이로 스며드는 햇살은 왠지 모르게 쓸쓸한 기운을 더했다. 우연히 한 작은 서점을 발견했다. 낡은 나무 문을 열고 들어서자, 오래된 종이 냄새와 먼지 냄새가 섞인 독특한 향기가 코끝을 스쳤다. 서점 안은 책들로 가득했고, 그 책들은 마치 수많은 이야기들을 침묵으로 속삭이는 듯했다. 책들 사이를 천천히 걸었다. 빛바랜 표지의 고서부터, 누군가의 손때 묻은 시집까지. 그 모든 책들은 저마다 다른 세상과 지혜를 품고 있었다. 책을 읽는다는 것은 어쩌면, 시간과 공간을 초월하여 다른 누군가의 삶을 잠시 빌려 살아보는 것과 같은 경험일지도 모른다. 그 경험을 통해 우리는 세상을 바라보는 새로운 시각을 얻고, 인간과 삶에 대한 깊은 이해에 다가서게 된다. 한 권의 책은 때로 백 명의 스승보다 더 큰 가르침을 주기도 하고, 그 어떤 위로보다 더 따뜻한 안식을 선물하기도 한다. 서점 구석에 앉아, 우연히 손에 잡힌 시집 한 권을 펼쳤다. 그리고 그 속에 담긴 시인의 마음을 조용히 음미했다. 낯선 도시의 뒷골목에서 만난 작은 서점은 나에게 잠시 잊고 지냈던 내면의 평화를 선물해 주었다. 삶은 예측 불가능한 우연들로 가득하며, 그 속에서 우리는 뜻밖의 보물을 발견하기도 한다.", "거울 속의 나를 오랫동안 외면했었다. 거울에 비친 나의 모습은 내가 꿈꾸던 완벽한 모습과는 너무나 달랐다. 주름진 얼굴, 늘어난 몸무게, 그리고 무엇보다도 눈빛 속에 숨겨진 불안감과 피로감. 거울 속의 나를 볼 때마다 실망했고, 그 실망감은 나를 더욱 깊은 어둠 속으로 밀어 넣었다. 거울은 때로 가장 솔직한 친구가 되기도 하지만, 가장 잔인한 적이 되기도 한다. 그것은 나의 불완전함을 있는 그대로 보여주었고, 나는 그 사실을 받아들이기 어려웠다. 거울 속의 나를 바꾸려 애썼다. 더 완벽해지려 노력했고, 사람들의 시선에 맞춰 나를 포장했다. 하지만 그럴수록 나는 나 자신을 잃어갔다. 내 안의 진짜 목소리는 점점 더 희미해졌고, 겉으로만 번지르르한 가면 쓴 나만 남아버린 것 같았다. 그런데 어느 날 문득, 거울 속의 나에게 말을 걸었다. '괜찮아. 너는 너 그대로도 충분히 아름다워.' 그 순간, 거울 속의 나의 눈빛이 흔들리는 것을 보았다. 그리고 나도 모르게 눈물이 흘러내렸다. 나는 나 자신을 온전히 받아들이지 못했던 나를 용서했다. 진정한 아름다움은 완벽함에 있는 것이 아니라, 불완전함을 끌어안는 용기에 있다는 것을 깨달았다. 이제는 거울 속의 나를 외면하지 않을 것이다. 매일 아침 거울 앞에 서서, 나의 불완전함마저도 사랑하는 법을 연습할 것이다. 거울 속의 나는 이제 더 이상 나의 적이 아니다. 그것은 나의 가장 솔직한 친구이자, 나를 사랑하는 법을 가르쳐주는 따뜻한 스승이 될 것이다.", "과거의 상처는 낡은 옷처럼 나를 감싸고 있었다. 닳고 해져서 너덜거렸지만, 나는 그것을 벗어던질 용기가 없었다. 상처는 때때로 나를 아프게 했지만, 동시에 나를 보호해주는 갑옷처럼 느껴지기도 했다. 그 속에서 나는 나 자신을 숨기고, 세상과의 단절을 택했다. 과거의 상처는 마치 그림자처럼 나를 따라다녔다. 행복한 순간에도 불쑥 나타나 나의 발목을 잡았고, 새로운 시작 앞에서 나를 망설이게 했다. 나는 그 상처 때문에 많은 기회를 놓쳤고, 소중한 인연들을 떠나보내기도 했다. 상처는 나를 약하게 만들었지만, 동시에 나를 더 깊이 들여다보게 만들었다. 고통 속에서 나는 나 자신을 발견하고, 다른 이들의 아픔에 공감하는 법을 배웠다. 비록 아프지만, 이 아픔이 나를 성장시키는 자양분이라고 생각하려고 노력했다. 그리고 어느 날 문득, 나는 그 낡은 옷을 벗어던질 용기를 냈다. 비록 상처가 완전히 사라지지는 않겠지만, 더 이상 그것에 갇혀 살지는 않기로 했다. 상처는 나의 일부이지만, 그것이 나의 전부가 될 수는 없다. 나는 이제 상처를 끌어안고 새로운 옷을 입을 것이다. 그것은 나를 더 자유롭게 하고, 더 넓은 세상으로 나아가게 할 것이다. 상처는 끝이 아니라, 새로운 시작을 위한 발판이 될 수 있다는 것을 이제는 안다. 나는 나의 상처를 통해 더 강하고 지혜로운 사람으로 성장할 것이다.", "늦은 밤, 오래된 라디오에서 재즈 음악이 흘러나왔다. 지지직거리는 노이즈와 함께 흘러나오는 멜로디는 마치 낡은 필름처럼 시간을 거슬러 올라가게 만들었다. 트럼펫의 애절한 음색, 피아노의 섬세한 선율, 그리고 베이스의 깊은 울림은 마음속 깊은 곳까지 스며들어 알 수 없는 감동을 불러일으켰다. 재즈 음악은 언제나 나에게 자유로움과 즉흥성을 가르쳐준다. 정해진 틀에 얽매이지 않고, 순간의 감정에 충실하며 자신을 표현하는 것. 그것이 재즈의 매력이자, 우리가 삶에서 배워야 할 자세와도 같았다. 삶은 예측 불가능한 변수들로 가득하지만, 그 속에서 우리는 끊임없이 즉흥적인 연주를 해나가야 한다. 때로는 불협화음이 나기도 하고, 때로는 박자를 놓치기도 하지만, 그 모든 순간들이 모여 나만의 독특한 삶의 음악을 만들어간다. 라디오에서 흘러나오는 재즈 음악은 나에게 지난 시간의 아름다움을 상기시켜주었고, 동시에 앞으로 펼쳐질 미지의 시간에 대한 기대를 갖게 했다. 음악은 시간을 초월하여 우리를 연결하고, 우리의 감정을 어루만져주는 신비로운 언어이다. 눈을 감고 재즈 선율에 몸을 맡겼다. 나의 삶은 마치 끝없이 즉흥적인 연주를 해나가는 재즈 음악과 같다. 그 속에서 나는 나만의 리듬을 찾고, 나만의 멜로디를 만들어갈 것이다. 재즈는 나에게 삶의 자유와 예술을 가르쳐준다.", "낡은 박물관의 유리창 너머로 빛바랜 유물들이 고요히 잠들어 있었다. 먼지 쌓인 진열장 속에는 수천 년 전의 토기 조각, 녹슨 칼날, 그리고 이름 모를 인물의 초상화가 있었다. 그 모든 유물들은 각자의 시대와 이야기를 품고 있었고, 나는 그 침묵의 이야기들을 상상하며 시간 여행을 떠나곤 했다. 유물들은 단순한 과거의 잔재가 아니었다. 그것은 사라진 문명과 존재했던 사람들의 숨결을 담고 있는 증거이자, 현재를 살아가는 우리에게 과거의 지혜를 전해주는 메신저와 같았다. 유물들을 보며 인간의 삶이 얼마나 유한하고 무상한지 깨달았다. 아무리 거대한 문명도, 아무리 위대한 사람도 시간 앞에서는 결국 한 줌의 흙으로 돌아간다는 것을. 하지만 동시에, 그 사라져 가는 것들 속에서도 변치 않는 인간 본연의 아름다움과 열정을 발견했다. 유물들은 과거의 거울이 되어 현재의 나를 비춰주고, 미래를 살아갈 지혜를 선물해준다. 박물관을 나서며, 시간의 흐름 속에서 변치 않는 가치들을 찾아 나만의 삶의 유물을 만들어가야겠다고 다짐했다. 나의 삶은 결국 내가 만들어가는 하나의 유물이다. 언젠가 나 또한 시간의 진열장 속에 놓이겠지만, 그 속에 담긴 나의 이야기가 누군가에게 작은 영감이 되기를 바라면서.", "낡은 앨범 속에서 어린 시절의 사진을 발견했다. 빛바랜 사진 속에는 해맑게 웃고 있는 작은 아이의 모습이 담겨 있었다. 그 아이의 눈빛은 호기심으로 가득했고, 세상의 모든 것이 신비롭고 경이롭게 느껴지는 듯했다. 나는 그 사진을 한참 동안 바라보았다. 그리고 문득, 내가 그 어린아이와 얼마나 달라졌는지 생각했다. 순수했던 눈빛은 현실의 무게에 지쳐 탁해졌고, 호기심으로 가득했던 마음은 이제는 익숙함과 무관심으로 가득 차 있었다. 성장한다는 것은 어쩌면, 이렇게 순수했던 나를 조금씩 잃어가는 과정일지도 모른다. 하지만 동시에 깨달았다. 성장은 단순한 상실이 아니라, 새로운 것을 얻는 과정이기도 하다는 것을. 잃어버린 것만큼, 우리는 더 많은 지혜와 경험, 그리고 사랑을 얻는다. 어린 시절의 나는 다시 돌아오지 않겠지만, 그 아이의 순수함과 열정은 내 마음속 깊이 여전히 살아 숨 쉬고 있을 것이다. 나는 사진 속의 아이에게 조용히 말을 건넸다. '괜찮아, 너는 여전히 너야. 비록 모습은 변했지만, 너의 본질은 변치 않았어.' 낡은 앨범 속의 사진은 나에게 지난 시간의 아름다움을 상기시켜주었고, 동시에 앞으로 펼쳐질 미지의 시간에 대한 기대를 갖게 했다. 나의 삶은 계속해서 성장하고 변화하겠지만, 그 속에서 나는 나만의 빛을 잃지 않을 것이다.", "깊은 밤, 오래된 서재의 낡은 책상에 앉아 펜을 들었다. 책상 위에는 누군가 읽다 만 책들이 아무렇게나 놓여 있었고, 그 사이로 희미한 스탠드 불빛이 비치고 있었다. 공기 중에는 오래된 종이 냄새와 잉크 냄새가 섞여, 마치 시간이 멈춘 듯한 묘한 분위기를 자아냈다. 백지 위에 첫 문장을 쓰기 시작했다. 어떤 이야기를 써야 할지, 어떤 메시지를 전달해야 할지 알 수 없었지만, 그저 마음이 이끄는 대로 펜을 움직였다. 글을 쓰는 것은 마치 나 자신과의 깊은 대화와 같았다. 내 안에 숨겨져 있던 생각들과 감정들이 글이라는 형태로 구체화되는 과정은 언제나 경이로웠다. 때로는 막막함에 막혀 한 글자도 쓰지 못할 때도 있었고, 때로는 폭풍처럼 쏟아지는 영감에 밤새도록 펜을 놓지 못할 때도 있었다. 글은 나에게 세상을 이해하는 도구이자, 나 자신을 표현하는 가장 솔직한 방식이었다. 나는 글을 통해 상처를 치유하고, 용기를 얻었으며, 다른 이들과 소통하는 법을 배웠다. 글은 나의 가장 친한 친구이자, 나의 영원한 동반자였다. 펜촉이 종이 위를 스치는 소리만이 고요한 서재를 채웠다. 나는 오늘도 나의 이야기를 써 내려간다. 나의 삶은 내가 써가는 한 권의 책이다. 그리고 그 책은 아직 끝나지 않았다. 나는 나의 글로 세상을 마주하고, 나만의 빛을 밝힐 것이다.", "'완벽함'이라는 환상을 오랫동안 좇아왔다. 완벽한 사람이 되면, 완벽한 삶을 살 수 있을 거라고 믿었다. 그래서 나는 나 자신을 끊임없이 채찍질했고, 단 하나의 실수도 용납하지 않았다. 하지만 완벽함을 좇을수록 나는 더 큰 불안감과 좌절감에 시달렸다. 세상은 언제나 나의 기대를 배신했고, 나는 끝없이 나 자신에게 실망했다. 완벽함은 애초에 존재하지 않는 신기루와 같은 것이었다. 그것은 우리를 지치게 하고, 우리를 불행하게 만드는 허상일 뿐이었다. 어느 날 문득, 이 끝없는 경쟁에서 벗어나고 싶다는 생각이 들었다. 더 이상 완벽함을 좇아 달려가지 않을 것이다. 대신, 나의 불완전함을 있는 그대로 받아들이고, 그 속에서 나만의 아름다움을 찾아나갈 것이다. 모든 사람은 불완전하다. 그리고 그 불완전함이야말로 우리를 인간답게 만들고, 우리를 더 깊이 이해하고 사랑하게 만든다. 실수해도 괜찮다. 넘어져도 괜찮다. 그 모든 과정이 나를 성장시키는 자양분이 될 것이다. 이제는 더 이상 완벽한 사람이 되려 애쓰지 않을 것이다. 그저 나 자신으로 존재할 것이다. 불완전한 나를 사랑하며, 불완전한 나의 삶을 온전히 살아갈 것이다. 나의 삶은 완벽하지 않지만, 그 자체로 이미 아름다운 예술이다.", "낡은 사진첩 속에서 할머니의 젊은 시절 사진을 발견했다. 흑백사진 속의 할머니는 지금과는 전혀 다른 모습이었다. 해맑게 웃고 있는 얼굴에는 희망이 가득했고, 눈빛 속에는 세상을 향한 열정이 빛나고 있었다. 나는 그 사진을 보며 할머니의 삶을 상상했다. 내가 알지 못했던 할머니의 젊은 시절, 그녀는 어떤 꿈을 꾸었고, 어떤 사랑을 했으며, 어떤 어려움들을 극복해왔을까. 한 장의 사진은 단순한 기록을 넘어, 한 사람의 삶 전체를 담고 있는 시간의 조각이었다. 그것은 나에게 과거와 현재를 잇는 다리가 되어주었고, 시간의 흐름 속에서 변치 않는 가치들을 돌아보게 했다. 할머니의 젊은 시절 사진은 나에게 많은 것을 생각하게 했다. 나 또한 언젠가 할머니처럼 늙고, 나의 젊은 시절은 한 장의 사진으로만 남을 것이다. 그때 나는 나의 삶을 어떻게 기억하고 싶을까. 후회보다는 사랑과 열정으로 가득했던 삶이었다고 말할 수 있을까. 사진을 조심스럽게 다시 앨범 속에 넣었다. 그리고 나 자신에게 다짐했다. 지금 이 순간을 가장 소중히 여기고, 후회 없는 삶을 살아가겠다고. 할머니의 젊은 시절 사진은 나에게 삶의 유한함과 그 속에서 우리가 가져야 할 겸손함을 가르쳐주었다. 그리고 동시에, 모든 순간이 소중하다는 것을 일깨워주었다.", "나의 '그림자'를 오랫동안 외면했었다. 내 안의 어둡고 취약한 부분들, 누구에게도 보여주고 싶지 않은 단점들. 나는 그것들을 깊숙이 숨기고, 밝고 완벽한 나만을 세상에 보여주려 애썼다. 하지만 그림자는 외면할수록 더욱 커지고, 결국에는 나를 집어삼킬 듯 밀려왔다. 그림자는 단순한 어둠이 아니었다. 그것은 나의 일부였고, 나를 더 깊이 이해하게 만드는 거울이었다. 나는 그림자를 통해 나의 두려움과 불안, 그리고 나약함을 마주할 수 있었다. 그것은 고통스러운 과정이었지만, 동시에 나를 더 강하고 솔직한 사람으로 만드는 과정이었다. 어느 날 문득, 나의 그림자를 끌어안았다. 더 이상 그것을 숨기거나 외면하지 않을 것이다. 오히려 나의 그림자와 함께 걸어갈 것이다. 그림자는 빛이 있기에 존재한다. 나의 그림자가 존재한다는 것은 나의 빛 또한 존재한다는 증거이다. 어쩌면 진정한 성장은 빛만을 좇는 것이 아니라, 어둠과 빛을 모두 끌어안는 데서 시작되는 것인지도 모른다. 그림자는 나의 가장 솔직한 친구이자, 나를 더 깊이 이해하게 만드는 스승이 될 것이다. 나는 이제 그림자와 함께 춤을 출 것이다. 어둠 속에서도 빛을 찾고, 빛 속에서도 어둠을 기억하며, 온전한 나로 살아갈 것이다. 나의 그림자는 나를 완성한다.", "나는 '의미'를 오랫동안 찾아 헤맸다. 내 삶이 어떤 거창한 의미를 가져야만 한다고 믿었다. 그래서 나는 끊임없이 더 높은 곳을 향해 달려갔고, 더 많은 것을 성취하려 애썼다. 하지만 의미는 손에 잡히지 않는 신기루처럼, 붙잡으려 할수록 더욱 멀어져만 갔다. 오히려 의미를 찾아 헤매다가는 삶의 작은 아름다움들을 놓치곤 했다. 의미는 어떤 거대한 목표를 달성했을 때 주어지는 것이 아니라, 매 순간을 어떻게 살아가는가에 달려 있다는 것을 이제는 안다. 따뜻한 햇살 아래 마시는 커피 한 잔, 사랑하는 사람과의 소박한 대화, 이름 모를 풀꽃의 아름다움. 이 모든 작은 순간들이 모여 삶의 의미를 이룬다. 거창한 의미가 없어도 괜찮다. 그저 존재한다는 것만으로도 충분하다. 숨 쉬고, 느끼고, 생각하고, 사랑하는 이 모든 순간들이 이미 의미가 있다는 것을요. 이제는 더 이상 의미를 찾아 헤매지 않을 것이다. 그저 오늘 주어진 순간들을 충실히 살아갈 것이다. 그리고 그 순간들 속에서 나만의 의미를 발견할 것이다. 나의 삶은 내가 만들어가는 의미의 조각들이다. 그리고 그 조각들은 이미 충분히 아름답다.", "'영원'을 오랫동안 믿었다. 영원히 변치 않을 사랑, 영원히 지속될 행복, 영원히 끝나지 않을 젊음. 하지만 살아보니, 이 세상에 영원한 것은 아무것도 없다는 것을 알게 됐다. 변치 않을 것 같았던 사랑도 시간 앞에서 빛을 잃고, 영원할 것 같았던 행복도 한순간에 사라지곤 했다. 모든 것은 끊임없이 변하고 흘러갔다. 처음에는 이 사실이 나를 슬프게 하고 허무하게 만들었다. 손에 쥔 모든 것이 결국 모래처럼 빠져나간다는 생각에 마음이 아려올 때도 있었다. 하지만 동시에 깨달았다. 모든 것이 변하기 때문에 오히려 삶은 더 아름답고 소중하다는 것을. 영원하지 않기에 우리는 매 순간을 더 소중히 여기고, 뜨겁게 사랑할 수 있다는 것을. 흘러가는 것을 붙잡으려 애쓰기보다, 그 흐름에 몸을 맡기고 변화를 받아들이는 지혜가 필요하다는 것을. 이제는 더 이상 영원을 좇아 헤매지 않을 것이다. 그저 오늘 주어진 순간들을 온전히 사랑하며 살아갈 것이다. 변화를 두려워하지 않고, 그 변화 속에서 새로운 아름다움을 발견할 것이다. 나의 삶은 영원하지 않지만, 그 모든 순간들이 영원처럼 빛날 것이다.", "밤하늘의 별들은 언제나 침묵으로 이야기한다. 그 빛은 수억 광년 전 과거에서 출발했지만, 지금 나의 눈에 닿는 순간 비로소 현재가 된다. 별빛은 시간의 상대성을 가르쳐주고, 내가 살아가는 이 순간의 소중함을 일깨워준다. 우리는 종종 과거의 후회에 갇히거나, 미래의 불안에 휩싸여 현재를 잊고 살아간다. 하지만 별빛은 말한다. 가장 중요한 것은 지금 이 순간, 네가 존재하고 있다는 사실이라고. 어쩌면 별빛은 우리에게 보내는 우주의 편지일지도 모른다. 우리가 얼마나 작은 존재인지, 그리고 동시에 얼마나 위대한 존재인지 일깨워주는 침묵의 메시지. 창가에 서서 밤하늘의 별들을 한참 동안 바라보았다. 나의 삶도 저 별빛과 같을 것이다. 과거의 빛이 현재를 밝히고, 현재의 빛이 미래를 만들어갈 것이다. 나는 이 순간을 소중히 여기고, 나의 빛을 온전히 발할 것이다. 밤하늘의 별들이 나에게 가르쳐준 가장 큰 지혜는, 나의 존재 자체가 이미 충분히 의미 있다는 것이었다. 나는 이 순간을 살아간다. 그리고 나의 빛은 영원할 것이다.", "낡은 나무 상자 속에서 한 통의 편지를 발견했다. 빛바랜 종이에는 누군가의 손글씨로 짧은 안부 인사가 적혀 있었다. 발신인도, 수신인도 알 수 없는 편지였지만, 나는 그 편지를 통해 낯선 이의 삶의 조각들을 엿볼 수 있었다. 편지 속에는 기쁨과 슬픔, 사랑과 이별, 희망과 좌절 등 인간이 겪을 수 있는 모든 감정들이 응축되어 있었다. 그것은 마치 시대를 초월하여 나에게 건네는 누군가의 솔직한 고백과도 같았다. 편지는 단순한 종이 조각이 아니라, 한 사람의 삶의 숨결을 담고 있는 살아있는 유물이었다. 디지털 시대에 우리는 너무나 쉽게 메시지를 주고받지만, 손글씨로 쓰인 편지가 주는 따뜻함과 진정성은 그 어떤 것으로도 대체할 수 없는 특별함이 있다. 편지 한 통은 때로 그 어떤 책보다 더 깊은 울림을 주고, 그 어떤 대화보다 더 깊은 공감을 불러일으킨다. 편지를 조심스럽게 다시 상자 속에 넣었다. 그리고 나 자신에게 다짐했다. 나 또한 언젠가 누군가에게 나의 삶을 담은 편지를 남겨야겠다고. 나의 이야기가 담긴 편지가 누군가에게 작은 위로가 되고, 희망이 될 수 있다면 좋겠다고. 낡은 편지는 나에게 과거와 현재를 잇는 다리가 되어주었고, 삶의 소박한 아름다움을 다시 한번 되새기게 했다.", "늦은 오후, 텅 빈 놀이터에 홀로 앉았다. 한때 아이들의 웃음소리로 가득했던 미끄럼틀과 그네는 이제 고요하게 멈춰 있었고, 모래밭에는 발자국 하나 남아 있지 않았다. 햇살은 기울어져 모래밭 위에 길게 그림자를 드리웠고, 바람은 쓸쓸하게 나뭇잎을 흔들었다. 그네에 앉아 천천히 몸을 흔들었다. 삐걱거리는 소리와 함께 잠시나마 어린 시절로 돌아간 듯한 기분이 들었다. 순수했던 그 시절, 작은 것 하나에도 크게 웃고, 작은 아픔에도 크게 울었던 나. 그때는 세상이 온통 놀이터였고, 모든 순간이 모험이었다. 세월이 흘러 어른이 된 지금, 나는 많은 것을 가졌지만 그때만큼 순수하게 행복하다고 말할 수 있을까. 문득 그런 생각이 들었다. 어쩌면 우리는 성장하면서 세상을 너무 복잡하게 바라보고, 진정한 행복의 의미를 잊어버리는 것은 아닐까. 놀이터는 나에게 말없이 가르쳐주는 듯했다. 삶은 언제나 놀이터와 같다는 것을. 어떤 마음으로 바라보느냐에 따라, 세상은 끝없는 모험의 장이 될 수도 있고, 따뜻한 안식처가 될 수도 있다는 것을. 그네에서 내려와 모래밭 위를 걸었다. 그리고 작은 발자국들을 남겼다. 나의 발자국은 앞으로도 계속해서 나의 삶의 놀이터 위를 걸어갈 것이다. 때로는 넘어져도 괜찮고, 때로는 길을 잃어도 괜찮다. 그 모든 과정이 나를 성장시키는 소중한 놀이일 테니까.", "밤하늘의 달은 언제나 고요한 위로를 건넨다. 수많은 별들 속에서 홀로 빛나는 달은 마치 세상의 모든 소음으로부터 벗어나, 고요한 침묵 속에서 나를 지켜봐 주는 친구와 같다. 잠 못 드는 밤, 달빛을 바라보며 나의 고민들을 속삭이곤 한다. 달은 아무 말 없이 나의 이야기를 들어주고, 그 빛으로 나의 마음을 어루만져준다. 달은 끊임없이 차고 기울기를 반복한다. 때로는 보름달처럼 환하게 빛나고, 때로는 초승달처럼 희미하게 존재한다. 그 변화 속에서 나는 삶의 순환과 변화의 아름다움을 느낀다. 모든 것은 영원히 머무르지 않고, 끊임없이 변하고 흘러간다는 것을. 그리고 그 모든 변화 속에서 우리는 성장하고 성숙해진다는 것을. 달빛은 어둠을 밝혀주지만, 동시에 어둠의 존재를 인정한다. 빛과 어둠은 공존하며, 서로에게 의미를 부여한다. 나의 삶 또한 빛과 어둠이 공존하는 복잡한 그림과 같을 것이다. 달빛 아래에서 나의 모든 감정을 온전히 받아들이고, 나 자신을 사랑하는 법을 연습한다. 달은 나에게 고독의 아름다움과 평화의 깊이를 가르쳐준다. 나는 오늘도 달빛 아래에서 나만의 고요한 명상을 이어간다. 그리고 믿는다. 달이 언제나 그 자리에서 나를 지켜봐 줄 것이라는 것을.", "낡은 엽서 한 장을 발견했다. 빛바랜 엽서에는 누군가의 손글씨로 짧은 안부 인사가 적혀 있었다. 발신인도, 수신인도 알 수 없는 엽서였지만, 그 엽서를 통해 낯선 이의 작은 삶의 조각을 엿볼 수 있었다. 엽서 속에는 짧은 문장에도 불구하고 따뜻한 마음과 소박한 일상의 행복이 담겨 있었다. 그것은 마치 시대를 초월하여 나에게 건네는 누군가의 진심 어린 메시지와도 같았다. 엽서는 단순한 종이 조각이 아니라, 한 사람의 마음과 시간을 담고 있는 작은 보물이었다. 디지털 시대에 우리는 너무나 쉽게 메시지를 주고받지만, 손글씨로 쓰인 엽서가 주는 따뜻함과 진정성은 그 어떤 것으로도 대체할 수 없는 특별함이 있다. 엽서 한 장은 때로 그 어떤 긴 편지보다 더 깊은 울림을 주고, 그 어떤 화려한 선물보다 더 큰 감동을 불러일으킨다. 엽서를 조심스럽게 다시 상자 속에 넣었다. 그리고 나 자신에게 다짐했다. 나 또한 언젠가 누군가에게 나의 삶을 담은 엽서를 보내야겠다고. 나의 이야기가 담긴 엽서가 누군가에게 작은 위로가 되고, 희망이 될 수 있다면 좋겠다고. 낡은 엽서는 나에게 과거와 현재를 잇는 다리가 되어주었고, 삶의 소박한 아름다움을 다시 한번 되새기게 했다.", "'결과'에 오랫동안 집착하며 살았다. 어떤 일을 하든, 오직 결과만이 중요하다고 믿었다. 그래서 나는 과정을 즐기지 못했고, 실패를 두려워했다. 결과가 좋지 않으면 스스로를 비난했고, 결과가 좋더라도 만족하지 못했다. 하지만 살아보니, 삶은 결과가 아니라 과정 그 자체라는 것을 알게 됐다. 어떤 목표를 향해 나아가는 과정 속에서 배우고 성장하며, 그 과정 속에서 진정한 의미를 발견한다는 것을. 결과는 단지 하나의 지표일 뿐, 삶의 모든 것을 대변하지 못한다. 실패해도 괜찮다. 그 실패를 통해 무엇을 배웠는지가 더 중요하다. 성공해도 자만하지 않고, 그 성공이 오기까지의 과정을 기억하는 것이 더 중요하다. 이제는 더 이상 결과에만 집착하지 않을 것이다. 과정을 즐기고, 그 속에서 나만의 의미를 발견할 것이다. 나의 삶은 끝없는 과정의 연속이다. 그리고 그 과정 속에서 나는 계속해서 배우고 성장하며, 나만의 길을 만들어갈 것이다. 나의 삶은 결과가 아니라 과정이다. 그리고 그 과정은 이미 충분히 아름답다.", "'관계'라는 끈에 오랫동안 묶여 살았다. 사람들의 기대에 부응하려 애썼고, 모든 사람에게 좋은 사람으로 보이고 싶어 했다. 그래서 나는 나의 진짜 모습을 숨기고, 가면을 쓴 채 살았다. 하지만 그럴수록 나는 지쳐갔고, 진정한 관계를 맺지 못했다. 관계는 때로 우리를 지치게 하고 상처를 주기도 하지만, 동시에 우리를 성장시키고 삶을 풍요롭게 하는 가장 중요한 요소이다. 진정한 관계는 완벽함이 아니라, 불완전함을 있는 그대로 받아들이는 데서 시작된다는 것을 이제는 안다. 서로의 다름을 인정하고, 서로의 상처를 보듬어주며, 진심으로 소통하려 노력할 때 비로소 깊은 관계를 맺을 수 있다. 이제는 더 이상 모든 사람에게 좋은 사람으로 보이려 애쓰지 않을 것이다. 나의 진짜 모습을 보여주고, 나를 있는 그대로 받아들여주는 사람들과 진정한 관계를 맺을 것이다. 관계는 나의 삶을 더욱 풍요롭게 만들고, 나를 더 깊이 이해하게 만든다. 나는 관계 속에서 나를 발견하고, 관계 속에서 성장한다. 그리고 나의 관계는 나의 삶을 완성한다.", "이른 아침, 안개가 자욱한 숲길을 걸었다. 나무들은 안개 속에 잠겨 희미한 그림자처럼 보였고, 세상의 모든 소음은 잠든 듯 고요했다. 발걸음을 옮길 때마다 축축한 흙냄새와 풀냄새가 코끝을 스쳤고, 나뭇잎에 맺힌 이슬방울들이 햇살을 받아 보석처럼 반짝였다. 천천히 걸으며, 안개 속에서 드러나는 숲의 신비로운 모습에 매료되었다. 안개는 모든 것을 흐릿하게 만들었지만, 동시에 상상력을 자극하고 내면의 목소리에 귀 기울이게 만들었다. 안개 속을 걷는 것은 마치 삶의 불확실한 미래를 걷는 것과 같았다. 앞이 보이지 않아 불안하기도 하지만, 동시에 미지의 세계에 대한 기대감과 호기심을 불러일으킨다. 우리는 삶의 모든 것을 예측하고 통제하려 애쓰지만, 때로는 이렇게 안개 속을 걷듯이 모든 것을 내려놓고 흐름에 몸을 맡길 필요도 있다. 안개는 언젠가 걷히고, 그 뒤에는 분명 찬란한 햇살이 기다리고 있을 것이다. 안개 속에서 나 자신을 온전히 마주하고, 내면의 평화를 찾았다. 안개는 나에게 겸손함과 인내심을 가르쳐주었다. 안개 속을 걷는 나의 발걸음은 더욱 단단해졌고, 나의 마음은 더욱 평온해졌다. 나는 이제 더 이상 안개를 두려워하지 않을 것이다. 안개 속에서도 나의 길을 찾아 나아갈 것이다. 안개는 나를 성장시킨다.", "문득 걸음을 멈춰 서서 생각합니다. 나는 지금 삶의 어느 지점에 서 있는 걸까. 분명 시작은 눈부시게 찬란했고, 가슴 벅찬 기대로 가득했는데, 어쩌다 이 길목에서 숨을 고르고 있을까. 지나온 발자국을 되짚어보면, 후회와 미련의 그림자가 더욱 선명하게 드리웁니다. 왜 그때는 그토록 서둘렀을까. 왜 그때는 눈앞의 작은 욕심에 그토록 사로잡혔을까. 밤이 깊어지면, 고요한 침묵 속에서 내가 놓친 것들의 그림자가 길게 드리워집니다. 영원할 줄 알았던 관계는 바람처럼 흩어졌고, 손에 닿을 듯했던 꿈은 안개처럼 사라져 버렸습니다. 사람들은 모두 괜찮다고, 잘하고 있다고 다독이지만, 정말 나는 괜찮은 걸까. 이 알 수 없는 공허함은 언제쯤 채워질까. 어쩌면 영원히 채워지지 않는 것이 삶의 본질일지도 모릅니다. 그저 이 쓸쓸함을 친구 삼아, 오늘도 나는 펜을 들고 또 다른 하루를 적어 내려갈 뿐입니다. 누구도 읽지 않을, 나만의 이야기들을. 이 캄캄한 어둠 속에서 나는 나 자신에게 묻습니다. 괜찮으냐고, 정말 괜찮으냐고.", "나는 꽤 오랫동안 가면을 쓰고 살았습니다. 세상이 요구하는 강하고 완벽한 모습을 연기하며 나 자신을 잃어갔죠. 아파도 아프다고 말하지 못하고, 힘들어도 괜찮은 척 웃어야만 했습니다. 사람들은 그런 나를 보며 '대단하다', '강하다'고 칭찬했지만, 내 안은 점점 더 곪아가고 있었습니다. 밤이 되면, 그 가면을 벗어던지고 침대 위에서 하염없이 눈물을 흘리곤 했습니다. 누구에게도 보여줄 수 없는 나의 연약함과 두려움이 나를 삼킬 듯 밀려왔으니까요. 이제는 정말 지쳤습니다. 더 이상 이런 가짜 나로 살고 싶지 않습니다. 비록 처음에는 낯설고 두렵겠지만, 나의 연약함을 드러내고, 아픔을 솔직하게 마주하고 싶습니다. 괜찮지 않아도 괜찮다는 것을, 나 자신에게 끊임없이 말해주고 싶습니다. 그래야만 내가 비로소 숨 쉴 수 있을 것 같습니다. 이 글을 쓰는 지금도 손이 떨리지만, 이것이 진짜 나를 찾아가는 첫걸음이 되리라 믿습니다. 나, 이제 괜찮지 않아도 괜찮으려 합니다.", "정말 우스운 일이지요. 우리는 모두 행복해지려고 애쓰면서, 정작 그 행복이라는 추상적인 개념 때문에 불행해지곤 합니다. 죽을힘을 다해 좇았던 성공 뒤에는 허무함만 남고, 영원할 거라 믿었던 사랑은 한순간에 재가 되어버리기도 합니다. 삶이란 참으로 얄궂은 아이러니의 연속입니다. 얻으려 할수록 멀어지고, 놓아주면 되레 돌아오는 것들이 얼마나 많던가요. 우리는 끊임없이 무엇이 '정답'인지 찾으려 발버둥 치지만, 애초에 정답 같은 건 없는 미완성의 그림이 삶 아닐까요? 흑백 논리로만 세상을 바라보려다 길을 잃고 헤매는 어리석은 존재들. 어쩌면 이 복잡하고 알 수 없는 삶 속에서, 나만의 해답을 찾아 헤매는 작은 존재일 뿐인지도 모릅니다. 오늘도, 내일도. 그리고 앞으로도 이 알 수 없는 아이러니 속에서 나는 나만의 춤을 추겠지요. 옳고 그름을 따지기보다, 그저 존재할 뿐인 나로.", "어느덧 세월이 강물처럼 흘러갔다는 것을 깨달았습니다. 손가락 사이로 빠져나가는 모래처럼, 붙잡으려 해도 속절없이 흘러가버린 시간의 조각들. 어릴 적에는 하루가 영원처럼 길었는데, 이제는 눈 깜짝할 사이에 한 계절이 가고, 한 해가 가버립니다. 남는 건 희미한 기억들과 몇 장의 빛바랜 사진뿐인 것 같습니다. 잃어버린 것들이 너무 많습니다. 다시는 돌아오지 않을 그 시절의 온기, 그 사람들의 목소리. 가끔은 이렇게 시간이 빨리 흐르는 것이 무섭기도 합니다. 내가 정말 이 시간을 의미 있게 사용하고 있는 건지, 낭비하고 있는 건 아닌지 불안해질 때가 있습니다. 다시는 돌아오지 않을 이 소중한 시간들을 어떻게 채워나가야 할까. 정답은 없겠지만, 적어도 후회는 남기지 말아야겠다고 다짐하곤 합니다. 어쩌면 시간은 그저 흘러가는 것이 아니라, 우리가 어떻게 채우느냐에 따라 다른 의미를 가지는 것인지도 모릅니다. 나의 시간은 나의 선택으로 채워지는 한 폭의 그림과도 같습니다.", "살아보니 별의별 인간 군상을 다 만나게 되더군요. 친절한 가면을 쓴 이기적인 사람, 겉으로는 냉정해도 속은 따뜻한 사람. 그 모든 관계 속에서 우리는 웃고 울고, 배우고 성장하고, 때로는 상처받고 또 치유됩니다. 그런데 가장 어려웠던 건, 나를 아프게 하는 사람들을 어떻게 대해야 하는가였습니다. 미워하고 싶지 않지만, 미워할 수밖에 없는 마음이 들 때도 있었고, 용서하고 싶지만, 용서가 되지 않아 밤잠을 설쳤죠. 관계는 참 미묘합니다. 가까워지려 할수록 상처받을 확률도 높아지고, 멀어지려 하면 외로움이 찾아옵니다. 어쩌면 모든 관계는 끝없는 연습과도 같습니다. 끊임없이 부딪히고, 배우고, 깨달아가는 과정. 완벽한 관계는 없겠지만, 서로의 다름을 인정하고, 존중하며, 함께 성장해나가는 관계야말로 가장 값진 것이라는 걸 이제는 알 것 같습니다. 상처받은 관계는 끝이 아니라, 새로운 시작이 될 수도 있다는 것을요. 나는 오늘도, 이 복잡한 관계 속에서 나를 찾아가고, 나만의 평화를 지키는 법을 배워갑니다.", "문득 혼자이고 싶을 때가 있습니다. 완벽하게 혼자여서, 아무도 없는 곳에서, 아무 생각 없이 그저 나 자신으로 온전히 존재하고 싶을 때가 있죠. 세상은 끊임없이 나에게 무언가를 요구하고, 나는 그 기대에 부응하기 위해 늘 애써야만 했습니다. 그러다 보니 내 안에 있는 진짜 목소리는 들리지 않고, 겉으로만 번지르르한 가면 쓴 나만 남아버린 것 같았습니다. 고독은 두려운 것이 아닙니다. 오히려 나를 온전히 만날 수 있는 소중한 시간이죠. 그 시간 속에서 나는 나의 그림자도, 나의 빛도 마주할 수 있습니다. 홀로 존재하는 법을 배우는 것, 그것이 어쩌면 가장 큰 성장일지도 모르겠습니다. 세상의 모든 소음에서 벗어나, 나만의 조용한 섬에서 잠시 숨을 고르고 싶습니다. 그렇게 나를 비워내고 나면, 다시 세상을 마주할 용기가 생길 테니까요. 나는 이 고독 속에서 나의 진정한 뿌리를 찾고, 나의 영혼을 채웁니다.", "한때 나에게도 수많은 꿈이 있었습니다. 반짝이는 별처럼 셀 수 없이 많았죠. 밤하늘을 수놓은 은하수처럼, 내 미래도 그렇게 빛날 줄 알았습니다. 그런데 살다 보니, 그 꿈들이 하나둘씩 힘없이 사라져가는 것을 보게 됐습니다. 현실이라는 거대한 벽 앞에서 좌절하고, 타협하고, 결국에는 포기해버린 꿈들이 얼마나 많은지 모릅니다. 가끔은 내가 꿈을 잃어버린 건지, 아니면 꿈이 나를 버린 건지 헷갈릴 때도 있습니다. 그 허무함과 상실감은 말로 다 표현할 수 없죠. 그런데 말이에요, 이제는 압니다. 꿈은 사라지는 것이 아니라, 다만 형태를 바꿀 뿐이라는 것을. 어쩌면 내가 꾸었던 거대한 꿈들은 작은 조각들로 나뉘어 내 삶 속에 스며들어 있는 것인지도 모릅니다. 비록 예전처럼 거창한 꿈은 없지만, 소박한 행복을 꿈꾸고, 소중한 사람들과 함께하는 삶을 꿈꾸는 것만으로도 충분하다는 것을요. 나는 오늘도, 이 작은 꿈들을 소중히 품고 살아가고 있습니다. 언젠가 이 작은 꿈들이 모여 또 다른 큰 그림을 그릴 날이 오겠지요. 그 그림은 아마 예전의 내가 상상했던 것과는 전혀 다른, 나만의 색깔로 빛나는 그림일 겁니다. 나는 여전히 꿈을 꿉니다. 다만 그 꿈의 형태가 달라졌을 뿐.", "돌아보면, 나는 꽤 오랫동안 과거의 그림자에 갇혀 살았습니다. '만약 그때 그랬더라면…', '만약 그때 다른 선택을 했더라면…' 하는 후회와 미련이 뱀처럼 나를 옥죄었죠. 과거는 이미 지나간 것인데, 나는 끊임없이 그 과거를 붙잡고 씨름했습니다. 그러다 보니 현재를 제대로 살지 못하고, 미래를 계획할 수도 없었죠. 마치 과거의 늪에 빠져 허우적거리는 것처럼 말입니다. 그런데 어느 순간 깨달았습니다. 과거는 결코 바꿀 수 없다는 것을. 내가 할 수 있는 건 오직 그 과거에서 배우고, 그것을 발판 삼아 앞으로 나아가는 것뿐이라는 것을요. 과거는 뒤에 놓인 풍경일 뿐입니다. 내가 가야 할 곳은 언제나 앞입니다. 이제는 그 그림자에서 벗어나고 싶습니다. 과거의 짐을 내려놓고, 가볍게 앞으로 나아가고 싶습니다. 오늘부터라도 현재를 온전히 살아가고 싶습니다. 그것이 내가 나에게 줄 수 있는 가장 큰 자유일 테니까요. 나의 과거는 나의 일부이지만, 그것이 나의 전부가 될 수는 없습니다. 나는 나만의 속도로, 나만의 길을 걸어갈 것입니다.", "이 길이 정말 내가 원하는 곳으로 이어질까? 가끔 이런 생각이 듭니다. 나는 지금 옳은 길을 가고 있는 걸까? 삶은 언제나 수많은 갈림길 앞에서 나를 망설이게 합니다. 어떤 길을 선택해야 할지 몰라 불안하고, 때로는 잘못된 길로 들어서서 헤매기도 했죠. 남들이 가는 길이 정답인 줄 알고 무작정 따라갔다가 후회했던 날들도 많습니다. 그 모든 과정 속에서 나는 수없이 넘어지고 일어섰습니다. 그런데 살아보니, 정답은 없다는 것을 알게 됐습니다. 각자의 삶에는 각자의 길이 있고, 그 길을 찾아가는 과정 자체가 중요한 것입니다. 남들이 뭐라 하든, 내 마음이 이끄는 대로 가는 용기가 필요하다는 것을요. 비록 그 길이 험난하고 외로울지라도, 결국 나만의 길을 완성할 수 있을 테니까요. 이제는 더 이상 헤매지 않고, 내 발자국이 남긴 길을 따라 묵묵히 걸어갈 것입니다. 그것이 나만의 지도가 될 테니까요. 나의 길은 내가 만듭니다. 나의 길은 나의 이야기입니다.", "꽤 오랫동안 나는 타인의 시선이라는 감옥에 갇혀 살았습니다. 사람들이 나를 어떻게 생각할까, 혹시 나를 싫어하지는 않을까 하는 불안감에 사로잡혀 늘 나를 포장하고 숨겼죠. 내 진짜 모습이 아닌, 사람들이 좋아할 만한 가면을 쓰고 살아왔던 것 같습니다. 그렇게 애써 얻은 인정은 겉으로는 달콤했지만, 속으로는 늘 공허했습니다. 결국 나는 나 자신을 잃어버렸으니까요. 이 끝없는 연극 속에서 나는 지쳐갔습니다. 그런데 어느 날 문득, 이렇게 살다가는 내 삶이 통째로 사라지겠다는 생각이 들었습니다. 이제는 그 가면을 벗어던지고 싶습니다. 사람들이 나를 좋아하든 싫어하든, 있는 그대로의 나를 보여주고 싶습니다. 비록 처음에는 낯설고 두렵겠지만, 나 자신으로 살아가는 용기를 내고 싶습니다. 그것이 내가 나에게 줄 수 있는 가장 큰 선물일 테니까요. 나는 이제 자유롭게 숨 쉴 수 있을 것 같습니다. 나의 삶은 이제부터 나만의 것이 될 것입니다.", "이 세상에 영원한 건 아무것도 없다는 것을, 이제는 뼈저리게 느끼곤 합니다. 변하지 않을 것 같았던 사랑도 시간 앞에서 빛을 잃고, 영원할 것 같았던 우정도 어긋난 길을 걷다가 끝을 맺습니다. 늘 그 자리에 있을 것 같았던 사람들도 하나둘씩 바람처럼 떠나갑니다. 모든 것이 변하고 사라지는 이 세상에서, 나는 무엇을 붙잡고 살아야 할까. 가끔은 허무하고 슬프기도 합니다. 손에 쥔 모든 것이 결국 모래처럼 빠져나간다는 생각에 마음이 아려올 때도 있죠. 하지만 동시에 깨달았습니다. 변하는 것들 속에서 변하지 않는 나 자신을 찾아야 한다는 것을. 외부의 조건에 흔들리지 않는 내면의 평화를 찾아야 한다는 것을. 모든 것이 사라져도 남는 것은 오직 나 자신뿐이라는 것을요. 이제는 흘러가는 것을 붙잡으려 애쓰기보다, 변하지 않는 나를 가꾸는 데 더 집중하고 싶습니다. 그것이 이 무상한 세상에서 내가 붙잡을 수 있는 유일한 진실일 테니까요. 나는 사라지는 것들 속에서 영원한 나를 찾아갑니다.", "가끔은, 너무나 아파서 모든 것을 놓아버리고 싶을 때가 있습니다. 심장이 찢어지는 것 같고, 숨쉬는 것조차 고통스럽게 느껴질 때가 있죠. 사람들은 시간이 약이라고 말하지만, 어떤 상처는 시간이 흘러도 아물지 않는 것 같습니다. 내 안에 깊이 박힌 가시처럼, 건드릴 때마다 쑤셔오는 고통에 나는 오늘도 몸서리치곤 합니다. 그 아픔은 나를 집어삼킬 듯했지만, 동시에 나를 더 깊이 들여다보게 만들었습니다. 고통 속에서 나는 나 자신을 발견하고, 다른 이들의 아픔에 공감하는 법을 배웠습니다. 비록 아프지만, 이 아픔이 나를 성장시키는 자양분이라고 생각하려고 합니다. 아프지 않고는 아무것도 배울 수 없는 것이 삶인 것 같으니까요. 오늘도 나는 이 아픔을 끌어안고 살아갑니다. 언젠가 이 아픔이 치유되어, 그 자리에 더 단단한 살이 돋아날 날을 기다리면서. 나는 아픔을 통해 비로소 나를 완성합니다.", "나는 꽤 오랫동안 완벽한 행복을 찾아 헤맸습니다. 마치 신기루처럼, 손에 잡힐 듯 잡히지 않는 그 무엇을 좇아 끊임없이 달려갔죠. 더 많은 것을 가지면, 더 높은 곳에 오르면, 더 완벽한 사람이 되면 행복해질 거라고 믿었습니다. 그런데 살아보니, 완벽한 행복이라는 건 애초에 존재하지 않는다는 것을 알게 됐습니다. 행복은 특정 목적지에 도달했을 때 주어지는 상이 아니라, 그 길을 걸어가는 과정 속에 숨어 있는 것입니다. 따뜻한 햇살 한 줄기, 고요한 밤하늘의 별, 사랑하는 사람의 미소, 맛있는 음식 한 조각. 이 모든 작은 순간들이 모여 삶의 행복을 이루는 것이라는 것을 이제야 깨달았습니다. 이제는 더 이상 완벽한 행복을 좇아 헤매지 않을 것입니다. 그저 오늘 주어진 작은 행복들을 소중히 여기며 살아가고 싶습니다. 그것이 진정한 행복일 테니까요. 나는 이제 완벽한 행복이 아닌, 나의 일상 속에서 피어나는 진짜 행복을 찾습니다.", "살아보니 말이에요, 후회 없는 삶이라는 건 애초에 불가능하다는 것을 알게 됐습니다. 누구나 크고 작은 후회를 안고 살아가게 마련이지요. '그때 그랬더라면…', '그때 다른 선택을 했더라면…' 하는 생각들이 밤마다 나를 찾아와 괴롭히곤 합니다. 하지만 문득 이런 생각이 들었습니다. 후회도 결국 내 삶의 일부라는 것을요. 그 후회들이 모여 지금의 나를 만들었고, 내가 무엇을 중요하게 생각하는지 가르쳐주었다는 것을요. 후회는 나를 괴롭히기 위해 존재하는 것이 아니라, 나에게 무언가를 가르쳐주기 위해 존재한다는 것을요. 이제는 더 이상 후회에 갇히지 않고 싶습니다. 과거의 실수를 인정하고, 그것을 발판 삼아 더 나은 내일을 만들어가고 싶습니다. 후회 없는 삶을 살기 위해 노력하겠지만, 설령 후회가 남더라도 그것마저도 나의 삶이라는 것을 받아들이고 싶습니다. 그것이 진짜 어른이 되는 과정인 것 같으니까요. 나는 후회 속에서 나의 길을 발견합니다.", "내 삶은 마치 계절의 변화와 같습니다. 따뜻한 봄날처럼 모든 것이 새롭게 시작되고 설렘으로 가득한 시기가 있는가 하면, 뜨거운 여름처럼 열정적으로 타오르며 땀 흘려 노력하는 시기도 있죠. 그러다가 가을처럼 모든 것을 거둬들이고 정리하며 사색에 잠기는 시기도 오고, 혹독한 겨울처럼 모든 것이 얼어붙고 움츠러들며 견뎌내야 하는 시기도 옵니다. 어떤 계절이든 영원히 머무르지 않고, 결국에는 다음 계절로 이어진다는 것을 깨달았습니다. 힘든 겨울을 지나야만 다시 따뜻한 봄이 오고, 봄이 와야만 다음 여름을 기대할 수 있다는 것을요. 그러니 지금 어떤 계절을 살고 있든, 너무 좌절하거나 너무 자만하지 말아야겠다고 다짐하곤 합니다. 이 모든 것은 잠시 머무르다 지나갈 뿐이니까요. 나는 이 삶의 모든 계절을 온전히 받아들이고 싶습니다. 그것이 삶의 아름다움일 테니까요. 나의 삶은 계절처럼 흐르며 성장합니다.", "나는 꽤 오랫동안 나 자신을 증명하기 위해 애썼습니다. 내가 얼마나 괜찮은 사람인지, 얼마나 유능한 사람인지, 세상에 보여주기 위해 끊임없이 노력하고 발버둥 쳤죠. 사람들의 인정과 칭찬에 목말라 있었습니다. 그런데 살아보니, 굳이 나 자신을 증명할 필요가 없다는 것을 알게 됐습니다. 나를 진정으로 이해하고 믿어주는 사람들은 내가 굳이 애쓰지 않아도 나를 알아봐 주고, 나를 믿지 않는 사람들에게는 아무리 애써도 소용없다는 것을요. 이제는 남들에게 나를 증명하기보다, 나 자신에게 만족하고 싶습니다. 내가 하고 싶은 일을 하고, 내가 옳다고 생각하는 길을 걸어갈 것입니다. 굳이 누구에게도 인정받으려 하지 않을 것입니다. 그것이 진정한 자유라는 것을 깨달았으니까요. 나 자신으로 존재하는 것만으로도 충분하다는 것을 이제는 압니다. 나는 이제 더 이상 누군가에게 나를 증명하지 않을 것입니다. 오직 나 자신에게만 충실할 것입니다.", "살아보니 말이에요, 이 세상은 정답이 없는 문제들로 가득하다는 것을 알게 됐습니다. 어릴 적에는 모든 문제에는 답이 있고, 그 답을 찾아내는 것이 가장 중요하다고 배웠죠. 그런데 삶은 수학 문제처럼 딱 떨어지는 답이 없더군요. 어떤 선택을 하든 장단점이 있고, 하나의 사건을 놓고도 수많은 해석이 가능합니다. 정답을 찾으려 헤매다가는 오히려 길을 잃기 십상이죠. 오히려 그 혼란 속에서 나만의 해답을 만들어가는 것이 더 중요하다고 생각합니다. 틀려도 괜찮습니다. 그 과정에서 배우고 성장하는 것이 더 중요하니까요. 나만의 방식으로 문제를 해결하고, 나만의 길을 만들어가는 것. 그게 이 복잡한 세상 속에서 살아가는 지혜인 것 같습니다. 정답은 없지만, 나만의 답은 만들 수 있습니다. 나의 삶은 내가 풀어가는 미완의 문제집입니다.", "내가 가진 이 수많은 감정들은 대체 어디서 오는 걸까? 가끔 이런 생각이 듭니다. 기쁨, 슬픔, 분노, 사랑, 불안, 질투… 이 모든 감정들이 나를 움직이고, 나를 살아가게 만드는 것 같습니다. 때로는 감정의 거대한 파도에 휩쓸려 허우적댈 때도 있고, 때로는 감정이 너무 메말라 아무것도 느끼지 못할 때도 있죠. 감정은 참 다루기 어려운 존재입니다. 억누르려 하면 더 크게 폭발하고, 외면하려 하면 그림자처럼 따라붙죠. 하지만 이제는 압니다. 감정은 그저 감정일 뿐이라는 것을. 옳고 그름이 없고, 좋고 나쁨이 없는, 그저 존재하는 것들이라는 것을요. 이제는 내 감정을 인정하고 받아들이고 싶습니다. 울고 싶으면 울고, 웃고 싶으면 웃을 것입니다. 감정에 휘둘리지 않고, 감정을 있는 그대로 바라보는 연습을 하고 싶습니다. 그것이 진정한 나를 만나는 길이 될 테니까요. 나의 감정은 나의 일부이며, 나는 그 모든 감정을 포용합니다.", "내 인생의 가장 큰 선물은 아마도 '관계'일 것입니다. 가족, 친구, 연인, 동료… 수많은 사람들과의 만남 속에서 우리는 웃고 울고, 배우고 성장하고, 때로는 상처받고 또 치유됩니다. 그 관계들이 모여 내 삶을 풍성하게 만들고, 나를 나답게 만들어주었습니다. 비록 어떤 관계는 끝을 맺었지만, 그 모든 관계 속에서 얻은 배움과 추억은 영원히 내 안에 남아있습니다. 관계는 끊임없는 노력과 관심이 필요한 섬세한 예술입니다. 서로의 다름을 인정하고, 존중하며, 진심을 다해 소통하려 노력해야 합니다. 때로는 상처를 주고받을 수도 있지만, 그 상처마저도 관계를 더 깊게 만드는 자양분이 될 수 있습니다. 나는 오늘도, 이 소중한 관계들을 가꾸며 살아가고 있습니다. 그것이 내 삶의 가장 큰 의미일 테니까요. 나는 관계 속에서 나를 발견하고, 관계 속에서 성장합니다.", "힘들 때마다 나는 생각합니다. 이 모든 시련이 나를 더 단단하게 만들 거라는 믿음. 마치 대장장이의 망치질처럼, 고통스러운 순간들이 나를 더욱 강하게 단련하고 있다고 말입니다. 때로는 모든 것을 포기하고 싶을 만큼 절망적인 순간도 있었습니다. 세상이 나를 벼랑 끝으로 내모는 것 같았죠. 하지만 나는 쓰러지지 않았습니다. 넘어져도 다시 일어섰고, 눈물을 흘리면서도 한 걸음 더 나아갔습니다. 나는 압니다. 이 모든 시련이 나에게 무언가를 가르쳐주기 위해 찾아왔다는 것을. 고통 속에서 배우고, 시련을 통해 성장하며, 결국 나는 더욱 성숙한 존재로 거듭날 것입니다. 당신은 혼자가 아니며, 이 모든 것을 이겨낼 힘이 있습니다. 그러니 두려워 말고 당신에게 다가오는 시련을 받아들이세요. 그것은 당신을 성장시킬 가장 좋은 스승이 될 것입니다. 나는 나의 시련을 통해 빛나는 존재가 될 것이다.", "어느 날 문득, 모든 것을 통제하려는 욕심을 내려놓았을 때, 비로소 진정한 자유를 맛보았습니다. 삶은 예측 불가능하며, 때로는 나의 의지와 상관없이 흘러가는 거대한 강물과 같다는 것을 깨달았죠. 그 흐름에 몸을 맡기고, 불확실성을 받아들일 때 비로소 마음의 평화를 얻을 수 있더군요. 모든 것을 계획하고 통제하려다 보면 오히려 더 큰 불안감에 휩싸입니다. 삶은 우리에게 끊임없이 변화를 요구하고, 그 변화 속에서 우리는 성장하는 법을 배우는 것입니다. 당신의 손을 활짝 펴고, 삶이 당신에게 주는 모든 것을 감사함으로 받아들여 보세요. 통제하려 하지 말고, 믿고 따라가 보세요. 당신의 삶은 당신이 생각하는 것보다 훨씬 더 큰 그림 속에서 움직이고 있습니다. 그 그림을 믿고 나아가면 됩니다. 이제 나는 자유롭다. 강물처럼 흐르는 삶 속에서 나는 나만의 춤을 춘다.", "밤하늘의 별들을 바라보며 문득 생각합니다. 각각의 별들이 홀로 빛나지만, 함께 모여 아름다운 은하수를 이루는 것처럼, 우리도 각자의 삶 속에서 고유한 빛을 내며 서로에게 영감을 주고 있다고. 당신이 홀로 있다고 느낄 때에도, 당신의 작은 빛은 누군가에게 길을 밝혀주고 있을지도 모르는 일입니다. 당신의 존재 자체가 의미 있으며, 당신의 삶은 우주만큼이나 소중합니다. 어둠 속에서도 희망을 잃지 말고, 당신의 빛을 계속해서 비추세요. 언젠가 그 작은 빛들이 모여 더 큰 빛을 만들고, 세상을 따뜻하게 비출 테니까요. 나는 우주의 한 조각이며, 나의 빛은 영원할 것이다. 나는 나의 빛으로 세상을 비춘다.", "진정한 지혜는 많은 것을 아는 데서 오는 것이 아니라, 자신이 무엇을 모르는지 아는 데서 시작된다는 것을 깨달았습니다. 겸손한 마음으로 배우고, 끊임없이 탐구하며, 자신의 한계를 인정할 때 우리는 비로소 성장할 수 있더군요. 세상은 넓고 배울 것은 무궁무진합니다. 닫힌 마음으로는 아무것도 얻을 수 없습니다. 열린 마음으로 세상의 모든 배움을 받아들이세요. 모든 경험은 나의 스승이 되고, 모든 만남은 나에게 새로운 지혜를 선물해 줍니다. 나의 지혜가 나의 삶을 더욱 풍요롭게 만들고, 다른 이들에게도 작은 영감을 줄 수 있다면 좋겠습니다. 배움의 길은 끝이 없으며, 그 길 위에서 나는 더욱 빛나는 존재가 될 것이다. 나는 배움을 통해 나를 완성한다.", "삶의 마지막 순간에 나는 무엇을 후회하게 될까? 아마도 해보지 못한 것들, 전하지 못한 사랑, 용서하지 못한 마음들일 것입니다. 이 사실을 깨달은 이후로, 나는 후회 없는 삶을 살기 위해 매 순간을 소중히 여기고, 진심을 다해 살아가려 노력합니다. 사랑하는 이에게 사랑한다고 말하고, 미안하다는 마음을 전하고, 용서해야 할 사람을 용서하며, 하고 싶은 일은 더 이상 망설이지 않고 시작합니다. 우리는 미래가 우리를 기다려줄 거라고 착각하지만, 삶은 언제나 불확실성의 연속입니다. 오늘이 마지막일 수도 있고, 지금 이 순간이 다시 오지 않을 기회일 수도 있습니다. 더 이상 미루지 않고, 오늘 당장 하고 싶은 일을 시작하고, 전하고 싶은 마음을 전해야겠다고 다짐하곤 합니다. 그래야만 후회 없는 삶을 살 수 있을 테니까요. 내일은 너무 늦을지도 모른다는 것을, 이제는 정말 알아야 할 때입니다. 나는 나의 삶을 후회 없이 채워갈 것이다.", "캄캄한 어둠 속에서도 나는 희망의 끈을 놓지 않습니다. 우리가 힘든 시간을 견딜 수 있는 것은 오직 '희망' 때문이라는 것을 알기 때문입니다. 어둠 속에서도 한 줄기 빛을 찾아내고, 절망 속에서도 다시 일어설 수 있다고 믿는 마음이 나를 지탱합니다. 희망은 결코 꺼지지 않는 마음속의 불꽃과 같습니다. 때로는 작게 깜빡거리기도 하고, 때로는 거센 바람에 흔들리기도 하지만, 결코 완전히 사라지지 않습니다. 그 불꽃이 꺼지지 않도록 끊임없이 내면의 힘을 불어넣고, 나의 마음속에 희망의 빛을 항상 밝히려고 노력합니다. 희망이 있는 한, 우리는 어떤 어려움도 이겨낼 수 있습니다. 나의 내면에 숨겨진 희망의 힘을 믿으세요. 그것은 나를 앞으로 나아가게 하는 가장 강력한 동력이 될 것입니다. 나는 희망을 통해 살아간다. 그리고 희망은 나를 배신하지 않을 것이다.", "어느덧 삶은 수많은 선택의 연속이었다는 걸 깨달았습니다. 밥을 먹는 일부터, 친구를 만나는 일, 심지어 오늘 아침 어떤 옷을 입을지까지. 작은 선택들이 모여 나라는 사람을 만들고, 내 삶의 방향을 결정했죠. 때로는 잘못된 선택으로 후회하고, 때로는 더 나은 선택을 하지 못해 아쉬워했던 날들이 많습니다. 하지만 이제는 압니다. 모든 선택에는 책임이 따르지만, 동시에 그 선택이 나를 성장시키는 기회가 된다는 것을요. 옳고 그름을 떠나, 나의 선택을 존중하고 그 결과를 받아들이는 용기가 필요하다는 것을요. 어쩌면 삶이란 완벽한 선택을 하는 것이 아니라, 불완전한 선택들 속에서 나만의 길을 찾아가는 과정인 것 같습니다. 나는 나의 선택을 통해 나의 삶을 만들어간다. 그 선택들이 모여 나만의 독특한 그림을 그릴 것이다.", "나는 왜 존재할까? 이 세상에 태어난 이유가 있을까? 가끔 잠 못 드는 밤, 이 질문들이 나를 사로잡습니다. 수많은 사람들 속에서 나는 한없이 작은 존재일 뿐인데, 이 작은 존재에게 무슨 거창한 의미가 있을까 하는 불안감에 휩싸이곤 합니다. 내가 사라져도 세상은 아무렇지 않게 흘러갈 텐데. 이런 생각을 하다 보면 한없이 초라해지곤 하죠. 하지만 동시에 깨달았습니다. 거창한 의미가 없어도 괜찮다는 것을. 그저 존재한다는 것만으로도 충분하다는 것을. 숨 쉬고, 느끼고, 생각하고, 사랑하는 이 모든 순간들이 이미 의미가 있다는 것을요. 나의 존재는 이미 그 자체로 빛나고 있다는 것을요. 이제는 더 이상 존재의 이유를 찾아 헤매지 않을 것입니다. 그저 나의 존재를 온전히 받아들이고, 이 순간을 충실히 살아갈 것입니다. 나는 나로 존재한다. 그리고 그것은 이미 충분하다.", "내 마음은 꽤 오랫동안 깊은 상처로 얼룩져 있었습니다. 누구에게도 말할 수 없는 비밀처럼, 나 혼자 삭이고 또 삭였죠. 그 상처는 때때로 나를 집어삼킬 듯했지만, 나는 늘 괜찮은 척해야만 했습니다. 그런데 이제는 압니다. 상처는 외면할수록 더 깊어진다는 것을. 아픔을 인정하고, 그 상처를 들여다볼 용기를 내야만 비로소 치유될 수 있다는 것을요. 마치 오래된 그림의 물감을 벗겨내듯, 나의 상처들을 하나씩 드러내고 싶습니다. 비록 아프겠지만, 그 아픔 속에서 나를 더 깊이 이해하고 사랑할 수 있을 것입니다. 나는 더 이상 이 상처에 갇히지 않을 것입니다. 나는 이 상처를 통해 더 강하고 지혜로운 사람으로 성장할 것입니다. 치유의 여정은 길고 힘들겠지만, 나는 나를 믿고 나아갈 것입니다. 나의 상처는 나의 훈장이 될 것이다.", "어깨에 짊어진 삶의 무게가 너무 버거워서, 가끔은 모든 것을 놓아버리고 싶을 때가 있습니다. 가족의 기대, 사회의 요구, 나 자신에 대한 압박. 이 모든 짐들이 나를 짓누르는 것 같습니다. 숨 쉬는 것조차 힘들게 느껴질 때가 있죠. 그런데 살아보니, 이 모든 짐을 내가 다 짊어질 필요가 없다는 것을 알게 됐습니다. 어떤 짐은 내려놓아야만 하고, 어떤 짐은 다른 사람과 나눠 짊어져야 한다는 것을요. 완벽하게 해내려 애쓰기보다, 때로는 불완전해도 괜찮다는 것을 받아들이는 용기가 필요하다는 것을요. 이제는 좀 내려놓고 싶습니다. 가볍게, 홀가분하게, 나만의 속도로 살아가고 싶습니다. 모든 짐을 다 짊어지고 가지 않아도 괜찮습니다. 나는 나 자신을 믿고, 내가 짊어질 수 있는 만큼만 짊어질 것입니다. 그리고 가끔은 아무것도 하지 않을 것입니다. 그것이 내가 나에게 줄 수 있는 가장 큰 휴식이자 선물일 테니까요.", "살다 보면, 나를 이해하지 못하는 사람들을 만나게 될 때가 있습니다. 내 말의 의도를 오해하거나, 내 행동을 비난하거나, 때로는 이유 없이 나를 미워하는 사람들도 있지요. 예전에는 그런 사람들 때문에 속상하고 화가 났습니다. 왜 나를 이해해주지 못할까, 왜 저렇게 판단할까 하는 생각에 괴로웠습니다. 그런데 이제는 압니다. 모든 사람은 자신만의 세상을 살아가고 있다는 것을. 각자의 경험과 상처, 그리고 관점이 다르다는 것을. 내가 그들을 온전히 이해할 수 없듯이, 그들도 나를 온전히 이해할 수 없다는 것을요. 이제는 나를 이해하지 못하는 사람들에게도 너그러워지고 싶습니다. 그들의 다름을 인정하고, 그들의 시선을 존중하고 싶습니다. 모든 사람이 나를 좋아할 필요도 없고, 모든 사람이 나를 이해할 필요도 없습니다. 그저 각자의 자리에서 자신만의 삶을 살아가는 것. 그것만으로도 충분하다는 것을 이제는 알 것 같습니다. 나는 이제 타인의 다름을 포용하며, 나만의 길을 걸어갑니다.", "낡은 다락방 창문으로 스며드는 오후의 햇살은 먼지 쌓인 시간 위로 부드럽게 내려앉았다. 공기 중에는 오래된 책 냄새와 희미한 나무 향기가 뒤섞여, 마치 잊혀진 이야기들이 낮은 목소리로 속삭이는 듯했다. 빛줄기를 따라 부유하는 작은 먼지들은 금빛 가루처럼 반짝였고, 그 너머로 보이는 바깥세상은 한 폭의 수채화처럼 아련했다. 나는 삐걱이는 나무 계단을 밟고 올라와, 창가 낡은 흔들의자에 가만히 몸을 기댔다. 창밖으로 보이는 느티나무는 수백 년의 세월을 말없이 지켜온 듯, 바람이 불 때마다 잎사귀를 흔들며 낮은 노래를 불렀다. 그 풍경 속에서 나는 어린 시절의 기억들을 하나씩 꺼내보았다. 할머니가 들려주시던 옛날이야기, 친구들과 뛰놀던 골목길의 저녁노을, 처음으로 느껴본 설렘과 아픔. 모든 것이 희미한 필름처럼 머릿속을 스쳐 지나갔지만, 그 감정만큼은 여전히 선명하게 남아 가슴 한구석을 아릿하게 만들었다. 시간은 모든 것을 변화시키지만, 기억 속에 새겨진 온기는 영원히 변치 않는다는 것을, 나는 그 순간 깨달았다. 어쩌면 우리는 모두 마음속에 자신만의 작은 다락방을 가지고 살아가는지도 모른다. 힘들고 지칠 때마다 찾아가 위로받을 수 있는, 소중한 추억들이 잠들어 있는 비밀스러운 공간을.", "깊은 밤, 창밖으로 무수한 별들이 보석처럼 쏟아질 듯 반짝였다. 나는 따뜻한 차 한 잔을 들고 창가에 서서, 끝없이 펼쳐진 밤하늘의 신비를 가만히 응시했다. 어둠이 짙을수록 별빛은 더욱 선명해졌고, 그 고요한 빛줄기는 내 마음속 깊은 곳까지 스며드는 듯했다. 저 멀리 이름 모를 별 하나가 유난히 밝게 빛나고 있었다. 마치 길 잃은 나그네에게 방향을 알려주는 등대처럼, 혹은 간절한 소망을 담아 하늘로 띄워 보낸 작은 등불처럼. 나는 그 별을 보며 어린 시절 순수했던 꿈들을 떠올렸다. 세상을 탐험하는 용감한 모험가, 사람들에게 감동을 주는 예술가, 밤하늘의 비밀을 푸는 천문학자. 현실의 벽에 부딪혀 하나둘씩 접어두었던 그 꿈들이, 별빛 아래에서 다시금 희미하게 살아나는 것을 느꼈다. 어쩌면 꿈이란, 완전히 사라지는 것이 아니라 잠시 우리 마음속 밤하늘에 숨어 반짝일 기회를 기다리는 별과 같은 것일지도 모른다. 중요한 것은 그 별빛을 잊지 않고, 언젠가 다시 그 빛을 따라 나아갈 용기를 내는 것이리라. 나는 마지막 한 모금의 차를 마시며, 내 마음속 별들을 향해 조용히 다짐했다. 아직 끝나지 않은 나의 이야기를 계속 써 내려가겠다고.", "이른 새벽, 안개가 자욱한 호숫가를 홀로 걸었다. 물안개는 마치 살아있는 생명체처럼 부드럽게 수면 위를 감돌았고, 멀리 보이는 산자락은 희미한 먹빛 그림자처럼 느껴졌다. 세상의 모든 소음이 잠든 듯, 오직 내 발걸음 소리와 이따금 들려오는 물새 소리만이 적막을 깨뜨렸다. 차가운 새벽 공기가 코끝을 스치자 정신이 맑아지는 기분이었다. 나는 호숫가 작은 벤치에 앉아, 서서히 밝아오는 동쪽 하늘을 바라보았다. 안개 너머로 붉은 기운이 조금씩 번지기 시작하더니, 이윽고 장엄한 해가 그 모습을 드러냈다. 떠오르는 태양은 밤새 호수를 뒤덮었던 안개를 부드럽게 걷어내었고, 그 아래 숨겨져 있던 맑고 투명한 호수의 민낯이 햇살 아래 눈부시게 반짝였다. 그 순간, 나는 마치 새로운 세상이 열리는 듯한 경이로움을 느꼈다. 어둠과 혼돈 속에서도 희망은 언제나 그렇게 떠오르는 것이라고, 자연은 말없이 가르쳐주는 듯했다. 삶이 때로 짙은 안개 속에 갇힌 것처럼 느껴질 때도 있겠지만, 그 안개 너머에는 분명 찬란한 아침이 기다리고 있음을, 그리고 그 아침을 맞이하기 위해서는 묵묵히 자신의 길을 걸어가야 함을, 나는 새벽 호숫가에서 깨달았다. 해가 완전히 떠오르자, 호수는 금빛으로 물들었고, 나는 새로운 하루를 시작할 용기를 얻어 다시 발걸음을 옮겼다.", "오래된 골목길 모퉁이를 돌자, 담벼락에 기대어 자라는 작은 담쟁이덩굴이 눈에 들어왔다. 거친 시멘트 벽을 가느다란 줄기로 힘겹게 부여잡고, 초록빛 잎사귀들을 햇살을 향해 힘껏 펼치고 있는 모습이었다. 그 작은 생명체의 강인함 앞에서 나는 잠시 발걸음을 멈추었다. 척박한 환경 속에서도 포기하지 않고, 자신의 자리를 묵묵히 지키며 생명의 푸르름을 피워내는 그 모습이 경이롭게 느껴졌다. 어쩌면 우리의 삶도 저 담쟁이덩굴과 크게 다르지 않을지도 모른다. 때로는 거칠고 힘겨운 현실이라는 벽에 부딪히고, 예상치 못한 시련의 바람에 흔들리기도 하지만, 그럼에도 불구하고 우리는 어떻게든 살아남아 자신의 이야기를 써 내려간다. 마음속 깊은 곳에 간직한 작은 희망의 씨앗을 붙들고, 한 뼘이라도 더 햇살을 향해 나아가려 애쓰면서 말이다. 담쟁이덩굴은 화려한 꽃을 피우거나 달콤한 열매를 맺지는 않지만, 그 자체로 충분히 아름답고 의미 있는 존재였다. 그것은 우리에게 말없이 가르쳐주고 있었다. 삶의 가치는 결과에만 있는 것이 아니라, 그 과정을 묵묵히 견뎌내고 자신의 자리에서 최선을 다하는 그 모든 순간에 깃들어 있다는 것을. 나는 작은 담쟁이덩굴에게서 큰 위로와 용기를 얻고, 다시금 내 삶의 담벼락을 향해 한 걸음 내디뎠다.", "늦은 오후, 텅 빈 기차역 플랫폼에 홀로 앉아 곧 떠나갈 기차를 기다렸다. 하늘에는 회색빛 구름이 낮게 드리워져 있었고, 바람은 스산하게 옷깃을 파고들었다. 어디론가 떠나고 싶은 마음과 어딘가에 머무르고 싶은 마음이 교차하는, 그런 묘한 감상에 젖어들었다. 잠시 후, 저 멀리서 기차가 육중한 소리를 내며 플랫폼으로 서서히 들어왔다. 낡았지만 정감 가는 기차의 창문 너머로, 각자의 사연을 안고 떠나는 사람들의 모습이 어렴풋이 보였다. 설렘과 아쉬움, 기대와 불안이 뒤섞인 그들의 표정 속에서 나는 내 삶의 여러 여정들을 떠올렸다. 새로운 시작을 향해 떠났던 길, 아쉬운 이별을 뒤로하고 돌아섰던 길, 목적지도 모른 채 그저 발길 닿는 대로 걸었던 길까지. 그 모든 길 위에서 나는 수많은 사람들을 만났고, 다양한 감정들을 경험했으며, 조금씩 성장해왔다. 기차가 멈춰 서고 문이 열리자, 나는 가방을 고쳐 메고 자리에서 일어섰다. 이번 여정의 끝에는 무엇이 기다리고 있을지 알 수 없지만, 그것 또한 내 삶의 한 페이지를 채워줄 소중한 경험이 될 것이라 믿었다. 기차는 다시 한번 육중한 기적 소리를 내며 천천히 움직이기 시작했고, 나는 창밖으로 멀어져 가는 익숙한 풍경들을 바라보며, 새로운 이야기가 시작될 미지의 공간을 향해 나아갔다.", "작은 도서관 구석, 햇살이 비껴드는 창가 자리에 앉아 오래된 소설책을 펼쳤다. 종이에서는 세월의 흔적이 느껴지는 희미한 냄새가 풍겨왔고, 손때 묻은 페이지들은 수많은 독자들의 이야기를 품고 있는 듯했다. 나는 한 자 한 자 천천히 글자를 따라 읽어 내려가며, 작가가 만들어낸 세계 속으로 깊이 빠져들었다. 그곳에는 내가 미처 경험하지 못한 삶과 감정들이 있었고, 현실에서는 만날 수 없는 매력적인 인물들이 살아가고 있었다. 때로는 주인공의 기쁨에 함께 웃고, 때로는 그의 슬픔에 함께 눈물 흘리며, 나는 책 속의 이야기와 온전히 하나가 되었다. 책을 읽는다는 것은 어쩌면, 시간과 공간을 초월하여 다른 누군가의 삶을 잠시 빌려 살아보는 것과 같은 경험일지도 모른다. 그 경험을 통해 우리는 세상을 바라보는 새로운 시각을 얻고, 인간과 삶에 대한 깊은 이해에 다가서게 된다. 한 권의 책은 때로 백 명의 스승보다 더 큰 가르침을 주기도 하고, 그 어떤 위로보다 더 따뜻한 안식을 선물하기도 한다. 나는 마지막 책장을 덮으며, 마음속에 잔잔하게 퍼지는 깊은 여운을 느꼈다. 책 속에서 만난 이야기와 인물들은 한동안 내 곁을 떠나지 않고, 내 삶의 중요한 일부가 되어 함께할 것 같았다. 그것이 바로 책이 가진 위대한 힘이리라.", "어스름이 내리는 저녁, 나는 강변을 따라 천천히 걷고 있었다. 강물은 해 질 녘의 붉은 노을을 온통 담아내며 고요히 흘러갔고, 강 건너편 도시의 불빛들은 하나둘씩 반짝이기 시작했다. 바람은 잔잔했고, 공기는 상쾌했다. 나는 강둑에 잠시 멈춰 서서, 아름다운 저녁 풍경을 가만히 바라보았다. 매일 반복되는 일상 속에서 우리는 종종 이런 순간의 아름다움을 잊고 살아간다. 하지만 잠시 멈춰 서서 주변을 둘러보면, 세상은 우리가 생각하는 것보다 훨씬 더 다채롭고 경이로운 모습으로 가득 차 있다는 것을 깨닫게 된다. 저녁노을이 만들어내는 황홀한 빛의 향연, 밤하늘을 수놓는 무수한 별들의 반짝임, 이름 모를 풀꽃의 소박한 아름다움까지. 이런 작은 것들 속에 삶의 진정한 기쁨과 위안이 숨겨져 있는지도 모른다. 중요한 것은 그것을 발견할 수 있는 열린 마음과 세상을 바라보는 따뜻한 시선이다. 어둠이 완전히 내려앉고 도시의 불빛이 더욱 선명해지자, 나는 다시 발걸음을 옮겼다. 짧은 산책이었지만, 내 마음은 어느새 평온함과 감사함으로 가득 차 있었다. 일상의 소중함을 다시 한번 깨닫게 해준 아름다운 저녁이었다.", "오랜만에 찾은 고향 집 마당에는 할머니가 심어두신 봉숭아 꽃이 곱게 피어 있었다. 어릴 적, 할머니 손을 잡고 봉숭아 꽃잎을 빻아 손톱에 물들이던 기억이 아련하게 떠올랐다. 빨갛게 물든 작은 손톱을 보며 세상을 다 가진 듯 기뻐했던 그 시절. 그때는 모든 것이 단순했고, 작은 것 하나에도 큰 행복을 느낄 수 있었다. 세월이 흘러 어른이 된 지금, 나는 많은 것을 가졌지만 그때만큼 순수하게 행복하다고 말할 수 있을까. 문득 그런 생각이 들었다. 어쩌면 우리는 성장하면서 세상을 너무 복잡하게 바라보고, 진정한 행복의 의미를 잊어버리는 것은 아닐까. 봉숭아 꽃은 예전과 다름없이 여전히 그 자리에서 소박한 아름다움을 뽐내고 있었다. 그것은 나에게 말없이 가르쳐주는 듯했다. 행복은 멀리 있는 것이 아니라, 바로 우리 마음속에, 그리고 우리가 지나쳐온 소중한 추억들 속에 있다는 것을. 나는 마당 한쪽에 쪼그리고 앉아, 바람에 흔들리는 봉숭아 꽃잎을 한참 동안 바라보았다. 그리고 어린 시절의 나에게, 그리고 지금의 나에게 조용히 속삭였다. 괜찮아, 지금 이 순간을 소중히 여기면 돼. 그것이 바로 행복이야.", "비 내리는 오후, 나는 창가에 앉아 하염없이 창밖을 바라보았다. 굵은 빗방울들이 유리창을 세차게 두드렸고, 세상은 온통 잿빛 물감으로 덧칠한 듯 흐릿했다. 이런 날이면 괜스레 마음이 차분해지고, 평소에는 떠오르지 않던 생각들이 꼬리에 꼬리를 물고 이어지곤 한다. 빗소리는 마치 세상의 모든 소음을 잠재우고, 오직 내면의 목소리에만 귀 기울이도록 만드는 마법과 같았다. 나는 잊고 지냈던 사람들을 떠올리고, 지나간 시간들을 반추하며, 미래의 불확실함에 대해 조용히 고민했다. 어쩌면 비는, 우리에게 잠시 멈춰 서서 자신을 돌아볼 시간을 선물하는 것일지도 모른다. 빠르게 변화하는 세상 속에서 미처 돌보지 못했던 마음의 상처들을 어루만지고, 잊고 지냈던 소중한 가치들을 다시 한번 되새길 수 있도록 말이다. 빗줄기가 조금씩 가늘어지더니, 이윽고 먹구름 사이로 희미한 햇살 한 줄기가 비쳐들었다. 비 온 뒤의 세상은 이전보다 더욱 깨끗하고 싱그러워 보였다. 내 마음도 한바탕 비를 맞고 난 뒤처럼, 한결 가볍고 맑아진 것을 느꼈다. 비는 모든 것을 쓸어내리고, 또다시 새로운 시작을 준비하게 만드는 자연의 경이로운 순환이었다.", "늦가을, 낙엽이 수북이 쌓인 오솔길을 혼자 걸었다. 발걸음을 옮길 때마다 바스락거리는 낙엽 소리가 정겹게 들려왔고, 코끝에는 쌉싸름하면서도 향긋한 가을 냄새가 스며들었다. 하늘은 더없이 높고 푸르렀으며, 나뭇가지 사이로 부서지는 햇살은 따스했다. 나는 천천히 걸으며, 화려했던 여름을 보내고 이제 겨울을 맞이할 준비를 하는 자연의 모습을 가만히 관찰했다. 울긋불긋 아름다운 색으로 물들었던 단풍잎들은 이제 마지막 빛을 발하며 땅으로 떨어져 내렸고, 앙상한 가지만 남은 나무들은 다가올 추위를 묵묵히 견뎌낼 준비를 하는 듯했다. 그 모습에서 나는 삶의 순환과 자연의 섭리를 느꼈다. 모든 것에는 시작과 끝이 있고, 성장의 시간이 있으면 쇠퇴의 시간도 있으며, 화려한 순간이 있으면 고요한 침묵의 순간도 있다는 것을. 그리고 그 모든 과정은 그 자체로 의미 있고 아름답다는 것을. 낙엽은 끝이 아니라 새로운 시작을 위한 준비였다. 땅으로 돌아가 거름이 되어, 다음 해 봄에 새로운 생명이 움틀 수 있도록 자신을 내어주는 것이다. 나는 깊어가는 가을의 정취 속에서, 삶의 유한함과 그 속에서 우리가 가져야 할 겸손함, 그리고 모든 것을 받아들이고 순응하는 지혜에 대해 생각했다. 낙엽 밟는 소리가 배경음악처럼 깔리는 그 길 위에서, 나는 자연이 주는 깊은 위안과 가르침을 얻었다.", "바람이 세차게 불던 어느 겨울날, 나는 바닷가 작은 등대를 찾아갔다. 하얀 포말을 일으키며 거칠게 밀려오는 파도와 매서운 바닷바람 속에서도 등대는 조금의 흔들림 없이 굳건히 서 있었다. 그 모습은 마치 세상의 온갖 풍파를 견뎌내며 자신의 자리를 지키는 고독한 수호자 같았다. 어둠이 내리면 등대는 어김없이 밝은 빛을 발하여, 밤바다를 항해하는 배들에게 길을 안내할 것이다. 그 빛은 단순한 불빛이 아니라, 험난한 바다 위에서 길을 잃은 이들에게 희망과 안도를 주는 생명의 빛이리라. 나는 문득 우리 삶에도 저런 등대와 같은 존재가 필요하다는 생각을 했다. 때로는 거친 파도처럼 힘겨운 시련이 몰아치고, 짙은 안개처럼 방향을 잃고 방황할 때, 우리를 올바른 길로 인도해주고 마음의 등불이 되어줄 그런 존재 말이다. 그것은 때로는 현명한 조언을 해주는 스승일 수도 있고, 변함없는 사랑을 주는 가족일 수도 있으며, 혹은 마음속 깊이 간직한 신념이나 가치관일 수도 있다. 중요한 것은 자신만의 등대를 가지고, 그 빛을 따라 꿋꿋이 나아가는 것이다. 세찬 바람 속에서도 묵묵히 빛을 밝히는 등대를 바라보며, 나는 내 삶의 등대는 무엇인지 다시 한번 생각해보았다.", "어린 시절, 동네 어귀에는 커다란 플라타너스 나무가 한 그루 서 있었다. 여름이면 무성한 잎으로 시원한 그늘을 만들어주었고, 가을이면 황금빛 낙엽을 아름답게 흩날렸으며, 겨울이면 앙상한 가지에 눈꽃을 피워 장관을 이루었다. 그 나무 아래는 언제나 아이들의 웃음소리가 끊이지 않는 놀이터였고, 동네 어른들의 정겨운 이야기가 오가는 쉼터였다. 나는 그 나무 아래에서 친구들과 술래잡기를 하고, 딱지치기를 하고, 때로는 가만히 앉아 하늘을 바라보며 엉뚱한 상상에 빠지기도 했다. 플라타너스 나무는 나의 유년 시절 모든 기억을 말없이 지켜봐 준 든든한 친구이자 보호자였다. 세월이 흘러 나는 어른이 되었고, 그 동네를 떠나온 지도 오래되었다. 하지만 문득 그 플라타너스 나무가 그리워질 때가 있다. 모든 것이 빠르게 변해가는 이 세상 속에서, 변함없이 그 자리를 지키고 있을 것 같은 그 나무의 존재가 주는 안정감 때문일까. 어쩌면 그 나무는 나에게 단순한 나무 이상의 의미였는지도 모른다. 그것은 돌아갈 수 없는 아름다운 시절에 대한 그리움이자, 순수했던 마음을 다시 찾고 싶은 작은 소망의 상징이었을 것이다. 언젠가 다시 그 나무 아래 서면, 나는 잠시나마 모든 것을 잊고 어린 시절의 나로 돌아갈 수 있을 것만 같다.", "오래된 엘피판을 꺼내 턴테이블 위에 올려놓는 것을 좋아한다. 지지직거리는 작은 소음과 함께 바늘이 레코드의 검은 골을 따라 천천히 움직이기 시작하면, 곧이어 따뜻하고 풍부한 아날로그 사운드가 공간을 가득 채운다. 디지털 음원에서는 느낄 수 없는 그 특유의 깊이와 온기는 마치 시간 여행을 하는 듯한 묘한 감흥을 불러일으킨다. 엘피판 한 장에는 단순히 음악만 담겨 있는 것이 아니다. 그 음악이 유행했던 시대의 공기, 그 음악을 함께 들었던 사람들과의 추억, 그리고 그 음악을 들으며 느꼈던 나의 젊은 날의 감정들이 고스란히 담겨 있다. 그래서 엘피를 듣는 것은 단순한 음악 감상을 넘어, 지나간 시간과의 조우이자 잊혀진 기억과의 재회이기도 하다. 때로는 빛바랜 앨범 재킷을 어루만지며 그 시절을 추억하고, 때로는 가사를 음미하며 그 의미를 되새기기도 한다. 세상은 점점 더 빠르고 편리한 것을 추구하지만, 나는 가끔 이렇게 느리고 불편한 아날로그의 세계에 머무르는 것을 좋아한다. 그 속에는 디지털이 결코 흉내 낼 수 없는 인간적인 따뜻함과 시간의 깊이가 존재하기 때문이다. 엘피판이 돌아가는 것을 가만히 바라보며, 나는 오늘도 잊혀진 시간 속으로 짧은 여행을 떠난다.", "작은 시골 간이역, 해 질 녘 플랫폼에는 기차를 기다리는 사람들보다 먼저 와 자리를 잡은 저녁노을이 더 짙었다. 나는 낡은 나무 의자에 앉아, 서쪽 하늘을 붉게 물들이며 서서히 스러져가는 노을의 마지막 장관을 바라보았다. 세상의 모든 색을 다 끌어모은 듯한 그 찬란한 빛의 향연 앞에서, 인간의 언어는 한없이 초라하게 느껴졌다. 노을은 낮과 밤의 경계에서 피어나는 짧지만 강렬한 예술과 같았다. 뜨거웠던 하루의 열정을 모두 불태우고, 이제 고요한 휴식의 시간으로 접어들기 위한 마지막 인사처럼. 나는 그 아름다움에 매료되어 한동안 아무 말도 할 수 없었다. 잠시 후, 노을이 완전히 자취를 감추고 어둠이 내려앉자, 하늘에는 하나둘씩 별들이 모습을 드러내기 시작했다. 그것은 마치 화려한 무대가 끝나고 다음 막이 오르기 전의 고요한 설렘과도 같았다. 삶에도 저런 노을과 같은 순간들이 있을 것이다. 모든 것을 쏟아부은 뒤 맞이하는 찬란한 마무리, 그리고 새로운 시작을 예비하는 고요한 성찰의 시간. 우리는 그 순간들을 통해 지나온 길을 돌아보고, 앞으로 나아갈 힘을 얻는다. 나는 깊어가는 밤의 적막 속에서, 오늘 하루 나에게 주어진 시간과 경험들에 감사하며, 내일 또다시 떠오를 새로운 태양을 기다렸다.", "나는 오래된 만년필로 일기를 쓰는 것을 좋아한다. 사각거리는 펜촉이 종이 위를 스치는 소리, 손끝으로 전해져 오는 잉크의 미세한 흐름, 그리고 한 자 한 자 정성스럽게 써 내려가는 글자들이 만들어내는 그 모든 과정이 나에게는 작은 의식과도 같다. 디지털 시대에 손으로 글을 쓴다는 것은 어쩌면 비효율적이고 번거로운 일일지도 모른다. 하지만 나는 그 느림과 불편함 속에서 오히려 더 깊은 사색과 진정한 자기표현의 즐거움을 발견한다. 컴퓨터 자판으로는 미처 담아낼 수 없는 생각의 결들과 감정의 미묘한 떨림들이, 만년필을 통해 종이 위에 고스란히 새겨지는 것을 느낀다. 일기장에는 그날 있었던 소소한 사건들뿐만 아니라, 마음속 깊은 곳에 숨겨두었던 생각들, 누구에게도 말하지 못했던 비밀들, 그리고 미래에 대한 막연한 기대와 불안까지 모든 것이 담긴다. 그것은 오롯이 나 자신과 마주하는 시간이며, 내 삶의 발자취를 기록하는 소중한 작업이다. 훗날 이 일기장을 다시 펼쳐보았을 때, 나는 지금 이 순간의 나를 만나고, 그 시절의 고민과 기쁨을 공유하며, 내가 얼마나 성장했는지를 돌아볼 수 있을 것이다. 만년필의 잉크가 마르듯 시간은 흘러가겠지만, 종이 위에 남겨진 나의 이야기는 영원히 그 자리에 남아 빛날 것이다.", "어느 늦봄, 나는 이름 모를 작은 산사의 툇마루에 앉아 있었다. 산사는 깊은 산속에 고즈넉이 자리 잡아, 세상의 모든 번뇌와 소음으로부터 벗어난 듯 평화로웠다. 처마 끝에 매달린 풍경은 바람이 불 때마다 맑고 청아한 소리를 냈고, 그 소리는 내 마음속까지 잔잔하게 울려 퍼졌다. 마당에는 수령을 알 수 없는 오래된 매화나무 한 그루가 마지막 꽃잎을 떨구고 있었고, 그 아래에는 작은 새 한 마리가 날아와 지저귀고 있었다. 나는 눈을 감고 가만히 그 모든 소리와 풍경을 마음에 담았다. 자연의 소리는 그 어떤 음악보다 아름다웠고, 산사의 고요함은 그 어떤 명상보다 깊은 평화를 가져다주었다. 복잡했던 머릿속은 어느새 텅 비고, 무거웠던 마음은 한결 가벼워졌다. 우리는 종종 너무 많은 것을 보고 듣고 생각하며 살아간다. 그래서 정작 중요한 내면의 소리에는 귀 기울이지 못하고, 진정한 휴식의 의미를 잊어버리곤 한다. 하지만 이렇게 잠시 모든 것을 내려놓고 자연 속에 머무르다 보면, 비로소 우리가 얼마나 작은 존재인지, 그리고 우리가 진정으로 추구해야 할 가치는 무엇인지 깨닫게 된다. 풍경 소리가 다시 한번 맑게 울리자, 나는 깊은 숨을 내쉬며 자리에서 일어섰다. 짧은 시간이었지만, 산사가 준 깊은 평화와 깨달음은 오랫동안 내 마음속에 남아 있을 것 같았다.", "오래된 흑백사진을 들여다보는 것을 좋아한다. 빛바랜 사진 속에는 지금은 만날 수 없는 사람들의 미소와 다시 돌아갈 수 없는 풍경들이 담겨 있다. 컬러사진이 현실을 있는 그대로 생생하게 재현한다면, 흑백사진은 현실 너머의 어떤 아련한 감성과 시간의 깊이를 느끼게 해주는 묘한 매력이 있다. 색이 사라진 세상은 오히려 더 많은 것을 상상하게 만들고, 인물의 표정과 배경의 분위기에 더욱 집중하게 만든다. 사진 속 인물들은 어떤 이야기를 간직하고 있을까, 그들은 어떤 꿈을 꾸고 어떤 사랑을 했을까. 나는 그런 상상을 하며 사진 속 시간으로 잠시 여행을 떠나곤 한다. 흑백사진은 단순한 기록이 아니라, 한 시대의 초상이자 누군가의 삶의 증거이다. 그 속에는 기쁨과 슬픔, 만남과 이별, 희망과 절망 등 인간이 겪을 수 있는 모든 감정들이 응축되어 있다. 그래서 흑백사진을 보고 있으면, 때로는 알 수 없는 그리움에 가슴이 아련해지기도 하고, 때로는 삶의 숙연함에 고개가 숙여지기도 한다. 사진 한 장이 건네는 수많은 이야기들. 나는 그 이야기들을 통해 과거와 현재를 잇고, 사라진 시간 속에서 변치 않는 가치를 발견한다. 흑백사진은 나에게 침묵으로 더 많은 것을 말해주는 오래된 친구와 같다.", "한겨울 밤, 창밖에는 하얀 눈이 소리 없이 내리고 있었다. 나는 따뜻한 코코아 한 잔을 들고 창가에 서서, 밤새 세상을 하얗게 뒤덮을 것 같은 눈송이들을 하염없이 바라보았다. 가로등 불빛 아래 춤추듯 흩날리는 눈송이들은 마치 동화 속 한 장면처럼 비현실적으로 아름다웠다. 눈은 세상의 모든 더러움과 소음을 하얗게 덮어버리고, 고요하고 순수한 평화를 가져다주는 것 같았다. 나는 어린아이처럼 창문에 입김을 불어 작은 그림을 그리기도 하고, 손을 내밀어 차가운 눈송이를 직접 만져보기도 했다. 눈이 내리는 풍경은 언제나 나를 설레게 하고, 잊고 지냈던 동심을 일깨워준다. 어쩌면 눈은, 하늘이 우리에게 보내는 하얀 편지일지도 모른다. 잠시 모든 것을 잊고 순수한 기쁨을 느껴보라고, 그리고 새로운 시작을 준비하라고 속삭이는 아름다운 편지. 나는 코코아의 마지막 한 모금을 마시며, 내일 아침 눈부시게 펼쳐질 하얀 세상을 상상했다. 발자국 하나 없는 깨끗한 눈밭 위를 처음으로 걷는 기분은 얼마나 상쾌할까. 눈이 그치고 아침이 오면, 나는 가장 먼저 하얀 세상 속으로 달려 나가, 겨울이 주는 특별한 선물을 만끽할 것이다.", "오래된 시장을 찾는 것을 좋아한다. 대형마트의 깔끔함과 편리함도 좋지만, 시장에는 그곳에서만 느낄 수 있는 특별한 활기와 정겨움이 있다. 좌판 가득 싱싱한 채소와 과일을 진열해놓고 구성진 목소리로 손님을 부르는 상인들, 흥정을 하며 덤을 얻어가는 손님들의 웃음소리, 맛있는 냄새를 풍기며 발길을 유혹하는 길거리 음식들까지. 시장은 살아있는 사람들의 이야기로 가득한 공간이다. 나는 천천히 시장 골목을 걸으며, 다양한 물건들을 구경하고 사람들의 살아가는 모습을 관찰한다. 그 속에서 나는 잊고 지냈던 인간적인 따뜻함과 소박한 삶의 아름다움을 발견한다. 시장 상인들의 거친 손마디에는 정직한 땀의 가치가 담겨 있고, 그들의 구릿빛 얼굴에는 세월의 흔적과 삶의 지혜가 새겨져 있다. 그들은 단순히 물건을 파는 것이 아니라, 자신의 삶을 나누고 사람들과 정을 주고받는다. 그래서 시장에서의 거래는 단순한 매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다."], engLong: [ "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper and faint wood, a nostalgic perfume that seemed to whisper tales of bygone eras. Tiny dust motes danced in the invading sunbeams, sparkling like miniature galaxies, and the world outside, viewed through the grimy pane, appeared as a distant, dreamlike watercolor. I had creaked my way up the wooden stairs, settling into the worn comfort of a rocking chair by the window. Below, an ancient oak stood sentinel, its leaves rustling a quiet, timeless song with every breeze, a silent observer of centuries unfolding. In that tranquil tableau, I found myself sifting through childhood memories: a grandmother's gentle voice narrating fairy tales, the vibrant hues of a sunset over a familiar alleyway, the first stirrings of a young heart's joy and sorrow. Time, in its relentless march, may alter all things, yet the warmth embedded in memory, I realized, remains an immutable sanctuary. Perhaps we all carry a small, secret attic within our souls, a place of solace filled with cherished recollections, a haven to retreat to when the world outside grows too loud.", "Under the velvet cloak of a moonless night, countless stars were scattered across the celestial canvas like diamonds on black silk. With a warm cup of herbal tea cradled in my hands, I stood by the window, lost in the profound mystery of the infinite expanse. The deeper the darkness, the more intensely the starlight seemed to pierce through, its serene luminescence seeping into the very core of my being. One distant, unnamed star shone with a particular brilliance, a beacon for a lost traveler, perhaps, or a tiny lantern carrying a whispered wish to the heavens. Gazing at it, I was transported back to the untainted dreams of youth: a daring explorer charting unknown territories, an artist evoking profound emotions, an astronomer unraveling cosmic secrets. Those aspirations, once so vivid but gradually set aside against the unyielding walls of reality, flickered faintly back to life under the starlight. Maybe dreams never truly vanish; perhaps they merely slumber in the night sky of our hearts, awaiting the courage to be pursued once more. As I sipped the last of my tea, I made a quiet promise to those stars, and to myself: to keep writing the unfinished chapters of my own story, guided by their distant, unwavering light.", "The scent of pine needles and damp earth filled the air as she walked deeper into the ancient woods. Sunlight struggled to penetrate the thick canopy, casting an ethereal, green-tinged light on the forest floor. Moss grew like velvet on the trunks and branches of old trees, and delicate ferns uncurled their fronds in the damp places where shadows lingered. She paused by a gnarled oak, its bark a tapestry of a thousand storms weathered and a thousand suns embraced. It seemed to whisper secrets of the ages, of creatures seen and unseen, of seasons turning in an endless, graceful dance. Here, away from the clamor of human invention, she felt a profound connection to something primal, something enduring. The forest was not merely a collection of trees, but a living, breathing entity, a sanctuary for the soul seeking quietude and a reminder of the intricate beauty of the natural world. Each fallen leaf crunched underfoot was a note in an ancient song, a testament to the cycle of life, death, and renewal, a humbling perspective in the grand theatre of existence.", "In the heart of the bustling city, there existed a small, almost forgotten courtyard, a tiny oasis of green amidst the towering steel and glass. Ivy climbed the old brick walls, and a single, resilient cherry tree bloomed defiantly each spring, its blossoms a soft pink rebellion against the urban grey. Few knew of this place, tucked away behind a narrow alley, and those who did cherished it as a secret haven. Here, the city's roar subsided to a distant hum, and one could hear the cooing of pigeons or the rustle of leaves in the gentle breeze. It was a place for quiet contemplation, for stolen moments of peace in a world that seldom seemed to pause. Sometimes, an artist would sit on the worn stone bench, sketching the play of light and shadow, or a writer would fill a notebook with fleeting thoughts and observations, inspired by the unexpected tranquility found in such an urban pocket of serenity. This courtyard was a reminder that even in the most concrete of jungles, nature, and a moment's peace, could always find a way to endure.", "The old lighthouse stood sentinel on the jagged cliff, its stoic form a familiar silhouette against the turbulent, grey sky. For generations, its beam had cut through the darkest storms, a steadfast promise of guidance to sailors navigating the treacherous coastal waters. The keeper, a man with a weather-beaten face and eyes that held the wisdom of the sea, lived a solitary life, his only companions the cry of gulls and the ceaseless rhythm of the waves. He knew every mood of the ocean, from its gentle summer caress to its furious winter rage. His days were marked by routine: tending the great lamp, polishing the massive Fresnel lens, and scanning the horizon for any sign of a vessel in distress. It was a life of responsibility, of quiet dedication to a purpose larger than himself. The lighthouse was more than just a structure of stone and light; it was a symbol of hope, a beacon of resilience against the raw, untamed power of nature, and a testament to the enduring human spirit that sought to illuminate the darkness and bring wanderers safely home, a silent guardian watching over the restless sea.", "A gentle rain began to fall as evening descended, a soft, persistent patter against the windowpanes. Inside, the warmth of the hearth cast a flickering, amber glow across the room, a stark contrast to the cool, damp air outside. She sat curled in an old armchair, a half-read book resting in her lap, a pensive expression on her face. The rain was a soothing melody, a lullaby that seemed to wash away the day's accumulated anxieties and quiet the relentless chatter of the mind. It was on nights like these, cocooned in the quiet solitude of her home, that her thoughts roamed free, unburdened by the demands of the world. She pondered the intricate tapestry of human connection, the fragile threads that bound one soul to another, the unexpected joys and inevitable sorrows that colored the human experience. The rhythmic drumming of the rain provided a comforting backdrop to her reflections, a reminder of nature's constant, gentle presence, and the quiet beauty to be found in a simple, rainy evening spent in peaceful contemplation.", "The desert stretched out before him, an endless expanse of undulating dunes under a sky so vast it seemed to swallow the horizon. The sun beat down relentlessly, and the air shimmered with an almost palpable heat. Yet, amidst this harsh and unforgiving landscape, there was a stark, austere beauty that captivated the soul. The way the wind sculpted the sand into ever-changing, sinuous patterns, the resilience of the sparse, thorny vegetation clinging stubbornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding."]
};

function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}

document.addEventListener('DOMContentLoaded', () => {
  languageSelectEl = document.getElementById('languageSelect');
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');

  // ▼▼▼ 글쓰기 모드 요소 초기화 ▼▼▼
  freestyleAreaContainerEl = document.getElementById('freestyle-area-container');
  freestyleInputAreaEl = document.getElementById('freestyle-input-area');
  downloadFreestyleBtnEl = document.getElementById('download-freestyle-btn');
  freestyleFilenameInputEl = document.getElementById('freestyle-filename-input');
  freestyleToolbarEl = document.getElementById('freestyle-toolbar');
  insertDateBtn = document.getElementById('insertDateBtn');
  insertTimeBtn = document.getElementById('insertTimeBtn');
  emojiBtn = document.getElementById('emojiBtn');
  emojiPicker = document.getElementById('emoji-picker');
  formatBoldBtn = document.getElementById('formatBoldBtn');
  formatItalicBtn = document.getElementById('formatItalicBtn');
  insertHrBtn = document.getElementById('insertHrBtn');
  focusModeBtn = document.getElementById('focusModeBtn');
  charCountEl = document.getElementById('charCount');
  wordCountEl = document.getElementById('wordCount');
  // ▲▲▲ 글쓰기 모드 요소 초기화 ▲▲▲

  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  const allElements = [languageSelectEl, lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl, freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl, freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker, formatBoldBtn, formatItalicBtn, insertHrBtn, focusModeBtn, charCountEl, wordCountEl];
  if (!allElements.every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다. 누락된 요소를 확인해주세요.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }

  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;

  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;

  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';


  initializeAudioPool();
  buildKeyboard();

  document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(button => {
    button.addEventListener('click', function() {
      const type = this.dataset.practiceType;
      if (type === 'freestyle') {
          startFreestyleMode();
      } else {
          const lang = languageSelectEl.value;
          const mode = (type === 'long') ? `${lang}Long` : lang;
          startPractice(mode, true);
      }
    });
  });

  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => activateGameMode('rainfall'));
  }

  languageSelectEl.addEventListener('change', () => {
    if (currentMode !== 'freestyle') {
      const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
      const type = activePracticeBtn ? activePracticeBtn.dataset.practiceType : 'short';
      if(type !== 'freestyle'){
          const lang = languageSelectEl.value;
          const mode = (type === 'long') ? `${lang}Long` : lang;
          startPractice(mode, true);
      }
    }
  });

  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';

  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }

  typingInputField.addEventListener('input', handleInputEvent);

  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }

  document.body.addEventListener('click', function(e) {
    if (emojiPicker.classList.contains('visible') && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
        emojiPicker.classList.remove('visible');
    }

    const isInteractiveElement = e.target.closest('button, a, select, input, textarea, #emoji-picker span');

    if (!isInteractiveElement) {
      if (document.body.classList.contains('game-mode-active')) {
        if (gameInputField && !gameInputField.disabled) gameInputField.focus();
      } else if (document.body.classList.contains('freestyle-mode-active')) {
        if (freestyleInputAreaEl) freestyleInputAreaEl.focus();
      } else {
        if (typingInputField && !typingInputField.disabled) typingInputField.focus();
      }
    }
  });

  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });

  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl && linesToPractice[currentDisplayLineIndex] !== undefined) {
        handleHighlightUpdate(currentLineEl, typingInputField.value, linesToPractice[currentDisplayLineIndex]);
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    if (audioPool[currentSoundPack] && (audioPointer[currentSoundPack] === undefined || audioPointer[currentSoundPack] === null) ) {
        audioPointer[currentSoundPack] = 0;
    } else if (!audioPool[currentSoundPack]) {
        initializeAudioPoolForPack(currentSoundPack);
    }
  });

  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });

  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });

  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> 자리연습 ON' : '<i class="far fa-keyboard"></i> 자리연습 OFF';

    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }

    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });

  // ▼▼▼ 글쓰기 모드 이벤트 리스너 추가 ▼▼▼
  freestyleInputAreaEl.addEventListener('input', () => {
      playTypingSound();
      if (!startTime) {
          startTime = Date.now();
      }
      updateFreestyleStats();
  });
  freestyleInputAreaEl.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
          playTypingSound();
      }
  });
  downloadFreestyleBtnEl.addEventListener('click', handleFreestyleDownload);
  insertDateBtn.addEventListener('click', insertDate);
  insertTimeBtn.addEventListener('click', insertTime);
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('visible');
  });
  emojiPicker.querySelectorAll('span').forEach(emoji => {
    emoji.addEventListener('click', () => {
        insertAtCursor(freestyleInputAreaEl, emoji.textContent);
        emojiPicker.classList.remove('visible');
        freestyleInputAreaEl.focus();
    });
  });
  formatBoldBtn.addEventListener('click', () => wrapSelectionWithTag(freestyleInputAreaEl, '**'));
  formatItalicBtn.addEventListener('click', () => wrapSelectionWithTag(freestyleInputAreaEl, '*'));
  insertHrBtn.addEventListener('click', () => insertAtCursor(freestyleInputAreaEl, '\n\n---\n\n'));
  focusModeBtn.addEventListener('click', toggleFocusMode);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.body.classList.contains('focus-mode-active')) {
        toggleFocusMode();
    }
  });
  // ▲▲▲ 글쓰기 모드 이벤트 리스너 추가 ▲▲▲

  startPractice('kor', true);
});

function cleanupActiveModes() {
    document.body.classList.remove('game-mode-active', 'freestyle-mode-active', 'focus-mode-active');

    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);
    if (freestyleStatsInterval) clearInterval(freestyleStatsInterval);

    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    freestyleStatsInterval = null;
    startTime = null;

    if(typingInputField) typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    if(gameInputField) gameInputField.removeEventListener('keydown', handleKeyDownEvent);

    enablePracticeControls();
}

function disableFreestyleControls() {
    toggleHighlightBtn.classList.add('disabled');
    toggleKeyboardGuideBtn.classList.add('disabled');
    languageSelectEl.closest('.language-settings').classList.add('disabled');
}

function enablePracticeControls() {
    toggleHighlightBtn.classList.remove('disabled');
    toggleKeyboardGuideBtn.classList.remove('disabled');
    languageSelectEl.closest('.language-settings').classList.remove('disabled');
}

function startPractice(mode, resetSessionStats = false) {
    cleanupActiveModes();

    currentMode = mode;
    currentGameType = '';

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === (mode.includes('Long') ? 'long' : 'short'));
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    if(resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';

    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }

    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }

    currentLineStartTime = null;
    currentArticleCorrectChars = 0;

    currentDisplayLineIndex = 0;
    const poolToUse = sentencePool[currentMode];
    let textToPractice = getRandom(poolToUse);
    if (!textToPractice && poolToUse && poolToUse.length > 0) textToPractice = poolToUse[0];
    if (!textToPractice) textToPractice = "예문 로딩에 실패했습니다.";

    linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if (linesToPractice.length === 0) {
        linesToPractice.push(textToPractice.includes("실패") ? textToPractice : "예문 처리 중 오류가 발생했습니다.");
    }

    if (currentMode.includes('Long') && linesToPractice.length > 1) {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'block';
    } else {
        if(progressBarContainerEl) progressBarContainerEl.style.display = 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();

    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}


function startFreestyleMode() {
    cleanupActiveModes();
    document.body.classList.add('freestyle-mode-active');
    currentMode = 'freestyle';

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === 'freestyle');
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    disableFreestyleControls();

    if (toggleHighlightBtn.classList.contains('active')) toggleHighlightBtn.classList.remove('active');
    if (toggleKeyboardGuideBtn.classList.contains('active')) toggleKeyboardGuideBtn.classList.remove('active');
    highlightEnabled = false;
    keyboardGuideEnabled = false;
    if (keyboardGuideEl) keyboardGuideEl.classList.remove('visible');


    if (resultEl) resultEl.textContent = '자유롭게 글을 작성하고 타건을 즐겨보세요.';

    startTime = null;
    overallMaxSpeed = 0;
    overallAvgSpeedLog = [];
    sessionTotalValidChars = 0;
    sessionTotalCorrectChars = 0;
    sessionTotalMistypedChars = 0;
    lastArticleSpeed = 0;
    updateStatsDisplay(true);

    if (document.getElementById('accuracyStat')) document.getElementById('accuracyStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('avgSpeedStat')) document.getElementById('avgSpeedStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('maxSpeedStat')) document.getElementById('maxSpeedStat').innerHTML = '<span class="value">—</span>';

    freestyleInputAreaEl.value = '';
    freestyleInputAreaEl.focus();

    updateFreestyleStats();
    if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    freestyleStatsInterval = setInterval(updateFreestyleStats, 500);
}

function updateFreestyleStats() {
    if (currentMode !== 'freestyle') {
        if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
        return;
    };
    const text = freestyleInputAreaEl.value;
    const charLength = text.length;
    const wordLength = text.trim().split(/\s+/).filter(Boolean).length;

    charCountEl.textContent = `${charLength}자`;
    wordCountEl.textContent = `${wordLength}단어`;

    if (startTime) { // 시작 시간이 기록되었는지 먼저 확인
        const elapsedMinutes = (Date.now() - startTime) / 60000; // <--- 변수를 여기서 선언합니다.
        if (elapsedMinutes > 0) {
            const speed = Math.round((charLength / elapsedMinutes) * KOR_SPEED_FACTOR);
            if (document.getElementById('speedStat')) {
                document.getElementById('speedStat').textContent = `${speed} 타/분`;
            }
        }
    }
}
function handleFreestyleDownload() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        alert('저장할 내용이 없습니다.');
        return;
    }

    let filename = freestyleFilenameInputEl.value.trim();
    if (filename === '') {
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        filename = `keytherapy_${timestamp}`;
    }

    if (!filename.toLowerCase().endsWith('.txt')) {
        filename += '.txt';
    }

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function insertAtCursor(myField, myValue) {
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length;
        myField.selectionEnd = startPos + myValue.length;
    } else {
        myField.value += myValue;
    }
    updateFreestyleStats();
    myField.focus();
}

function wrapSelectionWithTag(field, tag) {
    const start = field.selectionStart;
    const end = field.selectionEnd;
    const selectedText = field.value.substring(start, end);
    const replacement = tag + selectedText + tag;
    
    field.setRangeText(replacement, start, end, 'end');

    if (selectedText.length === 0) {
        field.setSelectionRange(start + tag.length, start + tag.length);
    }
    updateFreestyleStats();
    field.focus();
}

function insertDate() {
    const now = new Date();
    const dateString = `${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일`;
    insertAtCursor(freestyleInputAreaEl, dateString + " ");
}

function insertTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const formattedHours = (hours % 12) || 12;
    const timeString = `${ampm} ${formattedHours}:${minutes}`;
    insertAtCursor(freestyleInputAreaEl, timeString + " ");
}

function toggleFocusMode() {
    document.body.classList.toggle('focus-mode-active');
    const icon = focusModeBtn.querySelector('i');
    if (document.body.classList.contains('focus-mode-active')) {
        icon.classList.remove('fa-expand');
        icon.classList.add('fa-compress');
    } else {
        icon.classList.remove('fa-compress');
        icon.classList.add('fa-expand');
    }
    freestyleInputAreaEl.focus();
}

function applyTheme(theme) {
    document.body.classList.remove('light-theme', 'pink-theme');
    if (theme === 'light') document.body.classList.add('light-theme');
    else if (theme === 'pink') document.body.classList.add('pink-theme');

    if (gameCanvas && currentGameType) {
        requestAnimationFrame(() => {
            if (currentGameType === 'rainfall') drawRainfallGame();
            else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
            else if (currentGameType === 'giantBattle') drawGiantBattleGame();
        });
    }
}


function initializeAudioPoolForPack(packKey) {
    if (soundFiles.hasOwnProperty(packKey) && (!audioPool[packKey] || audioPool[packKey].length === 0)) {
        audioPool[packKey] = [];
        audioPointer[packKey] = 0;
        for (let i = 0; i < MAX_AUDIO_OBJECTS; i++) {
            const audio = new Audio();
            audio.preload = 'auto';
            audioPool[packKey].push(audio);
        }
    }
}

function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}

function splitTextIntoLines(text, mode, screenWidth) {
    let maxLength;
    if (mode.includes('Long')) {
        if (screenWidth <= 480) maxLength = mode.includes('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.includes('eng') ? 55 : 35;
        else maxLength = mode.includes('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }

    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.includes('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}

function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';

    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();

    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.textContent = passedLineText;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);

    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');

    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        handleHighlightUpdate(currentEl, "", currentLineText);
    } else {
        currentEl.textContent = ' ';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);

    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = upcomingLineText;
            fragmentUpcoming.appendChild(upcomingEl);
        } else {
            const upcomingEl = document.createElement('div');
            upcomingEl.classList.add('typing-line', 'upcoming');
            upcomingEl.textContent = ' ';
            upcomingEl.style.visibility = 'hidden';
            fragmentUpcoming.appendChild(upcomingEl);
        }
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
}

function handleInputEvent(e) {
    if ((currentMode !== 'game' && e.target === typingInputField) || (currentMode === 'game' && e.target === gameInputField)) {
        playTypingSound();
    }

    if (currentMode !== 'game' && currentMode !== 'freestyle' && e.target === typingInputField) {
        const typedValue = typingInputField.value;
        const currentLineEl = document.getElementById('current-typing-line');
        if (!currentLineEl) return;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        handleHighlightUpdate(currentLineEl, typedValue, originalLine);
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight();
    }
}

function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;
    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">타자 연습 시작...</span><span id="cursor"></span>`;
        return;
    }

    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span id="cursor"></span>`;
    } else {
        fakeInputField.innerHTML = `${typedValue}<span id="cursor"></span>`;
    }
}


function handleHighlightUpdate(targetElement, typedValue, originalLine) {
    if (!targetElement) return;
    if (typeof originalLine !== 'string') {
        targetElement.textContent = ' ';
        return;
    }
    let builtHTML = "";
    for (let i = 0; i < originalLine.length; i++) {
        const char = originalLine[i];

        if (i < typedValue.length) {
            if (highlightEnabled && typedValue[i] !== originalLine[i]) {
                builtHTML += `<span class="highlight">${char}</span>`;
            } else {
                builtHTML += `<strong>${char}</strong>`;
            }
        } else {
            builtHTML += `<span class="untyped-char">${char}</span>`;
        }
    }
    targetElement.innerHTML = builtHTML || ' ';
}

function handleKeyDownEvent(e) {
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const targetInput = e.target;

    if (e.isComposing) return;

    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }

    if (currentMode !== 'game' && currentMode !== 'freestyle' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;

        if (e.key === 'Backspace' || (e.key === 'Shift' && !e.repeat && !isModifierKey)) {
            playTypingSound();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            playTypingSound();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            playTypingSound();
            processCurrentLineCompletion();
        } else if (e.key === ' ' && originalLine !== null) {
            playTypingSound();
        }
    }
}


function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }

    let lineCorrectCharsThisLine = 0;
    let lineMistypedCharsOnThisLine = 0;

    for (let i = 0; i < originalLine.length; i++) {
        if (i < typedValue.length) {
            if (typedValue[i] === originalLine[i]) {
                lineCorrectCharsThisLine++;
            } else {
                lineMistypedCharsOnThisLine++;
            }
        } else {
            lineMistypedCharsOnThisLine++;
        }
    }
    if (typedValue.length > originalLine.length) {
        lineMistypedCharsOnThisLine += (typedValue.length - originalLine.length);
    }

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;

    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }


    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;

    if (!currentMode.includes('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }

    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if(resultEl) resultEl.textContent = currentMode.includes('Long') ? '장문 완료! 새로운 문제 준비 중...' : '연습 완료! 새로운 문제 준비 중...';
        if (currentMode.includes('Long')) {
            currentArticleCorrectChars = 0;
            startTime = null;
        }
        setTimeout(() => startPractice(currentMode, false), 200);
    }
}

function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;

  let currentSpeedToShow = 0;
  if (isSessionReset) {
      currentSpeedToShow = 0;
  } else if (startTime === null && !currentMode.includes('Long')) {
      currentSpeedToShow = lastArticleSpeed;
  } else if (currentMode.includes('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * (currentMode.includes('kor') ? KOR_SPEED_FACTOR : 1));
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;

  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;

  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;

  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} 타/분`;
}


function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.includes('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}

function playTypingSound() {
  if (!soundEnabled || !currentSoundPack || !soundFiles[currentSoundPack] || !audioPool[currentSoundPack]) return;

  const soundPackSounds = soundFiles[currentSoundPack];
  const currentAudioPoolForPack = audioPool[currentSoundPack];

  if (soundPackSounds.length === 0 || currentAudioPoolForPack.length === 0) return;

  const soundSrc = getRandom(soundPackSounds);
  if (!soundSrc) return;

  let foundAvailableAudio = false;
  for (let i = 0; i < currentAudioPoolForPack.length; i++) {
      const audioIndex = (audioPointer[currentSoundPack] + i) % currentAudioPoolForPack.length;
      let audioToPlay = currentAudioPoolForPack[audioIndex];

      if (audioToPlay && audioToPlay.paused) {
          audioPointer[currentSoundPack] = (audioIndex + 1) % currentAudioPoolForPack.length;
          audioToPlay.src = soundSrc;
          const playPromise = audioToPlay.play();
          if (playPromise !== undefined) {
              playPromise.catch(error => { /* console.warn("Audio play failed:", error); */ });
          }
          foundAvailableAudio = true;
          break;
      }
  }

  if (!foundAvailableAudio) {
      let audioToPlay = currentAudioPoolForPack[audioPointer[currentSoundPack]];
      audioPointer[currentSoundPack] = (audioPointer[currentSoundPack] + 1) % currentAudioPoolForPack.length;
      if (audioToPlay) {
        audioToPlay.src = soundSrc;
        const playPromise = audioToPlay.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => { /* console.warn("Fallback audio play failed:", error); */ });
        }
      }
  }
}

function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// --- GAME MODE ENTRY POINT ---
function activateGameMode(gameType) {
    cleanupActiveModes();
    document.body.classList.add('game-mode-active');

    currentMode = 'game';
    currentGameType = gameType;

    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }

    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);

    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;


    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;

    gameStartMessageEl = document.getElementById('game-start-message');
    gameCanvas = document.getElementById('game-canvas');
    if (gameCanvas) gameCtx = gameCanvas.getContext('2d');
    else console.error("activateGameMode: game-canvas 요소를 찾을 수 없습니다.");

    gameInputField = document.getElementById('game-input-field');
    gameOverlayEl = document.getElementById('gameOverlay');
    itemEffectPopupEl = document.getElementById('item-effect-popup');
    lbbTimerBarContainerEl = document.getElementById('lbb-timer-bar-container');
    lbbTimerBarEl = document.getElementById('lbb-timer-bar');
    lbbTimerTextEl = document.getElementById('lbb-timer-text');

    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }

    const gameTypeRow = document.getElementById('gameTypeSelectionRow');
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => activateGameMode('rainfall'));
    gameTypeRow.appendChild(sonagiBtn);

    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => activateGameMode('letterBlockBattle'));
    gameTypeRow.appendChild(letterBlockBtn);

    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> 타이핑 배틀';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => activateGameMode('giantBattle'));
    gameTypeRow.appendChild(typingBattleBtn);

    const settingsRow1 = document.getElementById('gameSettingsRow1');
    const settingsRow2 = document.getElementById('gameSettingsRow2');
    settingsRow1.innerHTML = ''; settingsRow2.innerHTML = '';

    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);

    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);

    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);

    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';

    let maxLevelForSelect;
    let currentLevelForSelect;

    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }

    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
    gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }
        if (isActive) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);

    settingsRow2.appendChild(levelControlItem);

    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);

    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);

    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }

    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 생명)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3초 멈춤)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (화면 정리)</div>
             </div>
             <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>상하좌우 블록의 단어를 입력하여 이동하고, 적과 빈 칸으로 연결되면 승리합니다!<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> 타이핑 배틀</h2>
            <p>쏟아지는 단어들을 정확히 입력하여 적의 공격을 막아내고,<br>당신의 공격 단어로 적을 격파하세요! 2분 안에 승리하세요!</p>
            <p>레벨을 선택하고 게임 시작 버튼을 누르세요.</p>
            <button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작</button>`;
        document.getElementById('startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(document.getElementById('gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";

    document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.classList.add('active');
    }
}

function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}


// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);

    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}

function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }

        drawRainfallGame();

        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }

        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}

function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }

    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error("Rainfall: Invalid game level configuration for level " + rainfall_gameLevel);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) {
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}

function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }

    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`점수: ${rainfall_gameScore}`, 15, 30);

    gameCtx.textAlign = 'center';
    gameCtx.fillText(`레벨: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);

    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`생명: ${'❤️'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;

        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;

        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}


function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    function generateWord() {
        if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;

        let newWordText;
        let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
        let itemDetails = null;

        if (isItem) {
            const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
            itemDetails = getRandom(itemTypes);
            newWordText = itemDetails.text;
        } else {
            const wordPool = gameWordsKor.filter(w => w.length <= 4);
            const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
            newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
            if (!newWordText) newWordText = '단어';
        }

        rainfall_usedWordsInLevel.add(newWordText);
        if (rainfall_usedWordsInLevel.size > 100) {
            const oldestWord = rainfall_usedWordsInLevel.values().next().value;
            rainfall_usedWordsInLevel.delete(oldestWord);
        }

        const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

        rainfall_wordsOnScreen.push({
            text: newWordText,
            x: Math.random() * (gameCanvas.width - 100) + 50,
            y: -20,
            speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
            isFast: isFast,
            itemType: isItem ? itemDetails.type : null,
            color: isItem ? itemDetails.color : null,
            duration: isItem ? itemDetails.duration : 0
        });
    }

    generateWord();
    rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
}


function handleRainfallGameInputSubmit() {
    if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
    const typedWord = gameInputField.value.trim();
    if (typedWord === "") return;

    let wordFound = false;
    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        const wordToMatch = word.text;

        if (typedWord === wordToMatch) {
            if (word.itemType) {
                activateRainfallItemEffect(word.itemType, word.duration);
            } else {
                rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
            }

            rainfall_wordsOnScreen.splice(i, 1);
            wordFound = true;
            break;
        }
    }

    if (!wordFound) {
        if(gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    gameInputField.value = "";
}

function activateRainfallItemEffect(itemType, duration) {
    let popupText = "";
    const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
    if (!itemInfo) return;

    switch(itemType) {
        case 'extraLife':
            if (rainfall_gameLives < 10) rainfall_gameLives++;
            popupText = `생명 +1 ${itemInfo.icon}`;
            break;
        case 'timeStop':
            rainfall_isTimeStopped = true;
            popupText = `시간 정지! ${itemInfo.icon}`;
            if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
            window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
            break;
        case 'clearScreen':
            popupText = `화면 정리! ${itemInfo.icon}`;
            for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                if (!rainfall_wordsOnScreen[j].itemType) {
                    rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                    rainfall_wordsOnScreen.splice(j, 1);
                }
            }
            break;
    }
    if (popupText) showGamePopup(popupText, 1500);
}


function triggerRainfallLifeLostEffect() {
    if (gameCanvas) {
        gameCanvas.classList.add('flash-effect');
        setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
    }
}


// --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
    if(level) lbb_gameLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    lbb_playerNoPlayableBlocksTimerId = null;
    if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    lbb_relocationCountdownIntervalId = null;

    lbb_isGameActive = true;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_isRelocating = false;

    lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];

    lbb_playerScore = 0;
    lbb_enemyScore = 0;

    generateLBBGameBoard();
    lbb_playerPos = { r: 0, c: 0 };
    lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
    lbb_enemyOriginalStartPos = { ...lbb_enemyPos };

    if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
        lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
    }
    if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
        lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
    }

    if (gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    lbb_gameStartTime = Date.now();
    lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
    startLBBGameLoop();
}

function startLBBGameLoop() {
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    function loop() {
        if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
            cancelAnimationFrame(lbb_gameLoopId);
            lbb_gameLoopId = null;
            return;
        }
        drawLetterBlockBattleGame();
        if(lbb_isGameActive && !lbb_gamePausedForOverlay){
            updateLBBGameLogic();
        }
        lbb_gameLoopId = requestAnimationFrame(loop);
    }
    lbb_gameLoopId = requestAnimationFrame(loop);
}

function updateLBBGameLogic() {
    if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

    if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
        return;
    }

    if (lbb_swapEffect.active) {
        updateLBBSwapAnimation();
    } else if (lbb_finalBattleAnimation.isActive) {
        updateLBBFinalBattleAnimation();
    } else {
        if (!lbb_isRelocating) {
             checkAndTriggerPlayerLBBRelocation();
        }
    }

    lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
    lbb_blockBreakParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.alpha -= 0.02;
    });
}

function drawLetterBlockBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
    const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
    const boardX = (gameCanvas.width - boardWidth) / 2;
    const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

    const bodyClasses = document.body.classList;
    let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
        inputBgColor = '#fefcf9';
        brokenColor = '#f9f5f0';
        playerBlockBg = '#fffacd';
        playerColor = '#4A90E2';
        enemyColor = '#D0021B';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
        inputBgColor = '#fffafa';
        brokenColor = '#fff5f8';
        playerBlockBg = '#ffe8f0';
        playerColor = '#E91E63';
        enemyColor = '#7B1FA2';
    } else {
        textColor = '#e8e0d8';
        inputBgColor = '#33302e';
        brokenColor = '#262422';
        playerBlockBg = 'rgba(212, 175, 122, 0.08)';
        playerColor = 'dodgerblue';
        enemyColor = 'tomato';
    }

    const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
            if (!block) continue;

            const x = boardX + c * LBB_BLOCK_SIZE;
            const y = boardY + r * LBB_BLOCK_SIZE;

            gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

            if (!block.broken) {
                const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                if (isPlayerAdjacent) {
                    gameCtx.fillStyle = playerBlockBg;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }

                gameCtx.font = lbb_blockTextFont;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillStyle = block.effect.color || textColor;
                gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                if (block.effect.icon) {
                    gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                    gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                }
            }
            gameCtx.strokeStyle = borderColor;
            gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
        }
    }

    lbb_blockBreakParticles.forEach(p => {
        gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
        gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
    });

    function drawCharacter(pos, color, isPlayer) {
        const x = boardX + pos.c * LBB_BLOCK_SIZE;
        const y = boardY + pos.r * LBB_BLOCK_SIZE;
        gameCtx.fillStyle = color;
        gameCtx.beginPath();
        gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
        gameCtx.fill();
        if (isPlayer) {
            gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.lineWidth = 1;
        }
    }

    if (lbb_swapEffect.active) {
        drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
        drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
    } else if (lbb_finalBattleAnimation.isActive) {
        drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
        drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
    } else {
        drawCharacter(lbb_playerPos, playerColor, true);
        drawCharacter(lbb_enemyPos, enemyColor, false);
    }

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.textAlign = 'left';
    gameCtx.fillStyle = playerColor;
    gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 15, 30);
    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = enemyColor;
    gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
    gameCtx.textAlign = 'center';
    gameCtx.fillStyle = textColor;
    gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);

    if (lbb_relocationCountdown > 0) {
        gameCtx.font = "bold 16px 'Poppins', sans-serif";
        gameCtx.fillStyle = 'orange';
        gameCtx.textAlign = 'center';
        gameCtx.fillText(`길을 찾는 중... ${lbb_relocationCountdown}초`, gameCanvas.width / 2, gameCanvas.height - 20);
    }

    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && lbb_isGameActive) {
        const elapsedTime = Date.now() - lbb_gameStartTime;
        const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
        if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
        const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}


function generateLBBGameBoard() {
    lbb_gameBoard = [];
    const wordPoolSource = gameWordsKor;
    const wordPool = wordPoolSource.filter(word => word.length >= 2 && word.length <= 3);

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        lbb_gameBoard[r] = [];
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const effectRoll = Math.random();
            let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
            if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                const itemRoll = Math.random();
                if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
            }
            lbb_gameBoard[r][c] = {
                word: getRandom(wordPool.length > 0 ? wordPool : wordPoolSource),
                broken: false,
                effect: effectType
            };
        }
    }
}

function getSurroundingLBBBlocks(pos, checkBroken = true) {
    const blocks = [];
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    for (const [dr, dc] of directions) {
        const r = pos.r + dr;
        const c = pos.c + dc;

        if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
            const block = lbb_gameBoard[r][c];
            if (!checkBroken || (block && !block.broken)) {
                blocks.push({ ...block, r, c });
            }
        }
    }
    return blocks;
}

function handleLetterBlockBattleInputSubmit() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
    const typedWord = gameInputField.value.trim();
    if (!typedWord) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);

    const matchedBlock = surroundingBlocks.find(block => {
        if (!block) return false;
        return block.word === typedWord;
    });

    if (matchedBlock) {
        lbb_playerMoveAndBreak(matchedBlock);
        checkLBBBattleCondition();
    } else {
        if (gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    if (gameInputField) gameInputField.value = '';
}

function lbb_playerMoveAndBreak(targetBlock) {
    lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
    const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
    block.broken = true;

    lbb_playerScore += block.effect.score;
    lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
    if (block.effect.effect) {
        lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
    }
}

function lbb_enemyAIAction() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
    if(surroundingBlocks.length > 0) {
        if (lbb_enemyNoPlayableBlocksTimerId) {
            clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
            lbb_enemyNoPlayableBlocksTimerId = null;
        }
        const targetBlock = getRandom(surroundingBlocks);
        lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
        const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
        block.broken = true;
        lbb_enemyScore += block.effect.score;
        lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
        if (block.effect.effect) {
             lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
        }
        checkLBBBattleCondition();
    } else {
        if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
            lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(false);
                lbb_enemyNoPlayableBlocksTimerId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
        }
    }
}

function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
    lbb_gamePausedForEffect = true;
    let popupText = '';

    switch (effect) {
        case 'freezeEnemy':
            if (isPlayer) {
                lbb_isEnemyFrozen = true;
                popupText = `적 정지! ${icon}`;
                if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
            }
            break;
        case 'swapPositions':
            lbb_swapEffect.active = true;
            lbb_swapEffect.step = 0;
            lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
            lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
            lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
            lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
            popupText = `위치 변경! ${icon}`;
            break;
    }

    if (popupText) {
        showGamePopup(popupText, 1500);
    }

    setTimeout(() => {
        if(effect !== 'swapPositions') lbb_gamePausedForEffect = false;
    }, 500);
}

function updateLBBSwapAnimation() {
    if (!lbb_swapEffect.active) return;

    lbb_swapEffect.step++;
    const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

    const playerTarget = lbb_swapEffect.enemyOld;
    const enemyTarget = lbb_swapEffect.playerOld;

    lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
    lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;

    lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
    lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;

    if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
        lbb_swapEffect.active = false;
        lbb_playerPos = { ...playerTarget };
        lbb_enemyPos = { ...enemyTarget };
        lbb_gamePausedForEffect = false;
    }
}
function lbb_triggerBlockBreakEffect(r, c, colorHex) {
    const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
    for (let i = 0; i < 15; i++) {
        lbb_blockBreakParticles.push({
            x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            ...colorRgb,
            alpha: 1
        });
    }
}

function checkLBBBattleCondition() {
    const path = findPath(lbb_playerPos, lbb_enemyPos);
    if (path) {
        lbb_triggerFinalBattleAnimation(path);
    }
}

function findPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([`${start.r},${start.c}`]);

    while (queue.length > 0) {
        const [current, path] = queue.shift();

        if (current.r === end.r && current.c === end.c) {
            return path;
        }

        const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);

        for (const neighbor of neighbors) {
            const posKey = `${neighbor.r},${neighbor.c}`;
            if (!visited.has(posKey)) {
                visited.add(posKey);
                const newPath = [...path, neighbor];
                queue.push([neighbor, newPath]);
            }
        }
    }
    return null;
}

function lbb_triggerFinalBattleAnimation(pathToMeet) {
    if (lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.isActive = true;
    lbb_finalBattleAnimation.step = 0;
    lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
}

function updateLBBFinalBattleAnimation() {
    if (!lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.step++;
    const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;

    const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
    const meetingC = lbb_finalBattleAnimation.meetingPoint.c;

    lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
    lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;

    if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
        lbb_finalBattleAnimation.isActive = false;
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
    }
}

function checkAndTriggerPlayerLBBRelocation() {
    if(lbb_isRelocating) return;
    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    if(surroundingBlocks.length === 0){
        if(!lbb_playerNoPlayableBlocksTimerId) {
            lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
            lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(true);
                lbb_playerNoPlayableBlocksTimerId = null;
                clearInterval(lbb_relocationCountdownIntervalId);
                lbb_relocationCountdownIntervalId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

            lbb_relocationCountdownIntervalId = setInterval(() => {
                lbb_relocationCountdown--;
                if(lbb_relocationCountdown <= 0) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
            }, 1000);
        }
    } else {
        if (lbb_playerNoPlayableBlocksTimerId) {
            clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
        }
        if(lbb_relocationCountdownIntervalId) {
            clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;
        }
        lbb_relocationCountdown = 0;
    }
}
function lbb_initiateRelocation(isPlayerRelocation) {
    if (isPlayerRelocation) {
        lbb_isRelocating = true;
        showGamePopup("길이 막혔습니다! 재배치합니다...", 2000);
        setTimeout(() => lbb_performRelocation(true), 1000);
    } else {
        lbb_performRelocation(false);
    }
}

function lbb_performRelocation(isPlayerRelocation) {
    const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
    const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);

    if(newPos) {
        if(isPlayerRelocation) {
            lbb_playerPos = newPos;
        } else {
            lbb_enemyPos = newPos;
        }
        lbb_gameBoard[newPos.r][newPos.c].broken = true;
    } else {
        handleGameEnd(false, "stuck");
    }
    if (isPlayerRelocation) {
       lbb_isRelocating = false;
    }
}

function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
    const allSpots = [];
    for(let r=0; r<boardRows; r++){
        for(let c=0; c<boardCols; c++){
            if(!lbb_gameBoard[r][c].broken){
                 const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                 if(dist >= minDistanceFromOpponent){
                    allSpots.push({r, c});
                 }
            }
        }
    }
    return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
}


// === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
    if (level) gb_currentLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    }

    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (gb_enemyAttackIntervalId) clearInterval(gb_enemyAttackIntervalId);

    gb_isGameActive = true;
    gb_gamePausedForOverlay = false;
    gb_playerHealth = GB_MAX_PLAYER_HEALTH;
    gb_enemyAttacks = [];
    gb_gameStartTime = Date.now();
    gb_enemyHitEffectTimer = 0;

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    gb_enemyHealth = currentLevelConfig.enemyHealth;

    gb_preferredGameLanguage = 'kor';

    gb_spawnPlayerAttackWord();

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
      setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    gb_enemyAttackIntervalId = setInterval(gb_spawnEnemyAttack, currentLevelConfig.attackInterval);

    startGiantBattleGameLoop();
}

function startGiantBattleGameLoop() {
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    function loop() {
        if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
             cancelAnimationFrame(gb_gameLoopId);
             gb_gameLoopId = null;
             return;
        }
        drawGiantBattleGame();
        if (gb_isGameActive && !gb_gamePausedForOverlay) {
            updateGiantBattleGameLogic();
        }
        gb_gameLoopId = requestAnimationFrame(loop);
    }
    gb_gameLoopId = requestAnimationFrame(loop);
}

function updateGiantBattleGameLogic() {
    if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

    if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
        handleGameEnd(gb_playerHealth > gb_enemyHealth, "timeUp");
        return;
    }

    if (gb_enemyHitEffectTimer > 0) {
        gb_enemyHitEffectTimer -= 1000 / 60;
        if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
    }

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
        const attack = gb_enemyAttacks[i];
        attack.y += currentLevelConfig.attackSpeed;

        const attackObjectHeight = 40;
        const playerHpBarY = gameCanvas.height - 35 - 18;
        const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;


        if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
            gb_enemyAttacks.splice(i, 1);
            gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
            const damageText = attack.isSpecial ? `특별 공격 피격! 🔥` : `피격! 🤕`;
            showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
            if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

            if (gb_playerHealth <= 0) {
                gb_playerHealth = 0;
                handleGameEnd(false, "hp");
                return;
            }
        } else if (attack.y > gameCanvas.height + attackObjectHeight) {
             gb_enemyAttacks.splice(i, 1);
        }
    }

    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
        return;
    }
}

function drawGiantBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let mainTextColor, accentColor, specialAttackColor;
    if (bodyClasses.contains('light-theme')) {
        mainTextColor = '#524a42';
        accentColor = '#b89a6c';
        specialAttackColor = '#b89a6c';
    } else if (bodyClasses.contains('pink-theme')) {
        mainTextColor = '#4F333D';
        accentColor = '#E85D75';
        specialAttackColor = '#E85D75';
    } else {
        mainTextColor = '#e8e0d8';
        accentColor = '#d4af7a';
        specialAttackColor = '#d4af7a';
    }

    function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
        const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();

        gameCtx.fillStyle = bgColor;
        gameCtx.fillRect(x, y, width, height);

        const healthPercentage = Math.max(0, currentHealth) / maxHealth;
        const currentHealthWidth = width * healthPercentage;

        const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, healthColor);
        gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
        gameCtx.fillStyle = gradient;
        gameCtx.fillRect(x, y, currentHealthWidth, height);

        gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
        gameCtx.fillRect(x, y, currentHealthWidth, height / 2);

        if (label) {
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 12px 'Poppins', sans-serif";
            gameCtx.textAlign = textAlign;
            gameCtx.textBaseline = "bottom";
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
            gameCtx.shadowBlur = 0;
        }
    }

    function hexToDarker(hex, percent) {
      let { r, g, b } = hexToRgb(hex);
      r = parseInt(r * (1 - percent));
      g = parseInt(g * (1 - percent));
      b = parseInt(b * (1 - percent));
      return `rgb(${r}, ${g}, ${b})`;
    }

    const topUiY = 30;
    const uiMargin = 15;
    const healthBarHeight = 18;

    const enemyHealthBarWidth = gameCanvas.width * 0.3;
    drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "적 HP", 'right');

    const playerAreaBottomMargin = 50;
    const playerHpBarWidth = gameCanvas.width * 0.3;
    const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
    const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
    drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "플레이어 HP", 'right');

    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = mainTextColor;
    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(`레벨: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

    if (gb_gameStartTime) {
        const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
        const minutes = Math.floor(remainingTime / 60000);
        const seconds = Math.floor((remainingTime % 60000) / 1000);
        gameCtx.font = "bold 14px 'Poppins', sans-serif";
        gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
    }

    const attackWordBoxHeight = 40;
    const attackWordBoxWidth = gameCanvas.width * 0.3;
    const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
    const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20;

    gameCtx.strokeStyle = accentColor;
    gameCtx.lineWidth = 2;
    gameCtx.beginPath();
    gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
    gameCtx.stroke();
    gameCtx.lineWidth = 1;

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.fillStyle = accentColor;
    gameCtx.textAlign = "center";
    gameCtx.textBaseline = "middle";
    gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
    gameCtx.shadowBlur = 2;
    gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);

    gameCtx.font = "bold 24px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
    gameCtx.shadowBlur = 5;
    gameCtx.shadowOffsetX = 1;
    gameCtx.shadowOffsetY = 1;

    for (const attack of gb_enemyAttacks) {
        gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
        if (attack.isSpecial) {
            gameCtx.shadowColor = accentColor;
            gameCtx.shadowBlur = 10;
        } else {
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
        }
        gameCtx.fillText(attack.word, attack.x, attack.y);
    }
    gameCtx.shadowBlur = 0;
    gameCtx.shadowOffsetX = 0;
    gameCtx.shadowOffsetY = 0;
}

function gb_spawnPlayerAttackWord() {
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "공격";
}

function gb_spawnDefenseWord(currentLevelConfig) {
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "수비";
}


function gb_spawnEnemyAttack() {
    if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;

    let word = "";
    let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
    let originalWordForSpecial = "";
    const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);


    if (isSpecialAttack) {
        const specialMinLen = 4;
        const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
        word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || "강타";
        originalWordForSpecial = word;
    } else {
        const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
        word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || "돌격";
    }

    const startY = -20;

    gb_enemyAttacks.push({
        word: word,
        originalWord: isSpecialAttack ? originalWordForSpecial : word,
        x: Math.random() * (gameCanvas.width - 100) + 50,
        y: startY,
        speed: currentLevelConfig.attackSpeed,
        element: 'rock',
        isSpecial: isSpecialAttack
    });
}

function handleGiantBattleInputSubmit() {
    if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
    const typedWordFull = gameInputField.value.trim();
    if (typedWordFull === "") return;

    const typedWord = typedWordFull;

    const playerAttackWordToMatch = gb_playerAttackWord;
    if (typedWord === playerAttackWordToMatch) {
        gb_playerAttack();
        if(gameInputField) gameInputField.value = "";
        return;
    }

    const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
    for (let i = 0; i < sortedEnemyAttacks.length; i++) {
        const enemyAttack = sortedEnemyAttacks[i];
        const enemyWordToMatch = enemyAttack.word;

        if (typedWord === enemyWordToMatch) {
            if (enemyAttack.isSpecial) {
                enemyAttack.isSpecial = false;
                const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                showGamePopup("특수 공격 무력화! 🛡️", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
            } else {
                gb_playerDefend(enemyAttack);
            }
            if(gameInputField) gameInputField.value = "";
            return;
        }
    }

    if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
    setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    if(gameInputField) gameInputField.value = "";
}

function gb_playerAttack() {
    gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
    gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
    showGamePopup(`명중! 💥`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
    gb_spawnPlayerAttackWord();
    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
    }
}

function gb_playerDefend(rock) {
    const index = gb_enemyAttacks.indexOf(rock);
    if (index > -1) {
        gb_enemyAttacks.splice(index, 1);
        showGamePopup("방어! 🛡️", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
    }
}

// --- 공통 게임 함수 (오버레이, 연습모드 복귀 등) ---
function handleGameEnd(playerWins, reason = "") {
    rainfall_isGameActive = false; lbb_isGameActive = false; gb_isGameActive = false;
    rainfall_gamePausedForOverlay = true; lbb_gamePausedForOverlay = true; gb_gamePausedForOverlay = true;
    if (gameInputField) gameInputField.disabled = true;

    if (rainfall_gameLoopId) { cancelAnimationFrame(rainfall_gameLoopId); rainfall_gameLoopId = null; }
    if (lbb_gameLoopId) { cancelAnimationFrame(lbb_gameLoopId); lbb_gameLoopId = null; }
    if (gb_gameLoopId) { cancelAnimationFrame(gb_gameLoopId); gb_gameLoopId = null; }
    if (rainfall_wordGenerationIntervalId) { clearInterval(rainfall_wordGenerationIntervalId); rainfall_wordGenerationIntervalId = null; }
    if (lbb_enemyActionIntervalId) { clearInterval(lbb_enemyActionIntervalId); lbb_enemyActionIntervalId = null; }
    if (gb_enemyAttackIntervalId) { clearInterval(gb_enemyAttackIntervalId); gb_enemyAttackIntervalId = null; }

    let gameConfig, currentLevel, score;
    const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

    if (currentGameType === 'rainfall') {
        gameConfig = { name: '소나기', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
        currentLevel = rainfall_gameLevel;
        score = rainfall_gameScore;
    } else if (currentGameType === 'letterBlockBattle') {
        gameConfig = { name: '블록 배틀', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
        currentLevel = lbb_gameLevel;
        score = lbb_playerScore;
    } else if (currentGameType === 'giantBattle') {
        gameConfig = { name: '타이핑 배틀', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
        currentLevel = gb_currentLevel;
        score = Math.round(gb_playerHealth);
    } else {
        return;
    }

    const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;

    if (reason === 'level_change') {
        showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
        return;
    }

    if (playerWins && currentLevel < gameConfig.maxLevel) {
        const nextLevel = currentLevel + 1;
        const title = `<i class="fas fa-crown"></i> 레벨 ${currentLevel} 클리어!`;
        const body = `잠시 후 다음 레벨(${nextLevel})을 시작합니다...`;

        gameOverlayEl.innerHTML = `<h2>${title}</h2><p>${body}</p>`;
        gameOverlayEl.classList.add('visible');

        setTimeout(() => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = nextLevel;
            updateDropdown(nextLevel);
            showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
        }, 2500);
        return;
    }

    let title, body, nextStepButtonText, nextStepAction;

    if (playerWins) {
        title = `<i class="fas fa-trophy"></i> 모든 레벨 클리어!`;
        if (currentGameType === 'letterBlockBattle') {
            body = `플레이어 점수: ${lbb_playerScore}<br>적 점수: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `플레이어 HP: ${score}<br>적 HP: ${gb_enemyHealth}`;
        } else {
             body = `최종 점수: ${score}`;
        }
        nextStepButtonText = '<i class="fas fa-redo"></i> 처음부터 다시';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            window[gameConfig.levelVarName] = 1;
            updateDropdown(1);
            showCountdownThenStart(gameConfig.initFunc, [true, 1]);
        };
    } else {
        title = `<i class="fas fa-skull-crossbones"></i> 게임 오버`;
        if (reason === 'timeUp' && ( (currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > gb_enemyHealth) )) {
             title = `<i class="far fa-clock"></i> 시간 종료! (판정승)`;
        } else if (reason === 'timeUp') {
            title = `<i class="far fa-clock"></i> 시간 종료!`;
        }

        if (currentGameType === 'letterBlockBattle') {
            body = `플레이어 점수: ${lbb_playerScore}<br>적 점수: ${lbb_enemyScore}`;
        } else if (currentGameType === 'giantBattle') {
            body = `플레이어 HP: ${Math.round(gb_playerHealth)}<br>적 HP: ${Math.round(gb_enemyHealth)}`;
        } else {
            body = `최종 점수: ${score}<br>달성 레벨: ${currentLevel}`;
        }

        nextStepButtonText = '<i class="fas fa-redo"></i> 다시 도전';
        nextStepAction = () => {
            gameOverlayEl.classList.remove('visible');
            const levelToRetry = selectedLevelInDropdown;
            window[gameConfig.levelVarName] = levelToRetry;
            updateDropdown(levelToRetry);
            showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
        };
    }

    gameOverlayEl.innerHTML = `
        <h2>${title}</h2><p>${body}</p>
        <button id="nextStepBtnOverlay" class="game-button">${nextStepButtonText}</button>
        <button id="returnToPracticeOverlayBtn" class="game-button" style="background: var(--text-secondary); border-color: var(--text-secondary);"><i class="fas fa-keyboard"></i> 타자연습 가기</button>`;
    gameOverlayEl.classList.add('visible');
    document.getElementById('nextStepBtnOverlay').addEventListener('click', nextStepAction);
    document.getElementById('returnToPracticeOverlayBtn').addEventListener('click', () => returnToPracticeMode(true));
}


function showCountdownThenStart(startGameFunction, args = [true, 1]) {
    if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';

    let count = 3;
    const countdown = () => {
        const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];

        if (drawFunc) drawFunc();

        if (count > 0) {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 80px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            count--;
            setTimeout(countdown, 1000);
        } else {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 70px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            setTimeout(() => {
                startGameFunction(...args);
            }, 500);
        }
    };
    countdown();
}


function returnToPracticeMode(resetSessionStats = true) {
    cleanupActiveModes();

    const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
    if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
        if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
             originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        }
        if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
            originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
        }
    }
    if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
        gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
        gameToggleSoundBtn = null;
    }

    let lastPracticeMode = 'kor';
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (activePracticeBtn && languageSelectEl) {
        const type = activePracticeBtn.dataset.practiceType;
        const lang = languageSelectEl.value;
        if(type !== 'freestyle' && type !== 'game'){
            lastPracticeMode = (type === 'long') ? `${lang}Long` : lang;
        }
    }

    updateKeyboardDisplay();
    updateKeyboardHighlight();
    startPractice(lastPracticeMode, resetSessionStats);
}
const charToKeyMap = {
    'ㅂ': 'q', 'ㅈ': 'w', 'ㄷ': 'e', 'ㄱ': 'r', 'ㅅ': 't', 'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅔ': 'p',
    'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l',
    'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
    'ㅃ': 'q', 'ㅉ': 'w', 'ㄸ': 'e', 'ㄲ': 'r', 'ㅆ': 't', 'ㅒ': 'o', 'ㅖ': 'p',
    '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
    '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?' : '/'
};

const Hangul = (() => {
    const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
    const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const HANGUL_OFFSET = 0xAC00;

    const disassemble = (str) => {
        return str.split('').map(char => {
            const code = char.charCodeAt(0);
            if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                const uniValue = code - HANGUL_OFFSET;
                const jong = uniValue % 28;
                const jung = Math.floor((uniValue - jong) / 28) % 21;
                const cho = Math.floor(uniValue / (21 * 28));
                
                const result = [CHO[cho]];
                const jungJamo = JUNG[jung];
                
                switch(jungJamo) {
                    case 'ㅘ': result.push('ㅗ', 'ㅏ'); break;
                    case 'ㅙ': result.push('ㅗ', 'ㅐ'); break;
                    case 'ㅚ': result.push('ㅗ', 'ㅣ'); break;
                    case 'ㅝ': result.push('ㅜ', 'ㅓ'); break;
                    case 'ㅞ': result.push('ㅜ', 'ㅔ'); break;
                    case 'ㅟ': result.push('ㅜ', 'ㅣ'); break;
                    case 'ㅢ': result.push('ㅡ', 'ㅣ'); break;
                    default: result.push(jungJamo); break;
                }
                
                if (jong > 0) {
                    const jongJamo = JONG[jong];
                    switch(jongJamo) {
                        case 'ㄳ': result.push('ㄱ', 'ㅅ'); break;
                        case 'ㄵ': result.push('ㄴ', 'ㅈ'); break;
                        case 'ㄶ': result.push('ㄴ', 'ㅎ'); break;
                        case 'ㄺ': result.push('ㄹ', 'ㄱ'); break;
                        case 'ㄻ': result.push('ㄹ', 'ㅁ'); break;
                        case 'ㄼ': result.push('ㄹ', 'ㅂ'); break;
                        case 'ㄽ': result.push('ㄹ', 'ㅅ'); break;
                        case 'ㄾ': result.push('ㄹ', 'ㅌ'); break;
                        case 'ㄿ': result.push('ㄹ', 'ㅍ'); break;
                        case 'ㅀ': result.push('ㄹ', 'ㅎ'); break;
                        case 'ㅄ': result.push('ㅂ', 'ㅅ'); break;
                        default: result.push(jongJamo); break;
                    }
                }
                return result;
            }
            return [char];
        }).flat();
    };
    return { disassemble };
})();

function buildKeyboard() {
    keyboardGuideEl.innerHTML = '';
    const layout = [
        ['q','w','e','r','t','y','u','i','o','p','[',']'],
        ['a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
        ['z','x','c','v','b','n','m',',','.','/'],
        ['ShiftLeft', 'Space','ShiftRight']
    ];
    const keyInfo = {
        'q': { eng: 'Q', kor: 'ㅂ', shiftKor: 'ㅃ' }, 'w': { eng: 'W', kor: 'ㅈ', shiftKor: 'ㅉ' },
        'e': { eng: 'E', kor: 'ㄷ', shiftKor: 'ㄸ' }, 'r': { eng: 'R', kor: 'ㄱ', shiftKor: 'ㄲ' },
        't': { eng: 'T', kor: 'ㅅ', shiftKor: 'ㅆ' }, 'y': { eng: 'Y', kor: 'ㅛ' }, 'u': { eng: 'U', kor: 'ㅕ' },
        'i': { eng: 'I', kor: 'ㅑ' }, 'o': { eng: 'O', kor: 'ㅐ', shiftKor: 'ㅒ' }, 'p': { eng: 'P', kor: 'ㅔ', shiftKor: 'ㅖ' },
        'a': { eng: 'A', kor: 'ㅁ' }, 's': { eng: 'S', kor: 'ㄴ' }, 'd': { eng: 'D', kor: 'ㅇ' },
        'f': { eng: 'F', kor: 'ㄹ' }, 'g': { eng: 'G', kor: 'ㅎ' }, 'h': { eng: 'H', kor: 'ㅗ' },
        'j': { eng: 'J', kor: 'ㅓ' }, 'k': { eng: 'K', kor: 'ㅏ' }, 'l': { eng: 'L', kor: 'ㅣ' },
        'z': { eng: 'Z', kor: 'ㅋ' }, 'x': { eng: 'X', kor: 'ㅌ' }, 'c': { eng: 'C', kor: 'ㅊ' },
        'v': { eng: 'V', kor: 'ㅍ' }, 'b': { eng: 'B', kor: 'ㅠ' }, 'n': { eng: 'N', kor: 'ㅜ' }, 'm': { eng: 'M', kor: 'ㅡ' },
        '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, ';': { base: ';', shift: ':' },
        "'": { base: "'", shift: '"' }, ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' },
        '/': { base: '/', shift: '?' }
    };

    layout.forEach((row, index) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = `keyboard-row row-${index + 1}`;
        
        const keysWrapper = document.createElement('div');
        keysWrapper.className = 'keys-wrapper';

        row.forEach(keyId => {
            const keyDiv = document.createElement('div');
            const dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
            keyDiv.dataset.key = dataKey;
            keyDiv.classList.add('keyboard-key');

            const data = keyInfo[keyId];
            if (data) {
                const engMain = data.base || data.eng.toLowerCase();
                const engShift = data.shift || data.eng.toUpperCase();
                const korMain = data.kor || data.base || '';
                const korShift = data.shiftKor || data.shift || '';
                
                keyDiv.innerHTML = `
                    <div class="key-eng">
                        <span class="key-main-char">${engMain}</span>
                        <span class="key-shift-char">${engShift}</span>
                    </div>
                    <div class="key-kor">
                        <span class="key-main-char">${korMain}</span>
                        <span class="key-shift-char">${korShift}</span>
                    </div>
                `;
            } else {
                 keyDiv.classList.add('special');
                 keyDiv.textContent = keyId.replace(/Left|Right/, '');
            }
             if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId)) {
                keyDiv.classList.add('home-row-base');
            }
            keysWrapper.appendChild(keyDiv);
        });
        rowDiv.appendChild(keysWrapper);
        keyboardGuideEl.appendChild(rowDiv);
    });
}
function updateKeyboardDisplay() {
    if (!keyboardGuideEl) return;
    const isKorMode = currentMode.startsWith('kor');
    
    keyboardGuideEl.className = 'keyboard-guide';
    if (keyboardGuideEnabled) {
        keyboardGuideEl.classList.add('visible');
    }
    keyboardGuideEl.classList.add(isKorMode ? 'lang-kor' : 'lang-eng');
}

function clearKeyboardHighlight() {
    if (!keyboardGuideEl) return;
    const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
    highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
}

function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game' || currentMode === 'freestyle') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();
    
    const isKorMode = currentMode.startsWith('kor');
    let nextCharToPress;

    if (isKorMode) {
        const disassembledTyped = Hangul.disassemble(typingInputField.value);
        if (disassembledTyped.length < disassembledLine.length) {
            nextCharToPress = disassembledLine[disassembledTyped.length];
        }
    } else {
        const originalLine = linesToPractice[currentDisplayLineIndex];
        if (!originalLine) return;
        const typedValue = typingInputField.value;
        if (typedValue.length < originalLine.length) {
            nextCharToPress = originalLine[typedValue.length];
        }
    }
    
    if (!nextCharToPress) return;

    let keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    let isShiftNeeded = false;

    if (isKorMode) {
        if ('ㅃㅉㄸㄲㅆㅒㅖ'.includes(nextCharToPress)) {
            isShiftNeeded = true;
        }
    } else {
        if ( (nextCharToPress >= 'A' && nextCharToPress <= 'Z') || ('~!@#$%^&*()_+{}|:"<>?'.includes(nextCharToPress)) ) {
            isShiftNeeded = true;
        }
    }
    
    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}
</script>

</body>
</html>
