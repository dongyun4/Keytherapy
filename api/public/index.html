<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="8618ed275af69bb1d516d2b1c3cf358ddfa91dd3" />
  <title>도각도각, 마음이 쉬어가는 시간 - Key Therapy</title>
  <meta name="description" content="복잡한 생각은 잠시 내려놓고, 기분 좋은 소리에만 집중하는 시간. 도각거리는 키보드로 나만의 문장을 완성하며 마음의 평온을 되찾아보세요.">
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bagel+Fat+One&family=Cute+Font&family=Do+Hyeon&family=Dokdo&family=East+Sea+Dokdo&family=Gaegu:wght@300;400;700&family=Gamja+Flower&family=Gowun+Dodum&family=Hi+Melody&family=IBM+Plex+Sans+KR:wght@300;400;500&family=Kirang+Haerang&family=Nanum+Brush+Script&family=Nanum+Myeongjo:wght@400;700&family=Nanum+Pen+Script&family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&family=Single+Day&family=Song+Myung&family=Source+Code+Pro:wght@400;500&family=Stylish&family=Yeon+Sung&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* 기존 CSS 스타일은 변경 없이 그대로 유지됩니다. */
.no-transition * {
  transition: none !important;
}
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}
#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}
    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Gowun Dodum', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Gowun Dodum', sans-serif;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ab20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);
      
      --font-size-base: 1.25rem;
      --font-size-base-mobile: 1.15rem;
      --font-scale-multiplier: 1.0;
      --font-size-typing: calc(var(--font-size-base) * var(--font-scale-multiplier));
      --font-size-typing-mobile: calc(var(--font-size-base-mobile) * var(--font-scale-multiplier));
      
      --typing-letter-spacing: 0px;
      --typing-word-spacing: 0px;
      --typing-letter-spacing-mobile: 0px;
      --typing-word-spacing-mobile: 0px;
      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;
      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);
      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);
      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;
    }
        .light-theme {
      /* 전체 배경: 살짝 어두운 크림색으로 차분함 부여 */
      --bg-main: #f8f5f0;
      /* 컨테이너 배경: 깨끗한 아이보리색 */
      --bg-container: #ffffff;
      /* 타이핑 영역 배경: 컨테이너와 미세한 톤 차이 */
      --bg-typing-area: #fbf9f6;
      --bg-progress-bar: #a98b61;
      --bg-progress-bar-track: #e8e2d9;
      
      /* 기본 텍스트: 가독성을 위해 더 진한 세피아 톤으로 */
      --text-primary: #3d3934;
      /* 보조 텍스트: 기본 텍스트와 명확히 구분되는 부드러운 회갈색 */
      --text-secondary: #8a8177;

      /* 강조색: 깊이 있는 올드 골드 색상으로 변경 */
      --accent-primary: #a98b61;
      --accent-secondary: #c5b29a;
      --accent-active: #9a7c55;
      --accent-darker: #896d4a;
      --accent-rgb: 169, 139, 97;
      --accent-primary-rgb: 169, 139, 97;
      
      /* 입력창 관련 색상 조정 */
      --input-bg: #fefdfb;
      --input-text: #3d3934;
      --input-border: #e0d9d0;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.3);
      
      /* 버튼 텍스트 색상 */
      --button-text: #3d3934;
      --button-text-on-accent: #ffffff;

      /* 현재 타이핑 라인 스타일 */
      --current-line-bg: rgba(var(--accent-rgb), 0.07);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 3px 10px rgba(var(--accent-rgb),0.12);
      
      /* 오류 하이라이트: 부드러운 톤으로 변경 */
      --highlight-error: #e57373;
      --highlight-error-bg: rgba(229, 115, 115, 0.1);

      /* 그림자: 새로운 색상 톤에 맞게 조정 */
      --shadow-soft: 0 8px 25px rgba(180, 160, 140, 0.12);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.03);
      --shadow-button: 0 4px 10px rgba(180, 160, 140, 0.1);
      --shadow-button-hover: 0 6px 13px rgba(180, 160, 140, 0.15);
      
      /* 게임 관련 색상은 유지 또는 필요시 조정 */
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
        transition: padding-top 0.4s ease-out;
    }
    body.layout-collapsed .main-content-wrapper {
        padding-top: 23vh;
    }
    body.layout-collapsed.freestyle-mode-active .main-content-wrapper {
    padding-top: 25px;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: center;
        padding-top: 3vh;
    }
    body.focus-mode-active {
        overflow: hidden;
    }
    body.focus-mode-active .main-content-wrapper {
        padding: 0;
        align-items: stretch;
        justify-content: stretch;
    }
    body.focus-mode-active .main-content {
        max-width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    body.focus-mode-active .layout-toggle-container,
    body.focus-mode-active .hero-section,
    body.focus-mode-active .controls-and-stats-wrapper,
    body.focus-mode-active .footer {
        display: none !important;
    }
    body.focus-mode-active #freestyle-area-container {
        height: 100%;
        border-radius: 0;
    }
    .layout-toggle-container {
        width: 100%;
        max-width: 1200px;
        position: relative;
        z-index: 10;
        height: 0;
    }
    #toggleLayoutBtn {
      position: absolute;
      left: 0; 
      transform: translateX(0);
      top: 0;
      padding: 6px 15px;
      font-size: 0.85em;
      border-radius: 0 0 var(--border-radius-small) var(--border-radius-small);
      cursor: pointer;
      font-family: var(--font-ui);
      font-weight: 500;
      border: 1.5px solid transparent;
      border-top: none;
      background: transparent;
      color: var(--text-secondary);
      transition: all 0.2s ease-in-out;
      box-shadow: none;
      opacity: 0.6;
    }
    #toggleLayoutBtn:hover {
        background: var(--bg-container);
        color: var(--accent-primary);
        border-color: var(--input-border);
        opacity: 1;
    }
    #toggleLayoutBtn i {
        margin-right: 7px;
    }
    #result,
    #toggleLayoutBtn {
        transition: opacity 0.4s ease-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }
   .main-content {
  max-width: 1200px;
  width: 100%; background-color: var(--bg-container);
  border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
  display: flex; flex-direction: column;
  border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
  transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out, flex-grow 0.4s ease-out;
}
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }
    .hidden { display: none !important; }
    body.game-mode-active .layout-toggle-container,
    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #freestyle-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.freestyle-mode-active .typing-area-container,
    body.freestyle-mode-active .progress-bar-container,
    body.freestyle-mode-active #game-area-container,
    body.freestyle-mode-active #keyboard-guide.visible {
        display: none !important;
    }
    #freestyle-area-container { display: none; }
    body.freestyle-mode-active #freestyle-area-container { display: flex; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }
    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 10px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s 0.1s, border-width 0.4s, border-radius 0.3s ease, visibility 0.4s;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper {
        padding: 25px 25px 15px;
        max-height: 500px;
        overflow: hidden;
        transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s, visibility 0.4s;
    }
   body.layout-collapsed .hero-section {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
        visibility: hidden;
    }

    /* 
     * [핵심 변경] 
     * .controls-and-stats-wrapper 전체를 숨기는 대신,
     * 그 안의 .settings-container(각종 설정 버튼들)만 숨기도록 변경합니다.
    */
    body.layout-collapsed .settings-container {
        max-height: 0;
        opacity: 0;
        visibility: hidden;
        margin-bottom: 0; /* 설정 영역이 사라지면서 불필요한 여백도 제거합니다. */
        overflow: hidden; /* max-height 애니메이션을 위해 필요합니다. */
    }

    /* 
     * 메뉴가 숨겨졌을 때 wrapper의 상하 패딩을 줄여
     * 통계창이 너무 아래에 위치하지 않도록 조정합니다.
    */
    body.layout-collapsed .controls-and-stats-wrapper {
        padding-top: 15px;
        padding-bottom: 0;
    }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }
    .main-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button.disabled,
    .selection-controls .disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
        background: transparent !important;
        color: var(--text-secondary) !important;
        border-color: var(--input-border) !important;
        box-shadow: none !important;
        transform: none !important;
    }
    .practice-mode-controls,
    .feature-toggles {
        width: 100%;
        justify-content: center;
    }
    .practice-mode-controls button { min-width: 90px; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }
    .selection-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        width: 100%;
    }
    .language-settings, .sound-settings, .theme-settings, .long-text-settings, .font-family-settings {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }
    #languageSelect, #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #languageSelect:focus, #soundPackSelect:focus, #themeSelect:focus, #longTextSelect:focus, #fontFamilySelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 10px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 5px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }
    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #practice-title-display {
    font-family: var(--font-typing);
    font-size: 1.3em;  /* <<< 글씨 크기를 1.1em에서 1.3em으로 키웠습니다. */
    font-weight: 600;  /* <<< 굵기를 조금 더 주어 제목 느낌을 강조했습니다. */
    color: var(--accent-secondary);
    text-align: center;
    margin-top: 0;
    margin-bottom: 12px; /* <<< 제목과 본문 사이의 간격을 조금 더 확보했습니다. */
    padding: 2px 10px;
    min-height: 1.2em;
}
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }
        .typing-line {
        width: 100%; max-width: 800px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing); 
        font-weight: 400;
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.2s ease, color 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        background-color: transparent;
        white-space: pre-wrap;
        text-align: center;
        /* display: flex 와 하위 속성 제거 */
    }
    .typing-line > span {
        display: inline-block; /* text-align: center의 영향을 받도록 */
        text-align: left;
    }
    .whitespace-char {
        color: var(--text-secondary);
        opacity: 0.6;
        user-select: none;
        font-weight: bold;
    }
    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }
    .typing-line strong {
        color: var(--current-line-typed-text);
    }
    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }
    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; 
        font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }
    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }
    #typing-input-field-container {
        width: 100%;
        max-width: 800px;
        margin: 2px auto 0 auto;
        position: relative;
    }
    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }
    .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;
        box-sizing: border-box;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        line-height: var(--line-height-typing);
        font-weight: 400;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        width: 100%;
        text-align: left;
        /* display: flex 와 하위 속성 제거 */
    }
    .fake-input-field > span {
        text-align: left;
        white-space: pre-wrap;
    }
    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }
    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }
    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-typing) * 1.2);
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: text-bottom;
        margin-left: -1px;
    }
    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }
    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
        .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    .footer .contact-info { margin-top: 10px; }
    #copyEmailBtn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.9em;
      padding: 2px 6px;
      vertical-align: middle;
      transition: color 0.2s ease-in-out;
    }
    #copyEmailBtn:hover {
      color: var(--accent-primary);
    }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}
    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }
    #returnToPracticeBtnGame {
      padding: 12px 24px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 600;
      font-size: 0.95em;
      color: var(--accent-primary);
      border: 2px solid rgba(var(--accent-rgb), 0.4);
      background-color: transparent;
      transition: all 0.25s ease;
      box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
    }
    #returnToPracticeBtnGame:hover {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-active);
      box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
    }
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }
    #gameToggleSoundBtn {
      padding: 10px 16px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 500;
      font-size: 0.9em;
      border: 1.5px solid var(--accent-secondary);
      background-color: transparent;
      color: var(--accent-secondary);
      transition: all 0.25s ease;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: var(--shadow-button);
    }
    #gameToggleSoundBtn.active {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
      font-weight: 600;
    }
    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        .game-overlay {
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .result-card {
        background-color: var(--bg-container);
        padding: 25px 35px;
        border-radius: var(--border-radius-main);
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        max-width: 500px;
        width: 90%;
    }
    .result-card h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin: 0 0 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .result-card-stats {
    display: flex; /* [수정] Grid 대신 Flexbox를 사용하여 유연한 정렬을 구현합니다. */
    flex-wrap: wrap; /* 공간이 부족하면 자동으로 줄바꿈 처리합니다. */
    justify-content: space-around; /* 항목들을 수평으로 균등하게 분배합니다. */
    gap: 10px 15px; /* 세로/가로 간격 */
    margin-bottom: 25px;
}
.result-card-stats .stat-item {
    font-size: 1.1em;
    text-align: center; /* [추가] 각 항목의 텍스트를 중앙 정렬합니다. */
    flex-grow: 1; /* [추가] 항목들이 가용한 공간을 채우도록 합니다. */
    min-width: 140px; /* [추가] 항목이 너무 좁아지는 것을 방지합니다. */
}
    .result-card-stats .stat-item .label {
        color: var(--text-secondary);
        font-size: 0.9em;
        margin-right: 8px;
    }
     .result-card-stats .stat-item .value {
        color: var(--text-primary);
        font-weight: 600;
        font-family: var(--font-ui);
    }
    .result-card .result-buttons {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }
    .light-theme .result-card h2, .pink-theme .result-card h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 0;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button.secondary {
        background: transparent;
        color: var(--accent-secondary);
        border-color: var(--accent-secondary);
    }
    .game-button.secondary:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-secondary);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    #gameHelpBtn {
        position: absolute;
        top: 15px;
        left: 15px;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background-color: rgba(var(--bg-main-rgb, 32, 30, 28), 0.7);
        color: var(--text-secondary);
        border: 1px solid var(--input-border);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.1em;
        z-index: 20;
        transition: all 0.2s ease;
    }
    #gameHelpBtn:hover {
        background-color: var(--accent-primary);
        color: var(--button-text-on-accent);
    }
    .light-theme #gameHelpBtn {
        background-color: rgba(var(--bg-main-rgb, 253, 250, 246), 0.8);
    }
    #helpModal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s, visibility 0s 0.3s;
    }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        #helpModal {
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
    }
    #helpModal.visible {
        opacity: 1; visibility: visible;
        transition: opacity 0.3s, visibility 0s 0s;
    }
    .help-modal-content {
        background-color: var(--bg-container);
        padding: 30px;
        border-radius: var(--border-radius-main);
        max-width: 500px;
        width: 90%;
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        position: relative;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    #helpModal.visible .help-modal-content {
        transform: scale(1);
    }
    .help-modal-close {
        position: absolute;
        top: 15px; right: 15px;
        font-size: 1.5em;
        color: var(--text-secondary);
        cursor: pointer;
        transition: color 0.2s;
    }
    .help-modal-close:hover {
        color: var(--accent-primary);
    }
    .help-modal-content h2 {
        font-family: var(--font-heading);
        color: var(--accent-primary);
        margin-top: 0;
        margin-bottom: 15px;
    }
    .help-modal-content p, .help-modal-content div {
        color: var(--text-secondary);
        line-height: 1.7;
    }
     .help-modal-content .item-info {
        font-size: 0.9em; margin-top: 15px;
    }
    .help-modal-content .item-info div { margin-bottom: 5px; }
    
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}
      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .language-settings,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings,
      body:not(.game-mode-active) .long-text-settings,
      body:not(.game-mode-active) .font-family-settings { width: 100%; justify-content: center; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }
      .typing-line,
      .fake-input-field,
      #freestyle-input-area {
          font-size: var(--font-size-typing-mobile);
          letter-spacing: var(--typing-letter-spacing-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-typing-mobile) * 1.2); }
      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .result-card h2 { font-size: 1.6em; }
      .result-card-stats { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .language-settings, .sound-settings, .theme-settings, .long-text-settings, .font-family-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }
    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .select-label { font-size: 0.85em; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line,
      .fake-input-field,
      #freestyle-input-area {
          font-size: var(--font-size-typing-mobile);
      }
      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .result-card h2 { font-size: 1.4em; }
      .result-card-stats { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }
.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}
.hero-section a:hover {
  transform: scale(1.03);
}
.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}
.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}
.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}
.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}
#keyboard-guide {
    display: none;
    margin-bottom: 25px;
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 900px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}
.keys-wrapper {
    display: flex;
    width: fit-content;
}
.row-1 .keys-wrapper, .row-2 .keys-wrapper, .row-3 .keys-wrapper, .row-4 .keys-wrapper {
    transform: translateX(0);
}
.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
    min-width: 50px;
}
.keyboard-key .key-main-char {
    font-weight: 500;
    font-size: 1.1em;
    color: var(--text-primary);
    margin-top: auto;
    margin-bottom: auto;
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
    align-self: flex-start;
    padding-left: 2px;
}
#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor,
#keyboard-guide.lang-js .key-kor,
#keyboard-guide.lang-python .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char,
#keyboard-guide.lang-js .key-eng .key-main-char,
#keyboard-guide.lang-python .key-eng .key-main-char { 
    font-size: 1.2em; 
}
.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.18);
}
.light-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.15);
}
.pink-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.12);
}
.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}
.light-theme .keyboard-key.highlight-key,
.pink-theme .keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
}
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}
.keyboard-key.special-key {
    font-size: 0.8em;
    font-weight: 400;
    text-align: center;
    line-height: 50px;
}
.key-width-1-5x { min-width: 80px; }
.key-width-1-75x { min-width: 95px; }
.key-width-2x { min-width: 110px; }
.key-width-2-25x { min-width: 125px; }
.key-width-2-5x { min-width: 135px; }
.key-width-space { min-width: 332px; flex-grow: 1; }
#freestyle-area-container {
    padding: 20px 25px 28px;
    background-color: var(--bg-typing-area);
    border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    flex-grow: 1;
    display: none;
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
    min-height: 400px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
}

body.layout-collapsed.freestyle-mode-active #freestyle-area-container {
    margin-top: 40px;
}

body.layout-collapsed.freestyle-mode-active .main-content {
    flex-grow: 1;
}

#freestyle-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    position: relative;
    align-items: center;
}
.freestyle-tool-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.toolbar-divider {
    width: 1px;
    height: 20px;
    background-color: var(--input-border);
    margin: 0 4px;
}
.freestyle-tool-btn {
    background-color: var(--input-bg);
    color: var(--text-secondary);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 8px 12px;
    font-family: var(--font-ui);
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.freestyle-tool-btn:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
    border-color: var(--accent-secondary);
}
.freestyle-tool-btn i {
    margin-right: 6px;
    width: 14px;
    text-align: center;
}
#focusModeBtn { margin-left: auto; }
#emoji-picker {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    transform: translateY(5px);
    background-color: var(--bg-container);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    padding: 10px;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    z-index: 10;
}
#emoji-picker.visible {
    display: grid;
}
#emoji-picker span {
    font-size: 1.4em;
    cursor: pointer;
    text-align: center;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
#emoji-picker span:hover {
    background-color: var(--bg-main);
}
#freestyle-input-area {
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 15px;
    font-family: var(--font-typing);
    font-size: var(--font-size-typing);
    line-height: var(--line-height-typing);
    letter-spacing: var(--typing-letter-spacing);
    word-spacing: var(--typing-word-spacing);
    font-synthesis: none;
    font-kerning: normal;
    text-rendering: optimizeLegibility;
    resize: both;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    box-sizing: border-box;
}
#freestyle-input-area:focus {
    outline: none;
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#freestyle-input-area::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
    transition: opacity 0.3s;
}
#freestyle-input-area:focus::placeholder {
    opacity: 0.3;
}
#freestyle-stats-bar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 15px;
    padding: 8px 5px;
    font-size: 0.85em;
    color: var(--text-secondary);
    font-family: var(--font-ui);
}
.freestyle-download-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin-top: 15px;
}
#freestyle-filename-input {
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 10px 12px;
    font-family: var(--font-ui);
    font-size: 0.9em;
    outline: none;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    width: 200px;
}
#freestyle-filename-input:focus {
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#download-freestyle-btn {
    padding: 10px 20px;
    font-size: 0.9em;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    border: 1.5px solid var(--accent-primary);
    background: var(--accent-primary);
    color: var(--button-text-on-accent);
    box-shadow: var(--shadow-button);
    transition: all 0.2s ease;
}
#download-freestyle-btn:hover {
    background: var(--accent-active);
    border-color: var(--accent-active);
    transform: translateY(-1px);
    box-shadow: var(--shadow-button-hover);
}
#download-freestyle-btn i {
    margin-right: 8px;
}
#shortcut-help-container {
    position: fixed;
    bottom: 25px;
    right: 25px;
    z-index: 1000;
    font-size: 1.6em;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s ease;
}
#shortcut-help-container:hover {
    color: var(--accent-primary);
}
#shortcut-help-container:hover .shortcut-tooltip {
    opacity: 1;
    visibility: visible;
    transform: translate(-5px, -5px);
}
.shortcut-tooltip {
    position: absolute;
    bottom: 110%;
    right: 110%;
    background-color: var(--bg-container);
    color: var(--text-secondary);
    padding: 15px 20px;
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    font-size: 0.55em;
    line-height: 1.7;
    width: 210px;
    opacity: 0;
    visibility: hidden;
    transform: translate(0, 0);
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
    border: 1px solid var(--input-border);
}
.shortcut-tooltip.show-temporarily {
    opacity: 1;
    visibility: visible;
    transform: translate(-5px, -5px);
}
.shortcut-tooltip strong {
    color: var(--accent-primary);
    font-size: 1.15em;
    font-weight: 600;
    display: block;
    margin-bottom: 10px;
    text-align: center;
}
.shortcut-tooltip p {
    margin: 0 0 8px 0;
}
.shortcut-tooltip p:last-child {
    margin-bottom: 0;
}
.shortcut-tooltip b {
    color: var(--text-primary);
    background-color: var(--bg-main);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--input-border);
    margin-right: 8px;
    font-family: var(--font-typing);
}
.shortcut-tooltip p {
    display: flex;
    align-items: center;
}
.shortcut-tooltip span {
    white-space: nowrap; /* 줄바꿈 방지 */
}
@media (max-width: 920px) {
    #keyboard-guide { max-width: 100%; }
    .keyboard-key { min-width: 42px; margin: 0 3px;}
    .key-width-1-5x { min-width: 68px; }
    .key-width-1-75x { min-width: 78px; }
    .key-width-2x { min-width: 88px; }
    .key-width-2-25x { min-width: 108px; }
    .key-width-2-5x { min-width: 118px; }
    .key-width-space { min-width: 278px; }
}
@media (max-width: 480px) {
    #freestyle-download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    #freestyle-filename-input, #download-freestyle-btn {
        width: 100%;
        box-sizing: border-box;
    }
    #freestyle-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    .freestyle-tool-group {
        justify-content: space-around;
    }
    #focusModeBtn { margin-left: 0; }
}

</style>
</head>
<body class="">
  <div class="main-content-wrapper">
    <div class="layout-toggle-container">
        <button id="toggleLayoutBtn"><i class="fas fa-chevron-up"></i> 메뉴 숨기기</button>
    </div>
    <div class="main-content">
      <div class="hero-section">
          <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
              <h1 class="hero-title">Key Therapy</h1>
              <p class="hero-tagline">깊은 수면과 집중을 위한<br>🎧키보드 타건 ASMR🎧</p>
          </a>
      </div>
      <div class="controls-and-stats-wrapper">
        <div class="settings-container">
            <div class="main-controls">
                <div class="practice-mode-controls control-button-group">
                    <button data-practice-type="short"><i class="fas fa-language"></i> 단문 연습</button>
                    <button data-practice-type="long"><i class="fas fa-align-left"></i> 장문 연습</button>
                    <button data-practice-type="freestyle"><i class="fas fa-pencil-alt"></i> 글쓰기</button>
                    <button id="gameModeBtn"><i class="fas fa-gamepad"></i> 게임하기</button>
                </div>
                <div class="feature-toggles control-button-group">
                    <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                    <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                    <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
                    <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> 자리연습 OFF</button>
                </div>
                <div class="selection-controls">
                    <div class="language-settings">
                        <label for="languageSelect" class="select-label" id="languageSelectLabel">언어:</label>
                        <select id="languageSelect">
                            <option value="kor">한글</option>
                            <option value="eng">영어</option>
                            <option value="js">JavaScript</option>
                            <option value="python">Python</option>
                        </select>
                    </div>
                    <div class="long-text-settings hidden" id="longTextSelectContainer">
                        <label for="longTextSelect" class="select-label">글 선택:</label>
                        <select id="longTextSelect"></select>
                    </div>
                    <div class="sound-settings" id="soundSettingsElement">
                        <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                        <select id="soundPackSelect"></select>
                    </div>
                    <div class="theme-settings" id="themeSettingsElement">
                        <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                        <select id="themeSelect">
                            <option value="dark">다크</option>
                            <option value="light">아이보리</option>
                            <option value="pink">핑크</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div id="stats">
            <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
            <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
            <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
            <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
        </div>
      </div>
      <div class="progress-bar-container">
          <div class="progress-bar"></div>
      </div>
      <div class="typing-area-container">
          <div id="keyboard-guide"></div>
          <h3 id="practice-title-display"></h3>
          <div id="line-display-area"> </div>
          <div id="typing-input-field-container">
              <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
              <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
          </div>
          <div id="upcoming-lines-area"> </div>
      </div>
      <div id="freestyle-area-container">
          <div id="freestyle-toolbar">
              <div class="freestyle-tool-group">
                  <button id="insertDateBtn" class="freestyle-tool-btn" title="오늘 날짜 삽입"><i class="fas fa-calendar-alt"></i></button>
                  <button id="insertTimeBtn" class="freestyle-tool-btn" title="현재 시간 삽입"><i class="fas fa-clock"></i></button>
                  <button id="emojiBtn" class="freestyle-tool-btn" title="이모티콘"><i class="far fa-smile"></i></button>
                   <div id="emoji-picker">
                      <span>😊</span><span>😂</span><span>😍</span><span>🤔</span><span>👍</span><span>❤️</span>
                      <span>🎉</span><span>✨</span><span>🔥</span><span>😭</span><span>🙏</span><span>⭐</span>
                  </div>
              </div>
              <div class="toolbar-divider"></div>
              <div class="freestyle-tool-group">
                  <button id="copyAllBtn" class="freestyle-tool-btn" title="전체 내용 복사"><i class="far fa-copy"></i></button>
                  <button id="clearAllBtn" class="freestyle-tool-btn" title="전체 삭제"><i class="fas fa-trash-alt"></i></button>
                  <button id="insertHrBtn" class="freestyle-tool-btn" title="구분선 삽입"><i class="fas fa-minus"></i></button>
              </div>
          </div>
          <textarea id="freestyle-input-area" placeholder="오늘 하루는 어땠나요? 당신의 이야기를 자유롭게 기록해보세요..."></textarea>
          <div id="freestyle-stats-bar">
              <span id="charCount">0자</span>
              <span id="wordCount">0단어</span>
          </div>
          <div class="freestyle-download-controls">
              <input type="text" id="freestyle-filename-input" placeholder="파일 이름 (선택사항)">
              <button id="download-freestyle-btn"><i class="fas fa-download"></i> 텍스트 파일로 저장</button>
          </div>
      </div>
      <div id="game-area-container">
      </div>
      <div id="result"></div>
    </div>
  </div>
  <div class="footer"> 
    <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> 
    <p class="contact-info">
      문의: <a href="mailto:keytherapy@naver.com">keytherapy@naver.com</a>
      <button id="copyEmailBtn" title="이메일 주소 복사"><i class="far fa-copy"></i></button>
    </p>
  </div>

  <div id="helpModal">
    <div class="help-modal-content">
      <span class="help-modal-close">×</span>
      <div id="helpModalBody"></div>
    </div>
  </div>

  <div id="result-share-popup" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--accent-active); color: var(--button-text-on-accent); padding: 12px 20px; border-radius: var(--border-radius-small); z-index: 1001; box-shadow: var(--shadow-soft); opacity: 0; transition: opacity 0.3s, transform 0.3s; pointer-events: none;">
      결과가 클립보드에 복사되었습니다!
  </div>

      <!-- 수정된 코드 -->
<div id="shortcut-help-container">
    <div class="shortcut-tooltip">
        <strong>단축키 안내</strong><br>
        <p><b>Esc</b><span>: 메뉴 숨기기/펼치기</span></p>
        <p><b>Alt + ↓</b><span>: 다시 시작</span></p>
        <p><b>Alt + →</b><span>: 다음 글</span></p>
        <p><b>Alt + ←</b><span>: 이전 글</span></p>
        <p><b>Alt + '</b><span>: 다음 타건음</span></p>
        <p><b>Alt + ;</b><span>: 이전 타건음</span></p>
        <p><b>Alt + M</b><span>: 타건음 ON/OFF</span></p>
        <p><b>Alt + ,</b><span>: 오타체크 ON/OFF</span></p>
        <p><b>Alt + .</b><span>: 측정 ON/OFF</span></p>
        <p><b>Alt + /</b><span>: 자리연습 ON/OFF</span></p>
    </div>
    <i class="fas fa-question-circle"></i>
</div>

<script>
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = [];

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;
let layoutCollapsed = false;
let autoCompleteEnabled = true; 
let isProgrammaticallyChangingInput = false;
let isComposingNow = false;
let freestyleStatsInterval = null;
let freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl;
let freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker;
let copyAllBtn, clearAllBtn, insertHrBtn;
let charCountEl, wordCountEl;
let longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl;

let languageSelectEl, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, toggleLayoutBtn;
let languageSelectLabelEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameStartMessageEl, itemEffectPopupEl;
let gameHelpBtn, helpModal, helpModalBody, helpModalClose;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;

const fontConfig = {
    "'Noto Sans KR', sans-serif": { scale: 1.0 },
    "'Gowun Dodum', sans-serif": { scale: 1.05 },
    "'IBM Plex Sans KR', sans-serif": { scale: 1.0 },
    "'Do Hyeon', sans-serif": { scale: 1.0 },
    "'Stylish', sans-serif": { scale: 1.1 },
    "'Nanum Myeongjo', serif": { scale: 1.0 },
    "'Song Myung', serif": { scale: 1.0 },
    "'Yeon Sung', cursive": { scale: 1.0 },
    "'Gaegu', cursive": { scale: 1.2 },
    "'Nanum Pen Script', cursive": { scale: 1.3 },
    "'Hi Melody', cursive": { scale: 1.15 },
    "'Gamja Flower', cursive": { scale: 1.2 },
    "'Cute Font', cursive": { scale: 1.15 },
    "'Single Day', cursive": { scale: 1.1 },
    "'Nanum Brush Script', cursive": { scale: 1.1 },
    "'East Sea Dokdo', cursive": { scale: 1.3 },
    "'Dokdo', cursive": { scale: 1.3 },
    "'Source Code Pro', monospace": { scale: 1.1 },
    "'Courier New', monospace": { scale: 1.1 }
};

let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;
let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;
let gameOverlayEl;

function showShortcutTooltipTemporarily() {
    const tooltip = document.querySelector('.shortcut-tooltip');
    if (!tooltip) return;

    tooltip.classList.add('show-temporarily');
    setTimeout(() => {
        tooltip.classList.remove('show-temporarily');
    }, 2000);
}

let soundPlayedForThisInput = false;
let currentSoundPack = '1';
const soundFiles = {};
const totalSoundPacks = 13;
const filesPerPack = 10;

for (let i = 1; i <= totalSoundPacks; i++) {
    const packKey = String(i);
    soundFiles[packKey] = [];
    for (let j = 1; j <= filesPerPack; j++) {
        soundFiles[packKey].push(`soundFiles/${i}/${i} (${j}).wav`);
    }
}

let audioPool = {};
let soundTimer = null;

let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: '시간', icon: '⏱️' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: '소멸', icon: '💨' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: '생명', icon: '❤️' }
};
const rainfall_gameMainLevelsConfig = [
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];
let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };
let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;
const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';
let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;
const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '⭐' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: '🔥' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '❄️' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '↔️' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;
let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
let gb_isGameActive = false;
let countdownTimerId = null;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000; // 2분
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;
const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "황사", "일기", "예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "보드카", "데킬라", "하이볼", "탄산수",
    "비행기", "기차", "버스", "택시", "자전거", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신", "우주인", "방울뱀", "사막여우",
    "가로등", "가위질", "가정교사", "가족사진", "키테라피", "갈림길", "걸림돌", "감사패", "감정표현", "강강술래", "개발자", "거북선", "건강검진", "건널목", "검정고시", "결혼기념", "경기장", "경찰관", "경호원", "계란후라이", "고속도로", "고인돌", "골목대장", "공기놀이", "공중전화", "공휴일", "과일가게", "과학상자", "관광버스", "광화문", "구급상자", "국회의원", "군고구마", "그림일기", "극장", "기념품", "기상캐스터", "기차여행", "긴급상황", "김장독", "까마귀", "까치밥", "꽃다발", "꿀벌", "꿈나라", "끝말잇기", "나무늘보", "나비넥타이", "낙하산", "낚시꾼", "난센스퀴즈", "날개", "남대문", "낭떠러지", "내비게이션", "냉장고", "네잎클로버", "노랫소리", "노트북", "놀이공원", "농구공", "눈사람", "다리미", "다람쥐", "다이아몬드", "단풍잎", "달리기", "닭꼬치", "담벼락", "당근", "대통령", "대한민국", "도서관", "독수리", "돈가스", "돌고래", "동물원", "두부", "두통약", "드라이기", "등산화", "디지털카메라", "라면", "라디오", "로봇", "리모컨", "마라톤", "마법사", "만두", "만리장성"
].map(word => word.trim());
const sentencePool = {
    kor: [
    "참 따뜻한 날이었다. 너와 함께여서였을지 모른다.",
    "엄마, 사랑해. 그 한마디가 왜 그리도 어려웠을까.",
    "지나고 나서야 알았다. 그때가 내 인생의 봄이었음을.",
    "네 생각을 하다 보면, 어느새 입가에 미소가 번져 있다.",
    "오늘 하루도 고생 많았지? 아무도 몰라줘도 나는 안다.",
    "왜 내 뜻대로 되는 게 하나도 없는지, 사는 게 참 쉽지가 않네.",
    "우산 챙겨가. 비 맞고 다니면 속상하니까.",
    "사는 게 다 그렇지 뭐. 다들 아픔 하나쯤은 안고 살아간다.",
    "텅 빈 놀이터 그네가 바람에 혼자 흔들렸다. 나처럼.",
    "오래된 일기장 속, 삐뚤빼뚤한 글씨가 울고 있었다.",
    "아빠의 구부정한 뒷모습에서 내가 살아온 세월을 보았다.",
    "잘 지내냐는 흔한 안부조차, 목구멍에 걸려 나오질 않았다.",
    "괜찮아, 다 괜찮아. 주문을 외워보지만 마음은 따라주질 않는다.",
    "창밖엔 비가 내린다. 유난히 네가 보고 싶은 날이다.",
    "어른이 되면 모든 게 쉬울 줄 알았다. 더 어려울 뿐인데.",
    "이유 없이 눈물이 났다. 마음이 보내는 작은 신호였다.",
    "그때 한 번 더 안아줄걸. 그게 마지막일 줄은 몰랐네.",
    "오늘따라 엄마가 해준 따뜻한 밥이 먹고 싶다.",
    "다들 잘만 사는 것 같은데, 왜 나만 이렇게 뒤처지는 기분일까.",
    "전화기를 들었다 놨다. 너의 목소리가 듣고 싶은 밤이다.",
    "거울 속 낯선 얼굴에게 물었다. 너는 지금 행복하니?",
    "애써 웃어 보였다. 울고 있는 걸 들키고 싶지 않아서.",
    "뽀드득, 뽀드득. 흰 눈 위에 첫 발자국을 새기며 걸었다.",
    "할머니의 주름진 손이 내 손을 잡았다. 세상 가장 따뜻했다.",
    "잊었다고 생각했는데, 문득 스친 향기에 심장이 내려앉았다.",
    "가끔은 모든 걸 멈추고 그냥 멍하니 하늘만 보고 싶다.",
    "오늘 저녁은 유난히 달이 밝네. 너도 이 달을 보고 있을까.",
    "친구야, 그냥 울어. 내가 옆에서 같이 있어 줄게.",
    "마음에도 지우개가 있다면, 너에 대한 기억부터 지우고 싶다.",
    "열심히 살았는데, 손에 남은 건 아무것도 없는 것 같다.",
    "별거 아닌 말에 상처받는 걸 보니, 나도 많이 지쳤나 보다.",
    "익숙한 골목길 모퉁이, 우리의 웃음소리가 들리는 듯했다.",
    "너무 애쓰지 않아도 돼. 지금 이대로도 충분히 괜찮아.",
    "밤하늘의 별을 헤다 잠든다. 내일은 조금 더 나은 날이기를.",
    "갓 구운 빵 냄새가 났다. 문득 어릴 적 동네가 그리워졌다.",
    "마지막으로 떠나던 네 뒷모습이 자꾸만 눈앞에 아른거린다.",
    "한참을 울고 나니, 오히려 마음이 조금은 편안해졌다.",
    "오늘 하루, 나 자신을 꼭 안아주자. 정말 수고 많았다고.",
    "빗소리를 들으면 마음이 차분해진다. 내 눈물 같아서일까.",
    "시간이 약이라는 말, 어떤 상처에는 해당되지 않는 것 같다.",
    "가끔은 네가 너무 미운데, 그래도 보고 싶은 건 어쩔 수 없다.",
    "'나중에'라는 말로 미뤄뒀던 일들이 후회로 남았다.",
    "불 꺼진 방 안에 홀로 앉아, 창밖 불빛을 세어보았다.",
    "아무 말 없이 건넨 따뜻한 커피 한 잔에, 얼었던 마음이 녹았다.",
    "나이를 먹는다는 건, 포기해야 할 것들이 늘어나는 거구나.",
    "오늘따라 유난히 외롭다. 누군가 내 이름을 불러줬으면.",
    "그때 왜 그랬냐고 묻고 싶지만, 이젠 그럴 수조차 없다.",
    "퇴근길 지하철 창문에 비친 내 얼굴이 참 지쳐 보였다.",
    "네가 좋아하던 노래가 라디오에서 나왔다. 하마터면 울 뻔했다.",
    "아무 일 없는 평범한 하루가, 얼마나 큰 행복인지 이제야 안다.",
    "말없이 등을 토닥여주던 그 손길을 잊을 수가 없다.",
    "행복은 멀리 있지 않다던데, 내 행복은 대체 어디쯤 있을까.",
    "밤이 깊어질수록 그리움도 짙어진다. 이건 어쩔 수가 없다.",
    "서툰 위로보다, 함께 침묵해 주는 것이 더 큰 힘이 될 때가 있다.",
    "어릴 적 꿈은 우주비행사였는데. 지금은 그냥 잘 살고 싶다.",
    "네가 떠난 빈자리가, 생각보다 훨씬 크고 시리다.",
    "가끔은 나도 나를 잘 모르겠다. 진짜 원하는 게 뭔지.",
    "한 걸음만 더 가면 될 것 같은데, 그 한 걸음이 내딛기 힘들다.",
    "묵묵히 흐르는 강물을 보며, 내 마음도 흘려보내고 싶었다.",
    "오늘 본 하늘은 꼭 너의 눈동자 색을 닮았더라.",
    "다음에 밥 한번 먹자는 인사가 제일 서글프게 들릴 때가 있다.",
    "늦은 밤 엄마의 기침 소리에, 가슴 한쪽이 철렁 내려앉았다.",
    "먼 훗날, 오늘을 떠올리며 웃을 수 있는 날이 오겠지?",
    "너와의 추억이 담긴 상자를 열었다. 먼지가 쌓여 있었다.",
    "바보같이, 아직도 네 전화번호를 지우지 못했다.",
    "힘들면 잠시 쉬어가. 아무도 너를 탓하지 않아.",
    "어릴 적 사진 속의 나는, 무엇이 그리 즐거웠을까.",
    "차가운 도시의 밤, 따뜻한 어묵 국물이 생각났다.",
    "마음이 텅 빈 것 같다. 무엇으로도 채워지지가 않는다.",
    "네가 웃으면 나도 따라 웃게 돼. 이건 정말 어쩔 수 없나 봐.",
    "떠나간 버스는 기다리는 게 아니랬다. 사람도 마찬가지겠지.",
    "무심코 넘긴 책 한 구절에, 내 이야기 같아 한참을 머물렀다.",
    "오늘도 수고했어. 그 말 한마디가 듣고 싶은 날이었다.",
    "옛날 노래를 들으면, 그 시절의 공기까지 함께 떠오른다.",
    "상처는 아물지만, 흉터는 남는다. 가끔씩 시큰거린다.",
    "가장 빛나는 별은, 가장 어두운 밤에만 볼 수 있다더라.",
    "모두가 잠든 새벽, 홀로 깨어있는 이 시간이 가장 나답다.",
    "첫눈 오는 날 만나자던 약속, 너는 기억하고 있을까.",
    "사는 게 버거울 땐, 잠시 하늘을 봐. 생각보다 넓고 푸르니까.",
    "아무것도 하고 싶지 않은 날. 그냥 이불 속에만 있고 싶다.",
    "오래된 친구와의 통화에, 잊고 있던 내 모습을 되찾았다.",
    "너는 내 세상의 전부였는데, 너는 지금 어떤 세상을 살고 있니.",
    "결국 모든 것은 지나간다. 이 아픔도 언젠가는 지나가겠지.",
    "잘못한 게 없는데 자꾸 작아지는 기분, 정말 싫다.",
    "창가에 스며드는 아침 햇살에, 어젯밤의 눈물을 말린다.",
    "좋은 사람이 되고 싶었는데, 점점 더 못난이가 되어가는 것 같다.",
    "비에 젖은 흙냄새가 좋다. 왠지 모를 위로를 받는 기분이다.",
    "너의 행복을 빌어줄게. 진심이지만, 조금은 아프다.",
    "가끔은 길을 잃어야, 새로운 풍경을 만날 수 있다.",
    "아빠의 무뚝뚝한 칭찬 한마디에, 어린애처럼 기분이 좋았다.",
    "마음의 문을 너무 오래 닫아뒀나. 여는 법을 잊어버렸다.",
    "오늘 밤, 꿈에서라도 너를 만날 수 있었으면 좋겠다.",
    "혼자 마시는 술이 늘었다. 털어놓을 곳이 없어서겠지.",
    "바람이 참 시원하다. 내 복잡한 마음도 씻어주면 좋을 텐데.",
    "너 없는 사계절은, 색깔 없는 풍경화 같았다.",
    "힘내라는 말보다 '힘들지?'라는 말이 더 위로가 될 때가 있다.",
    "내가 나를 사랑해 줘야 하는데, 그게 제일 어려운 것 같다.",
    "해 질 녘 노을을 보면, 왠지 모르게 눈물이 날 것 같다.",
    "잊혀진다는 건, 어떤 기분일까. 문득 두려워졌다.",
    "다시 태어난다면, 너를 만나지 않을 수 있을까.",
    "텅 빈 내 방에, 네 웃음소리가 울려 퍼지는 것 같았다.",
    "열심히 달려왔는데, 여기가 어디인지 모르겠다.",
    "오늘 하루, 딱 한 번만이라도 진심으로 웃고 싶다.",
    "오래된 가로등 아래, 내 그림자만이 외롭게 서 있었다.",
    "진심은 통한다지만, 때로는 그 진심이 오해를 낳기도 한다.",
    "너와의 마지막 대화, 마침표를 찍지 못해 여전히 흐르고 있다.",
    "누군가의 기억 속에 좋은 사람으로 남고 싶다.",
    "세월이 약이긴 한가 보다. 이젠 제법 무덤덤해졌으니.",
    "그래도, 사랑했던 날들이 더 많았으니 그걸로 되었다.",
    "아무 생각 없이 걷다 보니, 익숙한 너의 집 앞이었다.",
    "마음에도 날씨가 있다면, 오늘은 하루 종일 장마인 것 같다.",
    "한숨 자고 일어나면, 모든 게 꿈이었으면 좋겠다.",
    "따뜻한 뱅쇼 한 잔. 얼어붙은 몸과 마음을 녹여준다.",
    "낡은 벤치에 새겨진 낙서. 누군가의 사랑도 저렇게 낡아갔을까.",
    "가을은 참 쓸쓸한 계절이다. 사람을 자꾸 돌아보게 만든다.",
    "너와 함께 듣던 노래. 이젠 혼자서는 들을 용기가 나지 않는다.",
    "어른의 울음은 소리가 없다. 그래서 더 아프다.",
    "무심코 뱉은 말 한마디가, 누군가에겐 밤새 잠 못 들 상처가 된다.",
    "나만 빼고 모두가 행복해 보이는 밤. 유난히 더 외롭다.",
    "기억은 힘이 세다. 나를 한순간에 울고 웃게 만드니까.",
    "이별은 익숙해지지 않는다. 매번 처음처럼 아프다.",
    "오늘따라 보고 싶네. 그냥, 아무 이유 없이.",
    "내가 기댈 곳은, 결국 나 자신밖에 없다는 걸 깨달았다.",
    "밤 기차 창문에 기댄다. 지나가는 불빛들이 위로가 된다.",
    "말하지 않아도 알아주길 바라는 건, 너무 큰 욕심이었을까.",
    "옛 사진 속 우리는, 다시 돌아오지 않을 시간을 살고 있었다.",
    "사는 게 뭐라고. 이렇게까지 아등바등 살아야 하나.",
    "네가 남기고 간 온기가, 아직도 이 방에 남아있는 것 같다.",
    "오늘 하루, 잘 버텨줘서 고마워. 내 자신에게 해주고픈 말.",
    "눈을 감으면 네가 더 선명해져서, 잠들기가 싫다.",
    "세상에 나 혼자만 남겨진 기분. 이 고요함이 무섭다.",
    "그 시절, 우리는 무엇이든 될 수 있을 거라 믿었지.",
    "아무렇지 않은 척하는 게, 제일 힘든 일인 것 같다.",
    "낙엽 밟는 소리가 좋다. 가을이 내게 말을 거는 것 같다.",
    "다정한 말 한마디가, 무너진 하루를 일으켜 세우기도 한다.",
    "너를 잊는다는 건, 내 젊은 날의 일부를 도려내는 것과 같았다.",
    "결국 시간이 해결해 줄 거라는 말을, 더는 믿지 않기로 했다.",
    "오늘도 버텨냈다. 내일도 버텨낼 수 있을까.",
    "오래된 책 냄새가 좋다. 잊고 있던 시간의 향기 같아서.",
    "울고 싶을 땐, 그냥 실컷 우는 게 약이다.",
    "너는 나에게 파도 같아서, 밀려왔다 다시 멀어져 갔다.",
    "정답 없는 인생에, 자꾸만 정답을 찾으려 헤매고 있다.",
    "따뜻한 솜이불 속으로 파고든다. 세상의 소음이 멀어진다.",
    "그때 너를 잡았다면, 우리는 지금 어떻게 되었을까.",
    "잘하고 있는 건지, 이렇게 하는 게 맞는 건지 잘 모르겠다.",
    "밤하늘의 달을 보며, 너에게 안부를 묻는다. 잘 지내니?",
    "사람에게 받은 상처는, 결국 사람으로 치유받는 거라더라.",
    "너와의 모든 순간이, 내게는 영화의 한 장면이었다.",
    "가끔은 신에게 묻고 싶다. 왜 저에게 이런 시련을 주시냐고.",
    "바닷가에 홀로 앉아, 파도 소리를 하염없이 들었다.",
    "너를 미워하는 날보다, 그리워하는 날이 더 많아서 힘들다.",
    "하루가 참 길다. 해야 할 일은 많은데, 하고 싶은 일은 없다.",
    "오랜만에 부모님과 통화했다. 목소리가 많이 늙으셨다.",
    "결국 남는 건 사진뿐이라는 말이, 오늘따라 서글프게 들린다.",
    "다시 시작하기엔 너무 늦었고, 포기하기엔 너무 멀리 왔다.",
    "겨울 바다의 바람은, 뼛속까지 시리게 만들었다.",
    "너의 빈자리를 다른 사람으로 채우려 했지만, 더 허전해질 뿐이었다.",
    "세상이 나를 중심으로 돌지 않는다는 걸, 너무 늦게 깨달았다.",
    "오늘 같은 날엔, 그냥 아무나 붙잡고 실컷 하소연하고 싶다.",
    "우리가 함께 걷던 그 길, 이젠 나 혼자 걷고 있다.",
    "행복했던 기억이, 때로는 가장 큰 독이 되기도 한다.",
    "너무 꽉 쥐고 있었나 보다. 손을 펴니 아무것도 남아있지 않았다.",
    "비가 오면, 세상의 모든 아픔이 씻겨 내려갔으면 좋겠다.",
    "너는 내게 봄이었고, 여름이었고, 가을, 그리고 겨울이었다.",
    "다 괜찮다고 말해주는 네가 없어서, 나는 괜찮지 않다.",
    "나이를 먹을수록, 친구를 사귀는 게 더 어려워진다.",
    "어릴 적엔, 비 오는 날 물웅덩이에서 첨벙거리는 게 좋았다.",
    "이제는 희미해진 너의 얼굴을, 애써 떠올려본다.",
    "다 포기하고 싶다가도, 나를 보며 웃는 네 얼굴에 다시 힘을 낸다.",
    "먼 훗날, 이 모든 게 그저 웃어넘길 추억이 될 수 있을까.",
    "차가운 밤공기가, 오히려 뜨거운 내 속을 식혀주는 것 같다.",
    "너를 만나기 전의 나는, 어떤 모습이었는지 기억나지 않는다.",
    "열심히 하지 않은 게 아닌데. 그냥 운이 없었던 거라고 믿고 싶다.",
    "혼자인 게 편하다가도, 문득 사무치게 외로워지는 순간이 있다.",
    "첫사랑은 이루어지지 않아서 더 아름답다고 누가 그랬던가.",
    "오늘도 나는, 괜찮은 척하는 가면을 쓰고 집을 나선다.",
    "해묵은 감정들을 정리한다. 마음에도 대청소가 필요하니까.",
    "네가 없는 세상은, 소리가 꺼진 텔레비전 같다.",
    "가끔은 나보다 나를 더 잘 아는 네가 있어서 참 다행이야.",
    "어디서부터 잘못된 걸까. 자꾸만 되짚어보게 된다.",
    "지는 노을은 슬프도록 아름다워서, 눈을 뗄 수가 없었다.",
    "우리의 끝은, 이렇게 허무하게 올 줄 몰랐다.",
    "내일은 오늘보다 조금 더 웃을 수 있기를. 간절히 바라본다.",
    "소리 내어 울고 싶은데, 울음소리를 들을까 봐 입술을 깨문다.",
    "너와 헤어진 날, 세상의 모든 이별 노래가 내 노래 같았다.",
    "아무 말 없는 위로가, 때로는 백 마디 말보다 더 따뜻하다.",
    "어른이 된다는 건, 울고 싶을 때 웃는 법을 배우는 건가 보다.",
    "기대하지 않으면 실망도 없다지만, 기대 없이 살 수는 없었다.",
    "밤의 공기는 낮의 상처를 치유하는 서늘한 연고 같다.",
    "네가 두고 간 낡은 셔츠에서, 아직도 너의 향기가 난다.",
    "다 잘 될 거야. 근거는 없지만, 그냥 그렇게 믿고 싶다.",
    "어릴 적 내가 상상했던 어른의 모습은, 이게 아니었는데.",
    "너와 나의 시간은, 서로 다른 속도로 흐르기 시작했다.",
    "오늘 하루, 나에게 가장 다정하지 못했던 건 나 자신이었다.",
    "가을바람이 분다. 이별하기 좋은 계절이라 했던가.",
    "이제 그만 아파하고 싶은데, 마음이 내 말을 듣지 않는다.",
    "아무도 밟지 않은 눈길처럼, 내 인생도 새로 시작하고 싶다.",
    "너의 사소한 습관 하나하나가, 이젠 나의 그리움이 되었다.",
    "다들 나만 빼고, 각자의 자리에서 잘 살아가고 있는 것 같다.",
    "따뜻한 뱅쇼 한 잔에, 꽁꽁 얼었던 마음이 스르르 녹는다.",
    "우리가 자주 가던 카페, 아직도 그 자리에 그대로 있을까.",
    "결국 모든 관계는 변한다. 영원한 건 없다는 걸 안다.",
    "오늘 밤엔, 아무 생각 없이 그냥 푹 자고 싶다.",
    "너를 잊으려고 다른 사람을 만나는 건, 더 비참해질 뿐이었다.",
    "힘들 때 가장 먼저 생각나는 사람이, 너라는 게 서글펐다.",
    "버려진 소파를 보니, 왠지 내 모습 같아 마음이 아팠다.",
    "네가 좋아하던 비, 이제는 내가 더 좋아하게 되었다.",
    "시간이 흐르면, 이 그리움도 조금은 무뎌지겠지.",
    "어릴 적엔 몰랐던 부모님의 사랑을, 이제야 조금 알 것 같다.",
    "나는 너에게 어떤 사람으로 기억되고 있을까. 문득 궁금해졌다.",
    "별이 쏟아질 듯한 밤하늘, 너와 함께 보고 싶었다.",
    "애써 괜찮은 척했지만, 사실 하나도 괜찮지 않았다.",
    "다시 돌아갈 수 없기에, 모든 순간이 애틋하게 빛난다.",
    "오늘 하루도 무사히 끝나간다. 그것만으로도 감사해야지.",
    "너의 결혼 소식을 들었다. 축하해야 하는데, 마음이 시렸다.",
    "결국 나를 일으켜 세우는 건, 절망이 아니라 작은 희망이었다.",
    "가끔은 엉엉 울고 싶다. 어린아이처럼, 아무것도 신경 쓰지 않고.",
    "너의 웃는 모습을 보는 게, 내 인생의 가장 큰 행복이었다.",
    "사는 게 고되다. 그래도 살아내야만 한다.",
    "너와 함께했던 모든 장소가, 이젠 나에겐 슬픈 장소가 되었다.",
    "밤이 되니 센치해지네. 이놈의 감수성은 어쩔 수가 없나 보다.",
    "오늘도, 어제와 똑같은 하루를 살아냈다. 기계처럼.",
    "네가 내 인생에서 지워진다면, 어떤 이야기가 남을까.",
    "이젠 정말 끝이라고, 몇 번이나 다짐했는지 모르겠다.",
    "창문에 부딪히는 빗소리가, 꼭 네가 노크하는 소리 같았다.",
    "내가 나를 사랑하지 않는데, 누가 나를 사랑해 주겠어.",
    "오랜만에 고향에 왔다. 모든 게 변했는데, 나만 그대로인 것 같다.",
    "너의 부재는, 내 일상에 생각보다 큰 구멍을 남겼다.",
    "아무것도 아닌 일에 울컥하는 걸 보니, 나도 많이 약해졌나 보다.",
    "너와 함께 본 벚꽃, 올해는 나 혼자 봐야겠구나.",
    "세상에 쉬운 일은 하나도 없다. 어른이 되어보니 알겠다.",
    "'보고 싶다'는 말을, 차마 입 밖으로 꺼낼 수가 없었다.",
    "오늘 밤, 꿈에 나타나 줘. 할 말이 있으니까.",
    "가끔은 다 버리고, 어디론가 훌쩍 떠나고 싶다.",
    "너는 내게 당연한 사람이었는데, 당연한 건 없었다.",
    "오늘 하루, 단 한 사람이라도 내 마음을 알아줬으면 좋겠다.",
    "너를 잃고 나서야, 내가 얼마나 너를 사랑했는지 알았다.",
    "힘들다는 말조차, 사치처럼 느껴지는 날이 있다.",
    "어릴 적 친구들을 만나면, 잠시나마 그때로 돌아간 것 같다.",
    "너의 모든 것이 궁금했지만, 아무것도 물어볼 수 없었다.",
    "오늘의 눈물이, 내일의 나를 더 단단하게 만들어주길.",
    "가을은 독서의 계절이라는데, 나는 그리움에 잠긴다.",
    "너 없는 세상에, 나 혼자 덩그러니 남겨진 기분이다.",
    "그래, 이만하면 잘 살아왔다. 스스로를 다독여본다.",
    "우리가 다시 만난다면, 웃으며 인사할 수 있을까.",
    "오늘 밤, 달이 참 예쁘다. 이 말을 너에게 해주고 싶었다.",
    "인생은 희극이라는데, 왜 내 인생은 비극에 더 가까울까.",
    "너의 SNS를 몰래 훔쳐본다. 잘 지내는 것 같아 다행이다.",
    "나는 아직도, 너와의 추억 속에 살고 있다.",
    "오늘 하루도, 무사히 버텨낸 나에게 박수를 보낸다.",
    "너의 이름을 부르다, 잠에서 깼다. 텅 빈 방만 고요했다.",
    "모든 걸 다 가졌어도, 네가 없으면 아무 의미가 없다.",
    "오늘 같은 밤엔, 그냥 취해버리고 싶다. 다 잊어버리게.",
    "너와 함께 걷던 이 길, 이젠 발걸음이 무겁기만 하다.",
    "세상에서 가장 슬픈 거짓말은, '괜찮다'는 말이다.",
    "너를 만나 참 행복했다. 그걸로 되었다.",
    "오늘 하루, 수고 많았어요. 따뜻한 차 한 잔 하고 푹 쉬어요.",
    "낡은 필름처럼, 우리의 기억도 언젠가 빛이 바래겠지.",
    "네가 없는 내일이, 오는 것이 두려웠다.",
    "가끔은 아무 이유 없이, 네가 사무치게 그립다.",
    "비가 오는 날엔, 네 생각에 잠겨 하루를 보낸다.",
    "어릴 적엔, 어른이 되면 뭐든지 할 수 있을 줄 알았다.",
    "너와 헤어진 후, 세상의 모든 사랑 노래가 슬프게 들렸다.",
    "오늘 하루, 잘 살아낸 것만으로도 대단한 거야.",
    "네가 떠난 후, 내 시간은 그날에 멈춰 버렸다.",
    "보고 싶다는 말 대신, 그저 밤하늘의 달만 바라본다.",
    "괜찮지 않아도 괜찮아. 그럴 때도 있는 거니까.",
    "너와 함께한 계절은, 유난히 짧고 아름다웠다.",
    "오늘도 나는, 세상이라는 무대 위에서 광대를 연기한다.",
    "너의 빈자리가, 이렇게 클 줄은 미처 몰랐다.",
    "아무도 모르게 흘리는 눈물이, 가장 뜨거운 법이다.",
    "가끔은 모든 걸 내려놓고, 그저 바람처럼 살고 싶다.",
    "너를 잊기 위해, 나는 오늘도 바쁘게 살아간다.",
    "오늘 밤은, 유난히 네가 보고 싶어서 잠 못 이룰 것 같다.",
    "힘들 때, 기댈 어깨 하나 없는 게 제일 서럽다.",
    "너와 함께 듣던 그 노래, 이젠 혼자서도 잘 듣는다.",
    "오늘 하루, 너는 몇 번이나 내 생각을 했을까.",
    "너를 사랑했던 시간만큼, 아파해야 하는 걸까.",
    "사는 게 지칠 때면, 어릴 적 나를 찾아간다. 추억 속으로.",
    "너의 안부가 궁금하지만, 들을 용기가 나지 않는다.",
    "오늘 밤, 꿈에서라도 만나서 못다 한 이야기를 하고 싶다.",
    "가끔은, 내가 사라져도 아무도 모를 것 같다는 생각이 든다.",
    "너는 내게, 잊을 수 없는 첫눈 같은 사람이었다.",
    "오늘 하루, 나를 위해 울어줄 사람은 나밖에 없었다.",
    "너와의 기억을, 나는 오늘도 곱씹으며 살아간다.",
    "세상이 무너지는 것 같아도, 내일의 해는 또 떠오르겠지.",
    "너를 만나기 전으로, 시간을 되돌릴 수만 있다면.",
    "오늘 같은 날엔, 그냥 흠뻑 젖고 싶다. 비에도, 슬픔에도.",
    "너는 내 인생의 가장 아름다운 실수였다.",
    "오늘 하루도, 무사히 살아남았다. 전쟁 같은 하루였다.",
    "너의 이름을, 이제는 편하게 부를 수 있게 되었다.",
    "보고 싶다는 말을 삼킨다. 그 말은 이제 내 것이 아니기에.",
    "오늘 밤, 별이 참 많다. 저 별 중에 하나는 너일까.",
    "가끔은, 내가 뭘 위해 이렇게 열심히 사는지 모르겠다.",
    "너는 내게, 한여름 밤의 꿈처럼 다가왔다 사라졌다.",
    "오늘 하루, 웃었던 기억보다 울었던 기억이 더 많다.",
    "너와의 추억이, 나를 살게도 하고 죽게도 한다.",
    "세상은 넓고 할 일은 많다는데, 나는 왜 이리 무기력할까.",
    "너를 잊는 것이, 내게 주어진 가장 어려운 숙제다.",
    "오늘 밤, 네 생각에 잠겨 뜬눈으로 밤을 새운다.",
    "힘들면, 잠시 모든 걸 잊고 떠나는 것도 방법이다.",
    "너는 내게, 지울 수 없는 문신처럼 새겨졌다.",
    "오늘 하루, 나를 가장 힘들게 한 건, 바로 나 자신이었다.",
    "너를 사랑한 걸, 후회하지는 않는다. 다만, 아플 뿐이다.",
    "사는 게, 내 마음처럼 되는 게 하나도 없구나.",
    "너의 소식을, 다른 사람을 통해 듣는 것이 제일 싫었다.",
    "오늘 밤, 달에게 너의 안부를 물어본다. 부디 평안하기를.",
    "가끔은, 내가 너무 미워서 견딜 수가 없다.",
    "너는 내게, 마지막 사랑이 될 거라고 믿었다.",
    "오늘 하루, 나를 위로해 주는 건 따뜻한 커피 한 잔뿐이다.",
    "너와의 기억을, 나는 오늘도 안주 삼아 술을 마신다.",
    "세상에, 나보다 더 불행한 사람도 많겠지. 그렇게 위로해 본다.",
    "너를 잊으려고, 나는 오늘도 다른 사람을 만난다.",
    "오늘 밤, 네가 너무 보고 싶어 가슴이 먹먹하다.",
    "힘들 때, 울 곳이 있다는 것만으로도 큰 위로가 된다.",
    "너는 내게, 지지 않는 태양 같았다. 언제나 그 자리에 있을 줄 알았다.",
    "오늘 하루, 나는 몇 번이나 괜찮은 척 웃었을까.",
    "너와의 모든 순간이, 내게는 선물이었다. 아픈 선물.",
    "사는 게, 때로는 죽는 것보다 더 큰 용기가 필요하다.",
    "너의 행복을 빌어주는 것이, 내가 할 수 있는 마지막 사랑이었다.",
    "오늘 밤, 네 꿈을 꾸고 싶다. 행복했던 우리 꿈을.",
    "가끔은, 세상에 나 혼자만 남은 것 같은 기분이 든다.",
    "너는 내게, 가장 아픈 손가락이다. 만질수록 아프지만, 계속 만지게 되는.",
    "오늘 하루, 나를 위한 작은 사치를 부려본다. 케이크 한 조각.",
    "너와의 추억을, 나는 오늘도 일기장에 적어 내려간다.",
    "세상이, 나에게만 유독 가혹한 것 같다는 생각이 들 때가 있다.",
    "너를 잊는다는 건, 어쩌면 평생 불가능한 일일지도 모른다.",
    "오늘 밤, 네 생각에 잠 못 이루는 밤이 또 하루 늘었다.",
    "힘들면, 그냥 다 놓고 싶다. 아무 미련 없이.",
    "너는 내게, 가장 찬란했던 계절이었다. 다시 오지 않을.",
    "오늘 하루, 나를 가장 외롭게 만든 건, 너의 부재였다.",
    "너를 사랑했던 나를, 이제는 놓아주어야 할 때가 온 것 같다.",
    "사는 게, 참 별거 없다는 생각이 드는 날이다.",
    "너의 소식을, 차라리 듣지 않았더라면 좋았을 텐데.",
    "오늘 밤, 저 별들처럼, 나도 멀리서 너를 비춰주고 싶다.",
    "가끔은, 내가 나를 용서할 수 없을 때가 있다.",
    "너는 내게, 풀리지 않는 숙제 같다. 평생을 안고 가야 할.",
    "오늘 하루, 나를 웃게 한 것도, 울게 한 것도 모두 너였다.",
    "너와의 기억을, 나는 오늘도 가슴에 묻는다.",
    "세상이, 나를 중심으로 돌아가지 않는다는 걸 이제는 안다.",
    "너를 잊기 위해, 나는 오늘도 새로운 추억을 만든다. 너 없이.",
    "오늘 밤, 네가 없는 이 밤이 너무나 길고 외롭다.",
    "힘들 때, 혼자 끙끙 앓지 마. 누군가에게는 털어놔도 괜찮아.",
    "너는 내게, 가장 따뜻했던 봄날의 햇살 같았다.",
    "오늘 하루, 나는 몇 번이나 너의 이름을 속으로 불렀을까.",
    "너와의 모든 날이, 좋았다고는 말할 수 없지만, 그래도 소중했다.",
    "사는 게, 뜻대로 되지 않을 때가 더 많다는 걸 안다.",
    "너의 행복이, 곧 나의 행복이었던 시절이 있었다.",
    "오늘 밤, 네가 없는 이 도시의 야경이 유난히 쓸쓸하다.",
    "가끔은, 내가 아닌 다른 사람으로 살아보고 싶다는 생각을 한다.",
    "너는 내게, 가장 완벽했던 퍼즐의 마지막 한 조각이었다.",
    "오늘 하루, 나를 가장 아프게 한 건, 너에 대한 그리움이었다.",
    "너를 사랑했던 시간들을, 이제는 아름다운 추억으로 남기려 한다.",
    "사는 게, 때로는 너무 무겁고 버겁게 느껴진다.",
    "너의 빈자리가, 이렇게나 크게 느껴질 줄은 몰랐다.",
    "오늘 밤, 네 생각에 잠겨, 또다시 밤을 지새운다.",
    "힘들면, 잠시 쉬어가도 괜찮아. 길은 언제나 그 자리에 있으니까.",
    "너는 내게, 가장 눈부셨던 청춘의 한 페이지였다.",
    "오늘 하루, 나는 너라는 책을 몇 번이나 다시 읽었을까.",
    "너와의 이별이, 내게는 가장 큰 성장통이었다.",
    "사는 게, 때로는 너무나 외로운 싸움 같다는 생각이 든다.",
    "너의 웃음소리가, 아직도 귓가에 맴도는 것 같다.",
    "오늘 밤, 저 달에게 내 마음을 전해달라고 부탁해 본다.",
    "가끔은, 내가 너무 초라하게 느껴져서 숨고 싶을 때가 있다.",
    "너는 내게, 영원히 끝나지 않을 영화 같았다.",
    "오늘 하루, 나를 가장 슬프게 한 건, 더 이상 네가 없다는 사실이었다.",
    "너를 사랑했던 나를, 이제는 안아주려고 한다. 수고했다고.",
    "사는 게, 때로는 너무나 막막하게 느껴질 때가 있다.",
    "너의 흔적이, 내 삶의 곳곳에 배어 있다.",
    "오늘 밤, 네가 없는 이 세상이 너무나 낯설게 느껴진다.",
    "힘들 때, 하늘을 봐. 언제나 그 자리에 있는 별처럼, 나도 곁에 있을게.",
    "너는 내게, 가장 아름다웠던 노래였다. 슬픈 멜로디의.",
    "오늘 하루, 나는 너라는 이름의 감옥에 갇혀 있었다.",
    "너와의 만남이, 내게는 축복이었을까, 저주였을까.",
    "사는 게, 때로는 너무나 공허하게 느껴질 때가 있다.",
    "너의 목소리가, 너무나 듣고 싶은 밤이다.",
    "오늘 밤, 네가 내 꿈에 찾아와 주었으면 좋겠다.",
    "가끔은, 모든 게 거짓말이었으면 좋겠다는 생각을 한다.",
    "너는 내게, 가장 소중했던 보물이었다. 잃어버린.",
    "오늘 하루, 나를 가장 힘들게 한 건, 너를 잊지 못하는 나 자신이었다.",
    "너를 사랑했던 그 마음, 이제는 고이 접어 하늘로 보낸다.",
    "사는 게, 때로는 너무나 덧없이 느껴질 때가 있다.",
    "너의 모든 것을, 나는 아직도 기억하고 있다.",
    "오늘 밤, 네가 없는 이 밤이 너무나 차갑게 느껴진다.",
    "힘들면, 울어도 괜찮아. 눈물은 약한 게 아니라, 솔직한 거니까.",
    "너는 내게, 가장 눈부셨던 태양이었다. 이제는 져버린.",
    "오늘 하루, 나는 너라는 그림자를 끌고 다녔다.",
    "너와의 인연이, 여기까지였다는 걸 받아들이기가 너무 힘들다.",
    "아들아, 인생에 정답은 없단다. 그저 너의 답을 찾으렴.",
    "엄마, 행복은 돈으로 사는 게 아니었어. 이제야 알았네.",
    "친구야, 남들 보라고 사는 인생, 이젠 그만하면 안 될까?",
    "거울 속 나에게 속삭였다. '너, 꽤 잘하고 있어'라고.",
    "할머니는 말씀하셨다. 마음 편한 게 제일 큰 복이라고.",
    "지하철 창문에 비친 아저씨, 참 고단한 하루였나 보다.",
    "네가 그러더라. 내 인생의 주인공은 나 자신이어야 한다고.",
    "이제 알 것 같아. 나를 사랑해야 남도 사랑할 수 있단 걸.",
    "괜찮아, 다 잘 될 거야. 주문처럼 되뇌는 밤이 깊어간다.",
    "옆자리 그녀가 웃었다. 세상이 다 환해지는 것 같았다.",
    "아빠의 구겨진 와이셔츠에서, 삶의 무게가 느껴졌다.",
    "그 애는 늘 말했다. 비교하는 순간 지옥이 시작된다고.",
    "오늘 하루, 나를 미워하는 사람 말고 나를 위해 살기로 했다.",
    "사는 게 별거 있니. 그냥 오늘 너랑 마시는 커피 한 잔이지.",
    "꼬마 아이가 엉엉 울다 까르르 웃었다. 행복은 그런 건가.",
    "내 마음의 소리를 듣는 연습, 생각보다 꽤 어렵더라.",
    "바보같이, 남의 박수 소리에 춤추며 살았네. 이제 그만.",
    "넘어져도 괜찮아. 하늘 한번 보고 다시 일어나면 되지 뭐.",
    "창가에 앉은 노부부, 주름진 손을 꼭 잡고 있었다.",
    "너는 너의 속도로, 나는 나의 속도로. 그걸로 된 거야.",
    "최고의 복수는 엄청난 성공이래. 그 말, 오늘따라 와닿네.",
    "내 안의 어린 아이를, 오늘은 꼭 안아주기로 약속했다.",
    "엄마의 잔소리가, 실은 사랑이란 걸 너무 늦게 알았다.",
    "그 사람, 참 바보야. 자기 가치를 자기가 모르더라.",
    "오늘부터 내 행복 사전에 '남의 시선'은 지워버린다.",
    "인생은 속도가 아니라 방향이래. 너, 지금 어디로 가고 있니?",
    "나를 위한 작은 사치, 오늘 하루쯤은 허락해 주기로 했다.",
    "저기 봐, 저 꽃도 제 계절에 맞춰 피잖아. 조급해하지 마.",
    "아빠, 이제 걱정 마. 나도 내 인생 운전할 줄 알아.",
    "어릴 적 일기장을 보니, '행복'이 참 쉬운 단어였다.",
    "친구가 말했다. '네 인생은 네가 써 내려가는 소설'이라고.",
    "완벽하지 않아도 돼. 우린 모두 그렇게 서툴게 어른이 돼.",
    "가끔은 '아니오'라고 말해야, 내 마음을 지킬 수 있더라.",
    "길모퉁이 빵집 아저씨, 매일 아침 웃으며 문을 연다.",
    "나를 잃어버리면서까지, 지켜야 할 관계는 없다는 걸 깨달았다.",
    "힘들면 잠시 쉬어가. 아무도 너를 비난하지 않아.",
    "그는 늘 혼잣말을 했다. '나는 생각보다 강하다'고.",
    "공원 벤치의 할아버지, 비둘기 모이를 주며 웃고 계셨다.",
    "인생은 한 번뿐이래. 그러니 우리, 후회 없이 사랑하자.",
    "오늘만큼은 나에게 가장 다정한 친구가 되어주기로 했다.",
    "내 가치를 모르는 사람에게, 마음을 줄 필요는 없잖아.",
    "행복은 말이야, 저 멀리 있는 게 아니라 바로 옆에 있대.",
    "아들아, 가장 큰 선물은 평범한 오늘 하루란다.",
    "그녀는 비로소 알았다. 자신을 용서해야 자유로워진다는 걸.",
    "남의 인생 부러워하다 보니, 내 인생은 멈춰있더라.",
    "친구야, 너 자신을 믿어. 세상이 다 등 돌려도 나는 네 편이야.",
    "오늘의 작은 행복들을, 일기장에 차곡차곡 모아본다.",
    "저 아이 좀 봐. 넘어져도 툭툭 털고 다시 뛰어가네.",
    "인생은 B와 D 사이의 C래. 선택이 중요하단 뜻이겠지.",
    "아빠의 술주정 속엔, 늘 '미안하다'는 말이 숨어있었다.",
    "내 마음이 원하는 걸, 이제야 겨우 들여다보기 시작했다.",
    "그녀는 웃으며 말했다. '미움받을 용기, 그거면 충분해.'",
    "걱정의 9할은 일어나지 않는대. 우리, 오늘을 살자.",
    "남의 드라마에 훈수 둘 시간에, 내 인생부터 챙기자.",
    "아빠, 저 이제 괜찮아요. 넘어지는 법도 배웠거든요.",
    "오래된 레코드 가게 주인, 그는 음악 속에서 행복을 찾았다.",
    "나를 비난하는 목소리보다, 나를 응원하는 내 소리를 듣자.",
    "네가 그랬잖아. 가장 나다운 게 가장 아름다운 거라고.",
    "사는 게 다 그렇지 뭐. 웃는 날도, 우는 날도 있는 거지.",
    "가장 큰 감옥은, '나는 안 될 거야'라는 내 생각이었어.",
    "엄마의 거친 손을 잡으니, 내 어리광이 죄송스러워졌다.",
    "남들이 뭐라든, 나는 나의 우주에서 가장 빛나는 별이야.",
    "친구야, 우리 서로의 시간을 존중해 주자. 그게 사랑이야.",
    "오늘의 나는, 어제보다 딱 한 뼘 더 자랐으면 좋겠다.",
    "그녀는 조용히 말했다. '진정한 평화는 내 안에 있다'고.",
    "인생 뭐 있니? 그냥 너랑 맛있는 거 먹는 게 행복이지.",
    "아빠의 어깨가 저렇게 작았나. 오늘따라 유난히 그래 보이네.",
    "나를 사랑하는 연습, 그게 제일 어려운 숙제인 것 같아.",
    "골목길 담벼락의 낙서, 누군가에겐 소중한 추억이겠지.",
    "남의 기준에 맞추다 보니, 내가 누군지 잊어버렸잖아.",
    "아들아, 가장 큰 지혜는 너 자신을 아는 것이란다.",
    "그는 말했다. '행복은 찾는 게 아니라 만드는 거'라고.",
    "가끔은 아무 계획 없이, 발길 닿는 대로 걸어보는 거야.",
    "나를 위한 시간을 갖는 건, 이기적인 게 아니라 충전이야.",
    "엄마, 행복은 성적순이 아니잖아요. 저 그냥 웃고 싶어요.",
    "그 노인은 말했다. '가진 걸 즐기는 게 진짜 부자'라고.",
    "다른 사람을 바꾸려 애쓰지 마. 그 시간에 내가 변하는 게 빨라.",
    "나, 꽤 괜찮은 사람이야. 스스로에게 자주 말해주자.",
    "인생은 단막극이래. 그러니 매 순간을 주인공처럼 살자.",
    "어릴 적 동네 문방구 할머니, 늘 웃으며 사탕을 주셨다.",
    "남에게 보여주기 위한 삶, 이젠 정말 지긋지긋해.",
    "친구야, 우리 서로의 다름을 틀림으로 만들지는 말자.",
    "가장 큰 실수는, 아무것도 하지 않는 거라는 걸 깨달았다.",
    "그녀는 읊조렸다. '내 영혼의 선장은 바로 나 자신'이라고.",
    "인생은 해석의 문제. 컵에 물이 반이나 남았다고 생각할래.",
    "오늘 하루, 세상의 소음은 끄고 내 마음의 소리를 튼다.",
    "아빠, 저는 아빠처럼 살고 싶지 않았는데, 점점 닮아가네요.",
    "행복은 감사라는 문으로 들어온대. 불평은 이제 그만.",
    "낡은 구두를 신은 아저씨, 그의 걸음엔 힘이 넘쳤다.",
    "나를 믿어주는 단 한 사람, 그게 나라면 충분하지 않을까?",
    "아들아, 인생은 오르막이 있으면 내리막도 있는 거란다.",
    "그 카페 주인은 말했다. '손님의 미소가 제 행복'이라고.",
    "가장 큰 용서는, 완벽하지 않은 나를 그냥 안아주는 거야.",
    "행복은 덧셈이 아니라 뺄셈. 불필요한 것들을 덜어내자.",
    "친구야, 너의 길을 가. 남의 지도는 너에게 맞지 않아.",
    "버스 기사 아저씨의 한숨 소리, 나에게까지 전해지는 듯했다.",
    "나는 날마다, 모든 면에서 조금씩 더 나아지고 있어.",
    "엄마, 미안해. 엄마의 꿈을 내가 대신 살 수는 없었어.",
    "가장 지혜로운 사람은, 변하는 것과 변하지 않는 걸 안대.",
    "그는 낡은 책을 보며 말했다. '이 안에 길이 있다'고.",
    "나의 행복을 남에게 허락받을 필요는 없다는 걸 알았다.",
    "가장 큰 변화는, 작은 습관 하나를 바꾸는 것에서 시작돼.",
    "인생은 마라톤이 아니라, 풍경을 즐기는 산책이래.",
    "나, 오늘부터 나에게 가장 친절한 사람이 되기로 했어.",
    "그녀는 창밖을 보며 말했다. '모든 답은 내 안에 있다'고.",
    "가장 큰 자유는, '해야 한다'는 강박에서 벗어나는 거야.",
    "행복은 전염된대. 내가 먼저 웃어주는 사람이 되어야지.",
    "친구야, 네가 빛나야 네 주변도 밝아지는 거야.",
    "나를 정의하는 건, 나의 실수가 아니라 그 후의 태도래.",
    "인생은 항해와 같아. 가끔은 풍랑도 만나고 그러는 거지.",
    "오늘 밤, 나를 힘들게 했던 모든 것들을 용서하기로 했다.",
    "그녀는 말했다. 행복은 '언젠가'가 아니라 '지금'이라고.",
    "남들이 알아주지 않아도 괜찮아. 나는 나의 가치를 아니까.",
    "아들아, 인생은 놀이터란다. 신나게, 후회 없이 놀아라.",
    "나를 아프게 했던 과거와, 오늘부로 작별 인사를 한다.",
    "가장 큰 힘은, '그럼에도 불구하고' 다시 시작하는 용기래.",
    "행복은 내가 선택하는 거래. 나는 오늘 행복하기로 했어.",
    "내 삶의 주인으로 사는 연습, 오늘부터 1일이야.",
    "인생은 짧아. 미워하는 데 시간을 쓰기엔 너무 아까워.",
    "아빠, 저도 이제 아빠의 침묵이 사랑인 걸 알 것 같아요.",
    "가장 큰 위로는, '너는 혼자가 아니야'라는 말 한마디래.",
    "행복은 평범한 일상의 소중함을 깨닫는 바로 그 순간이래.",
    "나를 향한 비난에, 이제 더는 흔들리지 않기로 마음먹었다.",
    "인생은 연극이야. 슬픈 장면이 있으면, 기쁜 장면도 있어.",
    "친구야, 네가 널 사랑해야, 세상도 널 사랑해 준대.",
    "가장 큰 발견은, 내 안의 숨겨진 가능성을 찾는 거래.",
    "나를 위한 삶, 그게 진짜 '갓생' 아닐까?",
    "인생은 흐르는 강물이래. 과거에 머물지 말고 그냥 흘러가자.",
    "어릴 적 사진 속 나는, 참 걱정 없이 해맑게 웃고 있구나.",
    "행복은, 작은 기쁨들을 자주 느끼는 거. 그거면 충분해.",
    "나를 사랑하는 데에는, 어떤 조건도 필요 없다는 걸 알았어.",
    "그녀는 늘 다짐했다. '내 삶의 정답은 내가 만든다'고.",
    "가장 큰 용기는, 나의 불완전함을 그냥 사랑해 주는 거래.",
    "남을 위한 삶을 살다 보니, 정작 '나'는 사라지고 없더라.",
    "나는 내 삶의 기적, 그 자체라는 걸 잊지 말자.",
    "아빠의 낡은 지갑 속, 닳아빠진 내 사진을 보고 울었다.",
    "친구야, 우리는 각자의 시간 속에서 피어나는 꽃이야.",
    "그는 말했다. '인생은 나 자신과 화해하는 과정'이라고.",
    "모두를 만족시키려는 욕심, 그게 나를 병들게 했다.",
    "인생은 메아리 같아서, 내가 뱉은 말이 나에게 돌아온대.",
    "나를 둘러싼 모든 평가는, 그저 그들의 생각일 뿐이야.",
    "가장 큰 행복은, 사랑하고 또 사랑받는 것이라고 했다.",
    "나는 내 생각의 산물. 행복을 생각하면, 정말 행복해질까?",
    "그녀는 읊조렸다. '내 인생의 가장 아름다운 풍경은 나'라고.",
    "넘어지는 건 실패가 아니야. 다시 일어나지 않는 게 실패지.",
    "엄마의 기도가, 보이지 않는 우산이 되어 나를 지켜줬다.",
    "행복은 관점의 문제. 긍정의 안경을 끼고 세상을 보자.",
    "남의 빛을 보고 내 그림자를 탓하지 말자. 나도 빛나니까.",
    "인생은 음악 같아. 쉼표가 있어야 다음 악장이 더 아름다워.",
    "나를 가장 잘 아는 사람은, 결국 나 자신뿐이었어.",
    "그녀는 말했다. '불행을 세지 말고, 축복을 세어보라'고.",
    "나를 위한 최고의 휴식은, 잠시 모든 기대를 내려놓는 것.",
    "친구야, 우리 서로에게 좋은 영향을 주는 사람이 되자.",
    "가장 큰 성장은, 어제의 나보다 한 뼘이라도 나아지는 것.",
    "인생은 나라는 사람을 알아가는, 길고 긴 여행이래.",
    "나를 위한 최고의 응원, '이만하면 잘하고 있어'.",
    "행복은 '가지는 것'이 아니라, '감사하는 것'에서 온다.",
    "가장 지혜로운 삶은, 어제의 나보다 오늘 더 성장하는 삶.",
    "나의 가치는 남의 인정이 아니라, 나의 믿음으로 결정된다.",
    "인생은 한 권의 책. 나는 내 책의 작가이자 주인공이다.",
    "가장 큰 힘은, 어떤 상황에서도 나를 믿어주는 마음이다.",
    "다른 사람을 바꾸려 애쓰지 마. 내가 바뀌는 게 더 빠르다.",
    "나는 충분히 사랑받을 자격이 있는, 소중한 존재다.",
    "인생에서 가장 큰 위험은, 아무 위험도 감수하지 않는 것.",
    "나를 온전히 받아들일 때, 세상도 나를 받아들이기 시작해.",
    "가장 큰 행복은, 사랑하는 사람과 함께 웃는 것이다.",
    "내가 빛나면, 내 주변도 자연스레 밝아진다는 걸 믿는다.",
    "행복은, 불행이 없는 상태가 아니라 그것을 다루는 능력이다.",
    "남의 기준에 나를 맞추지 말고, 나의 기준을 세상에 보여주자.",
    "나는 내 생각보다 강하다. 이 시련도 결국 지나갈 것이다.",
    "가장 큰 지혜는, 내가 무엇을 모르는지 아는 것이다.",
    "행복은 특별한 날이 아니라, 평범한 날 속에 숨어 있다.",
    "나의 행복은 나의 책임이다. 누구도 대신해 줄 수 없다.",
    "가장 깊은 강은 조용히 흐른다. 내면이 단단한 사람이 되자.",
    "인생은 해석의 문제. 컵에 물이 반밖에 없나, 반이나 있나.",
    "나를 사랑하는 것이, 모든 것의 시작이라는 걸 잊지 마.",
    "가장 큰 자유는, '해야 한다'는 강박에서 벗어나는 것이다.",
    "행복은 전염된다. 내가 먼저 행복한 사람이 되어주자.",
    "다른 사람의 속도와 내 속도를 비교하지 않는다. 나는 내 길을 간다.",
    "나는 내 인생의 유일한 조종사다. 목적지는 내가 정한다.",
    "가장 큰 용서는, 완벽하지 않은 나 자신을 용서하는 것이다.",
    "행복은 덧셈이 아니라 뺄셈. 불필요한 것들을 덜어낼 때 찾아온다.",
    "나를 믿어주는 단 한 사람, 그게 나 자신이라면 충분하다.",
    "가장 큰 기적은, 오늘 아침 내가 다시 눈을 떴다는 사실이다.",
    "인생은 오르막과 내리막의 연속. 일희일비하지 말자.",
    "나를 위한 가장 좋은 변호사는, 언제나 나 자신이어야 한다.",
    "행복은 맑은 날에만 있는 게 아니다. 비 오는 날의 운치도 행복이다.",
    "남의 눈치를 보느라, 정작 내가 뭘 원하는지 잊고 살았다.",
    "나는 소우주다. 내 안에 무한한 가능성이 잠들어 있다.",
    "인생은 예술이다. 정해진 법칙 없이, 나만의 방식으로 창조해나가자.",
    "가장 큰 힘은, 포기하지 않는 끈기에서 나온다.",
    "행복은 소유가 아니라 존재의 방식이다. 지금 이 순간을 살자.",
    "나를 싫어하는 사람보다, 나를 사랑하는 사람에게 집중하자.",
    "가장 어려운 여행은, 내 안으로 떠나는 여행이다.",
    "인생은 경험의 총합. 좋은 경험이든 나쁜 경험이든 다 나의 자산이다.",
    "나를 행복하게 만드는 목록을, 오늘 밤 적어보기로 했다.",
    "가장 큰 변화는, 작은 습관 하나를 바꾸는 것에서 시작된다.",
    "행복은, 내가 누구인지 알고, 있는 그대로의 나를 사랑하는 것이다.",
    "남에게 상처 주는 말을 하지 않듯, 나에게도 상처 주는 생각을 하지 말자.",
    "나는 날마다, 모든 면에서 조금씩 더 나아지고 있다.",
    "인생은 선물이다. 포장지가 아니라, 그 안의 내용물을 즐기자.",
    "가장 큰 배움은, 실수를 통해 얻는 교훈이다. 넘어짐을 두려워 말자.",
    "행복은, '언젠가'가 아니라 '바로 지금' 여기에 있다.",
    "나의 가치를 증명하기 위해 애쓰지 않아도, 나는 이미 가치 있는 사람이다.",
    "인생은 마라톤이 아니라, 각자의 풍경을 즐기는 산책이다.",
    "나를 가장 잘 아는 사람은, 결국 나 자신뿐이다. 내 감정을 믿자.",
    "행복은, '무엇을'이 아니라 '어떻게'의 문제다. 관점을 바꾸자.",
    "모두가 가는 길이라고 해서, 그게 나의 길일 필요는 없다.",
    "나는 내 삶의 작가. 해피엔딩으로 만들 책임은 나에게 있다.",
    "인생은 긴 소설, 오늘은 그중 한 페이지일 뿐이다. 너무 심각해지지 말자.",
    "가장 큰 재산은, 돈이 아니라 나와의 좋은 관계다.",
    "행복은, 내가 가진 것에 감사하고, 가지지 못한 것에 자유로워지는 것이다.",
    "나를 둘러싼 모든 것들은, 내가 어떤 눈으로 보느냐에 따라 달라진다.",
    "나는 이 세상에 단 하나뿐인 한정판. 나를 아끼고 사랑하자.",
    "인생은 예측 불가능해서 더 재미있는 게임이다. 즐겨보자.",
    "가장 큰 평화는, 내 마음의 소란을 잠재우는 것이다.",
    "행복은, '완벽함'이 아니라 '온전함'을 추구하는 데 있다.",
    "나를 정의하는 것은, 나의 실수가 아니라 실수 후의 나의 태도다.",
    "인생은 항해와 같다. 순풍이 불 때도, 역풍이 불 때도 있다.",
    "나를 위한 최고의 휴식은, 잠시 모든 기대를 내려놓는 것이다.",
    "행복은, 밖에서 찾는 것이 아니라 내 안에서 발견하는 것이다.",
    "모두를 만족시키려는 욕심을 버리니, 마음이 한결 가벼워졌다.",
    "나는 내 인생의 정원사. 행복의 씨앗을 심고 가꾸어 나가자.",
    "인생은 메아리와 같다. 내가 세상에 외친 것이 그대로 돌아온다.",
    "가장 큰 힘은, '그럼에도 불구하고' 다시 시작하는 용기다.",
    "행복은, 미래의 목표가 아니라 현재의 선택이다.",
    "나의 행복을, 다른 사람의 허락을 받을 필요는 없다.",
    "인생은 짧다. 하고 싶은 일을 하며 살기에도 부족한 시간이다.",
    "나를 사랑하는 가장 좋은 방법은, 있는 그대로의 나를 받아들이는 것이다.",
    "가장 큰 지혜는, 변하는 것과 변하지 않는 것을 구분하는 것이다.",
    "행복은, 내가 얼마나 많이 가졌는지가 아니라, 얼마나 많이 나누는지에 있다.",
    "남의 빛을 보고 내 그림자를 탓하지 말자. 나도 나만의 빛이 있다.",
    "나는 내 삶의 기적을 만들어낼 힘을 가지고 있다.",
    "인생은 음악과 같다. 때로는 높은음, 때로는 낮은음이 있어야 아름답다.",
    "가장 큰 위로는, '너는 혼자가 아니야'라는 따뜻한 연대감이다.",
    "행복은, 특별한 사건이 아니라 평범한 일상의 소중함을 깨닫는 것이다.",
    "나를 향한 비난에 흔들리지 않는 단단한 마음을 기르자.",
    "나는 내 삶의 위대한 탐험가. 미지의 세계를 향해 나아가자.",
    "인생은 연극이다. 슬픈 장면이 있다면, 즐거운 장면도 반드시 있다.",
    "가장 큰 용서는, 나에게 상처 준 사람을 내 마음에서 놓아주는 것이다.",
    "행복은, '지금'이라는 시간을 온전히 살아내는 것이다.",
    "나를 둘러싼 부정적인 소음들로부터, 내 마음을 지켜내자.",
    "인생은 그림 그리기. 실수를 두려워하면 아무것도 그릴 수 없다.",
    "나를 온전히 사랑할 때, 비로소 세상을 제대로 사랑할 수 있다.",
    "가장 큰 발견은, 내 안에 숨겨진 힘과 가능성을 발견하는 것이다.",
    "행복은, 내가 선택하는 것이다. 나는 오늘 행복하기로 선택했다.",
    "남의 드라마에 감 놔라 배 놔라 할 시간에, 내 드라마를 더 잘 만들자.",
    "나는 충분히 괜찮은 사람. 스스로에게 더 자주 말해주자.",
    "인생은 흐르는 강물. 과거에 머물지 말고, 현재를 따라 흘러가자.",
    "가장 큰 성장은, 어제의 나보다 딱 한 뼘이라도 나아지는 것이다.",
    "행복은, 채우는 것이 아니라 비우는 것이다. 욕심을 비우자.",
    "나를 믿는 힘이, 세상의 어떤 힘보다도 강하다.",
    "인생은 길다. 가끔은 쉬어가도, 조금 돌아가도 괜찮다.",
    "나를 위한 가장 좋은 투자는, 나의 경험과 배움에 쓰는 시간과 돈이다.",
    "행복은, 내가 나일 수 있을 때 찾아오는 편안함이다.",
    "타인의 어둠을 탓하기보다, 내 안의 작은 촛불을 켜는 사람이 되자.",
    "나는 내 삶의 기적. 매일 아침 눈을 뜨는 것부터가 기적이다.",
    "인생은, '어떻게 살 것인가'라는 질문에 답을 찾아가는 여정이다.",
    "가장 큰 힘은, 부드러움이다. 물은 바위도 뚫는다.",
    "행복은, 내가 가진 것을 사랑하고, 내가 사랑하는 것을 갖는 것이다.",
    "나를 지치게 하는 모든 것들로부터, 잠시 휴가를 주기로 했다.",
    "나는 내 운명의 주인, 나는 내 영혼의 선장이다.",
    "인생은, 정해진 길을 가는 게 아니라 가면서 길을 만드는 것이다.",
    "가장 큰 용기는, 나의 약점과 불완전함을 드러내는 용기다.",
    "행복은, '언젠가'를 기다리는 것이 아니라 '지금'을 즐기는 것이다.",
    "나 자신에게 최고의 친구가 되어주자. 언제나 내 편이 되어주는.",
    "인생은 춤과 같다. 스텝이 꼬여도, 음악을 즐기면 그만이다.",
    "가장 큰 행복은, 평온한 마음이다. 어떤 것에도 흔들리지 않는.",
    "나를 바꾸는 것은, 100가지 결심이 아니라 1가지 실천이다.",
    "나는 내 삶의 유일한 심판관. 남의 판결에 휘둘리지 말자.",
    "인생은, 사랑하는 법을 배우기 위해 주어진 시간이다.",
    "가장 큰 깨달음은, 모든 답이 내 안에 있었다는 것을 아는 것이다.",
    "행복은, 감사의 문으로 들어와 불평의 문으로 나간다.",
    "나의 행복을 위해, 때로는 이기적이어도 괜찮다.",
    "인생은 놀이터다. 실패를 두려워 말고, 신나게 놀아보자.",
    "나를 아프게 하는 과거와는, 오늘부로 작별하기로 했다.",
    "가장 큰 자유는, 내가 나 자신을 어떻게 생각하는지에 달려있다.",
    "행복은, 내가 세상에 어떤 의미를 부여하는가에 따라 결정된다.",
    "남들이 알아주지 않아도 괜찮아. 나는 나의 가치를 아니까.",
    "나는 내 삶의 가장 아름다운 풍경이다.",
    "인생은, '나'라는 사람을 알아가는 긴 여행이다.",
    "가장 큰 힘은, 긍정적인 생각이다. 생각의 힘을 믿어보자.",
    "행복은, 내가 가진 것에 만족하는 것이다. 욕심은 끝이 없다.",
    "나를 둘러싼 모든 평가는, 그들의 생각일 뿐 진실이 아니다.",
    "나는 오늘, 나에게 가장 친절한 사람이 되기로 했다.",
    "인생은, 지금 이 순간의 연속이다. 이 순간에 충실하자.",
    "가장 큰 용기는, 평범해질 용기다. 특별해야 한다는 강박을 버리자.",
    "행복은, 내가 웃을 때 내 주변도 함께 웃는 것이다.",
    "나를 괴롭히는 문제의 9할은, 내 마음이 만들어낸 것이다.",
    "나는 내 삶의 예술가. 매일매일 내 삶을 작품으로 만들어가자.",
    "인생은, 나 자신과 화해하는 과정이다.",
    "가장 큰 행복은, 사랑하고 사랑받는 것이다.",
    "나의 길은, 오직 나만이 만들 수 있다. 자신감을 갖자.",
    "나는 내 생각의 산물. 행복을 생각하면 행복해진다.",
    "인생은, 나에게 주어진 선물을 하나씩 풀어보는 과정이다.",
    "가장 큰 변화는, 나의 관점을 바꾸는 것이다.",
    "행복은, 작은 기쁨들을 자주 느끼는 것이다.",
    "나를 사랑하는 데에는, 어떤 조건도 이유도 필요 없다.",
    "나는 내 삶의 정답을 찾아가는 중이다. 조급해하지 말자.",
    "인생은, 나 자신을 찾아 떠나는 여행이다.",
    "가장 큰 용기는, 나의 불완전함을 사랑하는 용기다.",
    "행복은, '지금' 행복하지 않으면 '나중'에도 없다.",
    "나를 위한 삶을 살자. 남을 위한 삶은 결국 나를 잃게 만든다.",
    "나는 내 삶의 기적, 그 자체다.",
    ],
    eng: ["The weather is lovely today perfect for a nice walk.", "Start your morning fresh with a warm cup of coffee.", "Listening to your favorite music always lifts the spirits.", "A small smile can brighten up someone's entire day.", "Sometimes it's nice to just gaze at the clear blue sky.", "A good book can be a wonderful and loyal companion.", "You did a great job today have a restful evening.", "Learning something new is always an exciting endeavor.", "Enjoy a delicious dinner together with your family.", "How about sending a warm greeting to an old friend?", "All that glitters is not gold.", "To be or not to be that is the question.", "The woods are lovely dark and deep.", "Hope is the thing with feathers that perches in the soul.", "It was the best of times it was the worst of times.", "The only thing we have to fear is fear itself.", "Stay hungry. Stay foolish.", "I have a dream that one day this nation will rise up.", "Two roads diverged in a wood and I I took the one less traveled by.", "The journey of a thousand miles begins with a single step.", "Be the change that you wish to see in the world.", "Not all those who wander are lost.", "That which does not kill us makes us stronger.", "Ask not what your country can do for you ask what you can do for your country.", "The unexamined life is not worth living.", "Where there is love there is life.", "The quick brown fox jumps over the lazy dog.", "Pack my box with five dozen liquor jugs.", "Sphinx of black quartz judge my vow.", "Amazingly few discotheques provide jukeboxes.", "How vexingly quick daft zebras jump.", "Bright vixens jump dozy fowl quack.", "Quick wafting zephyrs vex bold Jim.", "Crazy Fredrick bought many very exquisite opal jewels.", "Hello how are you today?", "Thank you very much for your help.", "Pleased to meet you.", "Practice makes perfect.", "Have a wonderful day ahead.", "Good morning sunshine.", "Keep up the good work.", "See you later alligator.", "What a beautiful surprise.", "Actions speak louder than words."],
    korLong: [
        { title: "다락방의 햇살", content: `낡은 다락방 창문으로 스며드는 오후의 햇살은 먼지 쌓인 시간 위로 부드럽게 내려앉았다. 공기 중에는 오래된 책 냄새와 희미한 나무 향기가 뒤섞여, 마치 잊혀진 이야기들이 낮은 목소리로 속삭이는 듯했다. 빛줄기를 따라 부유하는 작은 먼지들은 금빛 가루처럼 반짝였고, 그 너머로 보이는 바깥세상은 한 폭의 수채화처럼 아련했다. 나는 삐걱이는 나무 계단을 밟고 올라와, 창가 낡은 흔들의자에 가만히 몸을 기댔다. 창밖으로 보이는 느티나무는 수백 년의 세월을 말없이 지켜온 듯, 바람이 불 때마다 잎사귀를 흔들며 낮은 노래를 불렀다. 그 풍경 속에서 나는 어린 시절의 기억들을 하나씩 꺼내보았다. 할머니가 들려주시던 옛날이야기, 친구들과 뛰놀던 골목길의 저녁노을, 처음으로 느껴본 설렘과 아픔. 모든 것이 희미한 필름처럼 머릿속을 스쳐 지나갔지만, 그 감정만큼은 여전히 선명하게 남아 가슴 한구석을 아릿하게 만들었다. 시간은 모든 것을 변화시키지만, 기억 속에 새겨진 온기는 영원히 변치 않는다는 것을, 나는 그 순간 깨달았다. 어쩌면 우리는 모두 마음속에 자신만의 작은 다락방을 가지고 살아가는지도 모른다. 힘들고 지칠 때마다 찾아가 위로받을 수 있는, 소중한 추억들이 잠들어 있는 비밀스러운 공간을.` },
        { title: "녹슨 철문과 이끼", content: `오래된 골목 끝, 굳게 닫힌 녹슨 철문 앞에 섰다. 한때는 누군가의 소중한 경계였을 이 문은 이제 시간의 무게에 굴복하여, 제 기능을 잃어버린 하나의 조형물처럼 보였다. 문틈으로 비집고 자라난 푸른 이끼는 잊힌 세월의 더께를 말없이 증명하고 있었다. 나는 차갑고 거친 철문에 가만히 손을 얹었다. 그 서늘한 감촉 위로, 희미하게 남아있는 어린 날의 온기가 느껴지는 듯했다. 시간은 모든 것을 풍화시키지만, 어떤 기억은 이끼처럼 끈질기게 살아남아 마음의 그늘진 곳에 뿌리내린다. 어쩌면 우리는 모두 기억의 포로일지도 모른다. 녹슨 철문 너머의 세계를 그리워하면서도, 끝내 그 문을 열지 못하는.` },
        { title: "새벽의 도서관", content: `새벽의 푸른빛이 거대한 서고의 창을 넘어올 때, 도서관은 비로소 온전한 침묵의 주인이 된다. 공기 중에는 낡은 종이와 마른 잉크, 그리고 수많은 지혜가 잠들며 내쉬는 희미한 숨결이 섞여 있었다. 나는 책등을 가만히 쓸어보았다. 모든 책은 하나의 세계였고, 닫힌 표지 너머에는 수많은 삶과 죽음, 사랑과 배신, 환희와 절망이 파도처럼 넘실거리고 있었다. 이 고요 속에서 나는 세상 모든 이야기의 무게에 짓눌리면서도, 동시에 그 이야기들로 인해 구원받는 기묘한 평온을 느꼈다. 책은 가장 안전한 피난처이자, 가장 위험한 미로이다. 우리는 그 속에서 길을 잃기도 하고, 새로운 길을 발견하기도 한다. 새벽의 도서관에서 나는 홀로 그 위대한 방황을 시작한다.` },
        { title: "항구의 마지막 뱃고동", content: `밤의 항구는 짙은 해무에 잠겨 있었다. 가로등 불빛은 흐릿한 원을 그리며 겨우 제자리를 지켰고, 축축한 공기 속에는 소금기와 기름 냄새가 뒤섞여 있었다. 저 멀리, 마지막 여객선이 긴 뱃고동을 울었다. 그 소리는 안개를 뚫고 나아가는 하나의 길이 되어, 떠나는 이의 결의와 남는 이의 아쉬움을 동시에 실어 날랐다. 나는 부두 끝에 서서, 희미해지는 선미의 불빛을 하염없이 바라보았다. 모든 떠나감은 남겨진 것들의 자리를 더욱 선명하게 만든다. 부재는 때로 존재보다 더 강력한 힘을 갖는다. 바다 냄새와 섞인 스산한 공기 속에서, 나는 수많은 이별의 순간들을 떠올렸다. 그것들은 사라지는 것이 아니라, 항구의 밤처럼 내 안에 고요히 가라앉아, 이따금씩 기억의 뱃고동을 울리곤 했다.` },
        { title: "유리병 속의 편지", content: `나는 해변을 거닐다 파도에 밀려온 작은 유리병을 발견했다. 병 안에는 낡은 양피지 조각이 희미하게 보였다. 떨리는 손으로 코르크 마개를 열자, 오래된 바다의 냄새와 함께 잊혀진 시간이 쏟아져 나왔다. 편지에는 알 수 없는 문자로 가득했지만, 그 글씨체에는 간절함과 그리움이 배어 있었다. 이것은 누구의 이야기일까. 머나먼 섬에서 보낸 구조 신호일까, 아니면 영원한 사랑을 맹세한 연인의 밀어일까. 나는 편지를 다시 병에 넣고, 더 먼 바다를 향해 힘껏 던졌다. 어떤 이야기는 영원히 읽히지 않을 때 가장 완벽한 법이다. 그것은 이제 나만의 비밀이 되었고, 저 망망대해를 떠도는 영원한 질문이 되었다. 세상에는 우리가 알 수 없는 수많은 이야기들이 파도처럼 밀려왔다 사라진다. 그저 그 찰나의 순간을 목격하는 것만으로도, 우리의 삶은 충분히 신비로워질 수 있다.` },
        { title: "밤하늘의 별", content: `깊은 밤, 창밖으로 무수한 별들이 보석처럼 쏟아질 듯 반짝였다. 나는 따뜻한 차 한 잔을 들고 창가에 서서, 끝없이 펼쳐진 밤하늘의 신비를 가만히 응시했다. 어둠이 짙을수록 별빛은 더욱 선명해졌고, 그 고요한 빛줄기는 내 마음속 깊은 곳까지 스며드는 듯했다. 저 멀리 이름 모를 별 하나가 유난히 밝게 빛나고 있었다. 마치 길 잃은 나그네에게 방향을 알려주는 등대처럼, 혹은 간절한 소망을 담아 하늘로 띄워 보낸 작은 등불처럼. 나는 그 별을 보며 어린 시절 순수했던 꿈들을 떠올렸다. 세상을 탐험하는 용감한 모험가, 사람들에게 감동을 주는 예술가, 밤하늘의 비밀을 푸는 천문학자. 현실의 벽에 부딪혀 하나둘씩 접어두었던 그 꿈들이, 별빛 아래에서 다시금 희미하게 살아나는 것을 느꼈다. 어쩌면 꿈이란, 완전히 사라지는 것이 아니라 잠시 우리 마음속 밤하늘에 숨어 반짝일 기회를 기다리는 별과 같은 것일지도 모른다. 중요한 것은 그 별빛을 잊지 않고, 언젠가 다시 그 빛을 따라 나아갈 용기를 내는 것이리라. 나는 마지막 한 모금의 차를 마시며, 내 마음속 별들을 향해 조용히 다짐했다. 아직 끝나지 않은 나의 이야기를 계속 써 내려가겠다고.` },
        { title: "아버지의 굳은살", content: `어릴 적, 나는 아버지의 손이 세상에서 가장 크고 단단하다고 믿었다. 기계 기름 냄새가 희미하게 배어 있고, 온통 굳은살과 상처로 뒤덮인 그 손은 나를 번쩍 안아 올리거나, 고장 난 장난감을 뚝딱 고쳐주곤 했다. 나는 그 손이 부끄러웠던 적이 없다. 오히려 나의 가장 든든한 방패이자 자랑이었다. 세월이 흘러 내 키가 아버지의 어깨를 훌쩍 넘고, 내 손이 아버지의 손만큼 커졌을 때, 나는 문득 깨달았다. 아버지의 그 굳은살은 단순한 시간의 흔적이 아니라, 한 가족의 무게를 온몸으로 버텨낸 성실한 역사의 지도였음을. 그 손은 단 한 번도 당신 자신을 위해 부드러웠던 적이 없었다. 서툰 사랑을 표현하느라, 더 좋은 것을 쥐여주려 애쓰느라, 위험한 것들로부터 우리를 지켜내느라 늘 거칠고 투박해야만 했다. 오늘 저녁, 무심코 소파에 잠든 아버지의 손을 보았다. 힘없이 놓인 그 손의 주름진 골짜기마다, 내가 미처 헤아리지 못했던 아버지의 청춘과 꿈, 그리고 수많은 새벽의 한숨이 고여 있는 듯했다. 나는 차마 그 손을 깨울 수 없어, 조용히 내 방으로 돌아와 소리 없이 울었다. 아버지는 단 한 번도 힘들다 말하지 않았지만, 그의 손은 평생에 걸쳐 울고 있었다.` },
        { title: "부치지 못할 편지", content: `잘 지내니? 이 흔한 안부를 묻기 위해 나는 수백 번 전화기를 들었다 놓았어. 우리의 마지막은 너무나 시시했지. 사소한 오해와 지쳐버린 마음, 그리고 돌아설 용기만 남았던 그날. 우리는 서로에게 가장 날카로운 칼날이 되어 상처를 후벼 팠고, 다시는 보지 않을 사람처럼 매몰차게 돌아섰다. 시간이 모든 걸 해결해 줄 거라 믿었는데, 그건 오만이었나 봐. 너 없는 시간 속에서 나는 종종 길을 잃는다. 기가 막히게 웃긴 이야기를 들었을 때, 울고 싶은 영화를 봤을 때, 문득 맛있는 음식을 먹었을 때, 나는 나도 모르게 너에게 말해주려고 핸드폰을 찾는다. 네가 좋아하던 노래가 카페에서 흘러나올 때면, 심장이 쿵 내려앉는 기분이야. 미안하다는 말, 그 한마디가 목구멍에 걸려 나오지 않아 이 모든 시간을 허비했네. 사실은 네가 너무 보고 싶어. 우리가 함께 웃고 떠들던, 세상에 무서울 것 하나 없던 그 시절이 사무치게 그리워. 이 편지는 결국 너에게 닿지 못하겠지만, 오늘 밤 나는 너를 위해 기도할게. 부디 아프지 말고, 좋은 사람 곁에서 많이 웃으며 행복하라고. 그리고 아주 먼 훗날, 우리가 우연히 길에서 마주친다면, 그땐 그냥 웃으며 안부 정도는 물을 수 있는 사이이기를.` },
        { title: "나에게 쓰는 위로", content: `애썼다, 정말. 오늘 하루도 살아내느라 고생 많았지. 아무도 알아주지 않는 자리에서 묵묵히 버텨내고, 괜찮지 않으면서 괜찮은 척 웃어 보이고, 수없이 밀려오는 불안과 싸우느라 얼마나 힘들었니. 때로는 세상에 나 혼자만 남겨진 기분이 들었을 테고, 모두가 나를 비웃는 것 같은 자격지심에 괴로웠을 거야. 정답 없는 인생이라는 시험지 앞에서, 어떤 답을 써야 할지 몰라 막막했을 테지. 넘어져도 일으켜 줄 사람 하나 없는 텅 빈 길 위에서, 혼자 무릎을 털고 일어나야 했을 때, 얼마나 서러웠니. 괜찮아. 이제 괜찮아. 오늘만큼은 애써 강한 척하지 않아도 돼. 남의 시선 따위 신경 쓰지 말고, 그냥 너의 아픔을 가만히 들여다봐 주렴. 눈물이 나면 실컷 울어도 좋아. 네 눈물은 약함의 증거가 아니라, 그동안 최선을 다해 버텨왔다는 숭고한 훈장이니까. 잘하고 있는지 의심하지 마. 너는 너의 속도로, 너만의 방식으로 아주 잘 걸어가고 있어. 그러니 오늘 밤은 부디, 아무 걱정 없이 편안히 잠들기를. 내일의 너는, 오늘의 너보다 분명 조금 더 단단해져 있을 테니까. 정말이야. 내가 알아.` },
        { title: "어느 퇴근길의 풍경", content: `만원 지하철, 나는 퀴퀴한 공기와 사람들의 지친 숨결이 뒤섞인 객차 구석에 서 있었다. 저마다 다른 얼굴을 하고 있지만, 그들의 표정에는 공통적으로 '고단함'이라는 단어가 새겨져 있었다. 꾸벅꾸벅 조는 중년의 남자, 멍하니 스마트폰 화면만 들여다보는 젊은 여자, 가방을 꼭 껴안은 채 창밖 어둠을 응시하는 학생. 그들은 모두 오늘 하루라는 전쟁터에서 살아남아, 이제 각자의 휴식처로 돌아가는 중이었다. 문득, 그들 각자의 삶이 궁금해졌다. 저 남자는 오늘 회사에서 어떤 힘든 일이 있었을까. 저 여자는 지금 누구와 메시지를 주고받으며 위로를 얻고 있을까. 저 학생은 어떤 꿈을 꾸고, 또 어떤 불안에 시달리고 있을까. 우리는 서로의 이름도, 사연도 모른 채 그저 같은 공간, 같은 시간을 스쳐 지나가는 익명의 존재들이다. 하지만 이 순간, 나는 그들과 보이지 않는 끈으로 연결되어 있다는 기묘한 동질감을 느꼈다. 모두가 비슷한 무게의 삶을 짊어지고, 비슷한 고민을 안고, 비슷한 내일을 향해 나아가고 있다는 막연한 위로. 우리는 모두 외로운 섬처럼 보이지만, 사실은 거대한 바다 아래에서 서로 연결된 대륙일지도 모른다. 지하철이 멈추고 사람들이 썰물처럼 빠져나갔다. 그 텅 빈 자리들을 보며, 나는 오늘 밤 저 모든 지친 영혼들이 부디 편안한 꿈을 꾸기를 조용히 기도했다.` },
        { title: "엄마의 부엌", content: `친정집에 오면 나는 으레 부엌으로 먼저 향한다. 엄마의 부엌은 단순한 요리 공간이 아니다. 그곳은 우리 가족의 역사가 켜켜이 쌓여 있는 심장과 같은 곳이다. 닳아빠진 행주에서는 엄마의 부지런함이, 칼자국 가득한 낡은 도마에서는 수십 년의 세월이, 보글보글 끓는 된장찌개에서는 변치 않는 사랑의 냄새가 난다. 엄마는 늘 그랬다. 말보다는 음식으로 당신의 마음을 표현했다. 속상한 날이면 내가 좋아하는 김치찌개를 끓여주셨고, 기쁜 날이면 온 가족이 둘러앉아 먹을 갈비찜을 재웠다. 내가 입맛이 없다 하면, 당신은 온갖 산해진미를 걱정하며 내 입에 넣어주려 애썼다. 나는 그 음식을 먹으며 위로받고, 사랑받고, 다시 살아갈 힘을 얻었다. 이제 와 생각해 보니, 엄마는 당신의 청춘과 꿈을 그 작은 부엌의 불 위에 올려놓고, 우리를 위해 꼬박 밤을 새워 고아내셨던 것이다. 오늘, 엄마는 여느 때처럼 내 밥그릇 위에 가장 맛있는 반찬을 올려주신다. 주름진 손으로 내 등을 툭 치며 '많이 먹어라, 내 새끼' 하시는 그 무심한 한마디에, 나는 뜨거운 밥알과 함께 울컥 눈물을 삼켰다. 세상 모든 위대한 레시피는, 결국 '엄마의 손맛'이라는 여섯 글자로 귀결된다는 것을, 나는 오늘 또 한 번 깨닫는다.` },
        { title: "아들아, 너의 길을 가렴", content: `네가 처음으로 뒤집기를 했을 때, 나는 세상을 다 얻은 듯 기뻤단다. 첫 걸음마를 떼었을 때, 아빠의 손을 놓치는 네가 넘어질까 봐 조마조마하면서도 대견했지. 그렇게 너는 언제나 나의 세상이었고, 나의 자랑이었다. 그런데 아들아, 어느 순간부터 나는 너에게 나의 욕심을 강요하고 있었더구나. 남들보다 더 빨리, 더 높이, 더 멀리 가기를 바랐다. 네가 걷는 길이 좁고 험할까 봐, 미리 평탄한 길을 닦아주려 애썼지. 하지만 그것이 오히려 너를 너답지 못하게 만드는 족쇄가 될 수 있다는 걸, 이제야 조금 알 것 같다. 세상에는 수많은 길이 있단다. 어떤 길은 넓고 화려하지만, 어떤 길은 좁고 소박하지. 어떤 길은 많은 사람들이 함께 가지만, 어떤 길은 오롯이 혼자 걸어가야 한단다. 정답은 없어. 중요한 것은, 누가 정해준 길이 아니라 네 마음이 이끄는 길을, 네 발로 직접 걸어가는 것이란다. 넘어져도 괜찮다. 잠시 쉬어가도 괜찮고, 조금 돌아가도 괜찮아. 그 모든 것이 너의 인생을 더 풍요롭게 만드는 소중한 경험이 될 테니까. 아빠는 이제 너의 뒤에서 한 걸음 물러나, 그저 묵묵히 너를 응원하려 한다. 그러니 아들아, 두려워 말고 너의 길을 가렴. 너는 네가 생각하는 것보다 훨씬 더 강하고 지혜로운 아이란다.` },
        { title: "우리가 잃어버린 것", content: `친구야. 우리는 언제부터 이렇게 말이 없어졌을까. 한때 우리는 밤을 새워가며 시시콜콜한 이야기를 나누고, 서로의 꿈을 응원하며, 세상의 모든 부조리에 함께 분노했었지. 가진 것은 없었지만, 서로가 있기에 두려울 것이 없었다. 그런데 지금의 우리는 어떤가. 약속이라도 한 듯, ‘사는 게 바빠서’라는 편리한 핑계 뒤에 숨어 서로의 안부를 묻는 것조차 머뭇거린다. 가끔 만나는 자리에서는, 약속이나 한 듯 힘든 이야기는 삼키고 적당히 괜찮은 척 웃으며, 각자의 갑옷이 얼마나 단단한지 자랑하기에 바쁘다. 어쩌면 우리는 어른이 되는 과정에서, 가장 소중한 것을 잃어버린 건지도 모르겠다. 솔직하게 내 약점을 드러낼 용기, 남의 아픔에 진심으로 공감하는 능력, 그리고 비록 닿지 못할지라도 별을 향해 손을 뻗던 순수한 열정 같은 것들 말이다. 친구야. 오늘 밤, 나는 네가 그립다. 성공한 너의 모습이 아니라, 서툴고 불안했지만 누구보다 뜨거웠던 그 시절의 네가 그립다. 만약 네가 지금 어딘가에서 혼자 아파하고 있다면, 제발 혼자 끙끙 앓지 마라. 우리, 예전처럼 그냥 아무 말 없이 술 한잔 기울이자. 내가 너의 무거운 짐을 다 들어줄 수는 없겠지만, 잠시 내려놓고 쉴 수 있는 어깨 정도는 되어줄 수 있으니.` },
        { title: "빈자리", content: `당신이 떠나고, 나는 한동안 집 안의 모든 물건을 그대로 두었다. 당신이 마시다 남긴 찻잔, 소파 위에 아무렇게나 벗어둔 스웨터, 침대 머리맡에 놓인 읽다 만 책까지. 마치 금방이라도 당신이 현관문을 열고 들어와 "다녀왔어" 하고 말할 것만 같았다. 그것들은 더 이상 단순한 사물이 아니라, 당신의 부재를 증명하는 고통스러운 증거였다. 나는 그 물건들을 치울 용기가 나지 않아, 집 안 곳곳에 박제된 당신의 흔적과 함께 살았다. 하지만 시간은 무심했고, 찻잔에는 먼지가 쌓이고 스웨터에서는 당신의 향기가 사라져갔다. 나는 비로소 깨달았다. 붙잡고 있는 것은 당신이 아니라, 당신을 잃어버린 나 자신이라는 것을. 어느 맑은 날, 나는 큰마음을 먹고 당신의 물건들을 정리하기 시작했다. 하나씩 상자에 담을 때마다, 당신과 함께했던 기억들이 파도처럼 밀려와 숨이 막혔다. 울고 또 울었다. 하지만 마지막 상자의 테이프를 붙였을 때, 나는 이상한 해방감을 느꼈다. 빈자리는 여전히 아프고 시렸지만, 그 텅 빈 공간에 이제는 새로운 햇살이 들어올 수 있을 것 같았다. 이별은 끝이 아니라, 남겨진 사람이 슬픔을 딛고 자신의 삶을 계속 살아내야 하는 길고 긴 과정이었다. 나는 이제, 당신 없는 세상에서 홀로 걷는 법을 배워야만 한다.` },
        { title: "가면 뒤의 얼굴", content: `나는 매일 아침 거울 앞에서 가면을 쓴다. ‘쾌활함’이라는 가면, ‘유능함’이라는 가면, ‘친절함’이라는 가면. 상황에 따라, 만나는 사람에 따라 능숙하게 가면을 바꿔 쓰며 하루를 연기한다. 사람들은 가면 뒤의 내 진짜 얼굴을 궁금해하지 않는다. 그들은 내가 보여주는 역할에 만족하고, 나 역시 그들의 기대를 저버리지 않기 위해 최선을 다해 연기한다. 그렇게 하루의 연극이 끝나고, 지친 몸을 이끌고 텅 빈 집에 돌아와 가면을 벗는 순간, 나는 지독한 공허함과 마주한다. 거울 속에 비친 것은 누구일까. 저 낯설고 피곤에 절은 얼굴은, 수많은 가면 뒤에 숨어 정체를 잃어버린 진짜 ‘나’일까. 때로는 나조차도 내가 누구인지 모르겠다. 내가 진짜로 원하는 것은 무엇인지, 내가 느끼는 이 감정이 진짜 내 것인지조차 헷갈린다. 어쩌면 나는, 타인의 인정과 사랑을 받기 위해 스스로를 기만하는 겁쟁이일 뿐인지도 모른다. 오늘 밤, 나는 거울 속 나에게 조용히 묻는다. 이 가면들을 모두 벗어던져도, 누군가 나를 사랑해 줄까. 아니, 그보다 먼저, 있는 그대로의 내 모습을 나 자신은 사랑해 줄 수 있을까. 대답 없는 질문만이, 텅 빈 방 안을 무겁게 떠다닌다.` },
        { title: "할머니의 뜨개질", content: `할머니는 늘 툇마루에 앉아 뜨개질을 하셨다. 햇살 좋은 날에도, 비가 오는 날에도, 할머니의 무릎 위에서는 알록달록한 털실이 춤을 추었고, 낡은 나무 바늘은 규칙적인 소리를 내며 쉼 없이 움직였다. 어린 나는 그 모습이 신기하면서도 조금은 지루하다고 생각했다. 할머니는 그 지루한 일을 왜 매일 반복하시는 걸까. 세월이 한참 흐른 뒤에야 나는 깨달았다. 할머니의 뜨개질은 단순한 손일이 아니라, 당신의 삶을 엮어내는 신성한 의식이었다는 것을. 한 코 한 코, 실을 엮어나가는 그 손길에는 가족을 향한 사랑과 걱정, 지나온 세월에 대한 회한, 그리고 다가올 날들에 대한 조용한 기도가 담겨 있었다. 잘못 뜬 코는 과감히 풀어내 다시 시작하고, 엉킨 실타래는 인내심을 갖고 천천히 풀어내는 모습 속에서, 나는 삶을 대하는 할머니의 지혜를 엿보았다. 할머니가 떠나신 후, 유품을 정리하다 낡은 반짇고리 안에서 미처 완성되지 못한 작은 아기 신발 한 짝을 발견했다. 아마 곧 태어날 증손주를 위해 준비하셨던 것이리라. 나는 그 작은 신발을 손에 들고 한참을 울었다. 할머니는 비록 떠나셨지만, 당신이 남긴 따뜻한 사랑의 매듭은 남아있는 우리들의 마음속에서 영원히 풀리지 않을 것이다.` },
        { title: "도시의 섬", content: `나는 수백만 명이 살아가는 이 거대한 도시의 작은 섬이다. 매일 아침, 나는 만원 지하철이라는 거대한 강물에 휩쓸려 이름 모를 섬들 사이를 부유한다. 우리는 어깨를 스치고, 눈빛을 교환하고, 서로의 숨결을 느끼지만, 누구도 서로에게 말을 걸지 않는다. 각자의 귀에는 이어폰이 꽂혀 있고, 각자의 눈은 스마트폰 화면에 고정되어 있다. 우리는 연결되어 있지만, 철저히 단절되어 있다. 때로는 이 고독이 편안하게 느껴지기도 한다. 누구의 간섭도 받지 않고, 오롯이 나만의 생각에 잠길 수 있는 익명의 자유. 하지만 때로는, 이 견딜 수 없는 외로움에 숨이 막힐 것 같다. 누군가 내 이름을 다정하게 불러주었으면, 내 지친 어깨를 말없이 토닥여주었으면, 내 시시한 농담에 환하게 웃어주었으면 좋겠다. 오늘 밤, 나는 내 작은 섬의 창가에 서서, 건너편 아파트의 불빛들을 바라본다. 저 수많은 불빛 아래, 또 다른 섬들이 각자의 외로움을 견디고 있겠지. 어쩌면 우리는 모두, 서로를 그리워하며 밤새 희미한 빛을 깜빡이는 등대 같은 존재들인지도 모른다. 언젠가 짙은 안개가 걷히고, 우리가 서로의 존재를 발견하고, 따뜻한 인사를 나눌 수 있는 날이 올까. 나는 그 희망 하나로, 이 도시의 외로운 밤을 견뎌낸다.` },
        { title: "오래된 약속", content: `열일곱 살 여름, 우리는 낡은 방파제에 나란히 앉아 바다를 보았다. 끈적한 바닷바람이 머리카락을 흩날렸고, 부서지는 파도 소리가 귀를 간지럽혔다. 너는 내게 말했지. 십 년 뒤 오늘, 바로 이 자리에서 다시 만나자고. 성공하지 못해도 좋고, 초라한 모습이어도 좋으니, 그냥 살아남아서 다시 만나 웃자고. 그 유치하고 낭만적인 약속이, 나는 세상 그 어떤 맹세보다 진지하게 들렸다. 그 후, 우리는 각자의 길을 걸었다. 대학에 가고, 군대에 가고, 취직을 하고, 사랑을 하고, 이별을 했다. 삶의 파도는 생각보다 거셌고, 우리는 살아남기 위해 발버둥 쳐야 했다. 서로의 소식은 점점 뜸해졌고, 어느새 그 여름의 약속은 희미한 기억의 파편으로만 남았다. 그리고 오늘, 약속의 그날이 되었다. 나는 반신반의하며 낡은 방파제를 찾았다. 네가 있을 리 없다고 생각하면서도, 혹시나 하는 마음에 심장이 두근거렸다. 방파제 끝에는, 십 년의 세월을 정통으로 맞은 듯 희끗한 머리와 지친 얼굴을 한 네가, 바다를 보며 서 있었다. 너는 나를 보고, 어색하게 웃으며 말했다. '많이 늦었네.' 그 한마디에, 지나온 십 년의 세월이 눈물처럼 터져 나왔다. 우리는 아무 말 없이, 열일곱의 우리처럼 나란히 앉아 한참 동안 바다만 보았다. 성공하지도, 특별해지지도 못했지만, 우리는 살아남아 약속을 지켰다. 그것만으로도, 우리의 삶은 충분히 의미 있었다.` },
        { title: "꿈의 잔해", content: `내 방 한구석에는 먼지 쌓인 기타가 세워져 있다. 한때 나는 그 기타로 세상을 노래하는 가수가 되리라 믿었다. 굳은살이 박이도록 코드를 잡고, 밤을 새워가며 멜로디를 만들었다. 내 노래가 누군가의 마음을 울리고, 세상을 조금이라도 더 아름답게 만들 수 있을 거라는 풋내 나는 이상을 품고 있었다. 하지만 현실의 벽은 높고 단단했다. 재능의 한계, 냉혹한 평가, 그리고 먹고사는 문제 앞에서 나의 꿈은 서서히 빛을 잃어갔다. 나는 결국 기타를 내려놓고, 평범한 직장인이 되었다. 아침이면 지옥철에 몸을 싣고, 하루 종일 컴퓨터 모니터 앞에서 의미 없는 숫들과 씨름하고, 지친 몸으로 퇴근하는 삶. 이것이 내가 원했던 삶일까. 가끔, 회식 자리에서 억지로 노래를 부를 때면 씁쓸한 기분이 든다. 노래는 더 이상 나의 꿈이 아니라, 사회생활을 위한 하나의 도구가 되어버렸다. 오늘, 나는 아주 오랜만에 기타를 꺼내 조율했다. 서툰 손가락으로 예전에 썼던 노래를 연주해 보았다. 멜로디는 엉성했고 목소리는 갈라졌지만, 그 순간만큼은 잊고 있던 내 안의 불씨가 다시 타오르는 것을 느꼈다. 꿈을 이루지 못했다고 해서, 그 꿈이 실패한 것은 아닐 것이다. 그것은 내 청춘의 가장 뜨거운 한 페이지로 남아, 무미건조한 내 삶을 이따금씩 반짝이게 해주는 소중한 잔해이니까.` },
        { title: "마지막 기회", content: `의사 선생님은 담담한 목소리로, 남은 시간이 많지 않다고 말했다. 병원 복도를 걸어 나오는데, 환한 형광등 불빛이 유난히 눈이 부셨다. 이상하게도 눈물이 나지 않았다. 그저 머릿속이 하얗게 비어버린 듯, 아무 생각도 들지 않았다. 평생을 앞만 보고 달려왔다. 더 좋은 학교, 더 좋은 직장, 더 넓은 아파트. 남들보다 뒤처지지 않기 위해, 인정받기 위해, 나는 나 자신을 끊임없이 채찍질했다. 정작 소중한 것들은 모두 '나중'으로 미뤄둔 채. 사랑하는 아내와 눈을 맞추며 대화하는 시간, 아이가 커가는 모습을 가만히 지켜보는 여유, 궂은 날에도 묵묵히 곁을 지켜준 친구에게 고맙다는 말을 전하는 일까지. 나는 늘 바쁘다는 핑계로 그 모든 것을 외면했다. 이제 와서 후회한들 무슨 소용이 있을까. 집으로 돌아오는 길, 나는 평소와 다른 길로 걸었다. 작은 공원에 들러 아이처럼 그네를 탔고, 길모퉁이 꽃집에서 아내를 닮은 프리지아 꽃 한 다발을 샀다. 하늘은 놀랍도록 푸르렀고, 바람은 상쾌했다. 나는 비로소 깨달았다. 신이 내게 주신 이 마지막 시간은, 절망하라고 준 것이 아니라, 미처 하지 못했던 것들을 할 수 있는 마지막 기회라는 것을. 이제 나는 남은 시간 동안, 미뤄두었던 사랑을 표현하고, 소홀했던 관계를 돌보고, 진심으로 감사하는 법을 배울 것이다. 나의 마지막 페이지는, 비극이 아니라 가장 따뜻하고 아름다운 이야기로 채워질 것이다.` },
        { title: "거울 앞에서", content: `샤워를 마치고, 김이 서린 욕실 거울을 손으로 닦아냈다. 흐릿한 형체 너머로, 낯선 여자의 모습이 드러났다. 눈가에 옅게 자리 잡은 주름, 조금씩 탄력을 잃어가는 피부, 희끗희끗 존재감을 드러내는 흰머리 몇 가닥. 나는 언제 이렇게 나이를 먹었을까. 불과 몇 년 전까지만 해도, 나는 영원히 스물다섯의 청춘으로 머물 줄 알았다. 밤을 새워도 지치지 않는 체력과 무엇이든 할 수 있다는 근거 없는 자신감으로 충만했던 시절. 하지만 시간은 공평했고, 내 몸과 얼굴에 정직하게 그 흔적을 새겨놓았다. 문득 서글픈 마음이 들었다. 잃어버린 젊음이 아쉬워서, 혹은 다가올 늙음이 두려워서. 하지만 나는 거울 속 나를 좀 더 찬찬히 들여다보았다. 저 눈가의 주름은, 내가 얼마나 많이 웃었는지를 보여주는 훈장이 아닐까. 저 거칠어진 손은, 내가 얼마나 열심히 내 삶을 일구어왔는지를 증명하는 상장이 아닐까. 나는 더 이상 젊고 예쁘지는 않지만, 대신 세상을 바라보는 지혜와 작은 일에 감사하는 여유를 얻었다. 나이 듦은 잃어가는 과정이 아니라, 다른 것들로 채워지는 과정인지도 모른다. 나는 거울 속 나에게, 희미하게 미소 지어 보였다. '그동안 고생 많았어. 지금의 너도, 꽤 괜찮아.'라고 속삭여주면서.` },
        { title: "익숙함에 속아", content: `여보, 우리 결혼한 지 벌써 15년이 지났네요. 처음 당신을 만났을 때, 나는 당신의 모든 것이 궁금했어요. 어떤 음식을 좋아하고, 어떤 음악을 듣고, 슬플 땐 어떻게 우는지. 당신의 사소한 습관 하나하나가 나에게는 사랑의 언어처럼 느껴졌죠. 하지만 언제부터였을까요. 우리는 서로에게 너무나 익숙해져 버렸고, 그 익숙함은 설렘 대신 무관심을 낳았어요. 우리는 더 이상 서로의 하루를 궁금해하지 않고, 고맙다는 말과 사랑한다는 표현에 인색해졌죠. 함께 있지만, 각자의 스마트폰만 들여다보는 침묵의 시간이 더 길어졌어요. 나는 가끔, 우리가 정말 사랑해서 함께 사는 건지, 아니면 그저 오래된 습관과 책임감 때문에 함께 사는 건지 헷갈릴 때가 있어요. 오늘, 당신이 잠든 얼굴을 가만히 들여다보았어요. 피곤에 지친 얼굴, 미간에 잡힌 옅은 주름. 그 얼굴에서, 지난 15년간 나와 우리 가정을 위해 애써온 당신의 고단한 세월이 보였어요. 미안한 마음에 코끝이 찡해졌어요. 여보, 우리, 익숙함에 속아 소중함을 잊지는 말아요. 내일 아침, 내가 먼저 당신에게 물어볼게요. 어젯밤 좋은 꿈 꿨냐고, 오늘 아침 커피는 내가 타주겠다고. 우리, 다시 처음처럼, 서로를 궁금해하고, 아껴주고, 사랑하기로 해요. 아직 늦지 않았겠죠?` },
        { title: "나는 잘 될 거야", content: `오늘도 면접에서 떨어졌다. 벌써 열두 번째다. 면접관의 무미건조한 표정과 날카로운 질문들이, 비수처럼 가슴에 박혔다. 집으로 돌아오는 버스 안에서, 나는 차창에 비친 내 초라한 모습을 보았다. '나는 왜 이것밖에 안 될까.' 자괴감이 온몸을 휘감았다. SNS를 켜니, 친구들은 다들 제자리를 찾아 잘나가는 것만 같다. 해외여행 사진, 승진 축하 파티, 명품 가방 선물. 그들의 반짝이는 세상 속에서, 나만 홀로 어두운 터널에 갇혀 있는 기분이었다. 방에 돌아와 불도 켜지 않은 채, 침대에 쓰러지듯 누웠다. 이대로 모든 걸 포기하고 싶었다. 그때, 어디선가 엄마의 목소리가 들리는 듯했다. '우리 딸, 괜찮아. 넌 잘 될 거야. 엄마는 믿어.' 근거 없는 믿음, 맹목적인 사랑. 하지만 그 목소리가, 바닥까지 떨어진 나를 일으켜 세우는 마지막 동아줄이 되었다. 나는 눈물을 닦고, 벌떡 일어나 책상 앞에 앉았다. 그리고 낡은 다이어리 첫 장에, 삐뚤빼뚤한 글씨로 적었다. '나는 잘 될 거야. 나는 잘 될 거야. 나는 잘 될 거야.' 이것은 주문이다. 나 자신에게 거는 마지막 마법이다. 세상이 다 나를 외면해도, 나만큼은 나를 믿어주기로 했다. 내일 아침, 나는 열세 번째 이력서를 쓸 것이다. 터널의 끝이 보이지 않아도 괜찮다. 나는 그저, 오늘 하루치 걸음을 묵묵히 걸어갈 뿐이다.` },
        { title: "어느 비 오는 날의 단상", content: `비가 내린다. 창밖은 온통 잿빛이고, 빗방울은 리드미컬하게 유리창을 두드린다. 나는 이런 날이면, 모든 약속을 취소하고 방 안에 틀어박혀 있는 것을 좋아한다. 따뜻한 커피 한 잔을 내리고, 오래된 재즈 음반을 틀고, 푹신한 소파에 몸을 묻는다. 비 오는 날의 공기에는 특별한 냄새가 있다. 젖은 흙냄새와 아스팔트 냄새, 그리고 도시의 먼지가 씻겨 내려간 상쾌함. 그 냄새는 나를 차분하게 만들고, 복잡했던 마음을 정돈해 준다. 빗소리를 듣고 있으면, 굳이 애쓰지 않아도 괜찮다고, 잠시 쉬어가도 괜찮다고, 세상이 나를 위로해 주는 것만 같다. 우리는 늘 너무 많은 것을 하려고 애쓰며 살아간다. 더 빨리 달려야 하고, 더 높이 올라야 하고, 더 많이 가져야 한다고. 하지만 가끔은 이렇게, 아무것도 하지 않고 그저 가만히 머무르는 시간이 필요하다. 빗소리에 귀 기울이며, 내 마음의 소리를 듣는 시간. 잊고 있던 기억을 떠올리고, 소원했던 사람에게 안부를 묻고, 나 자신을 가만히 다독여주는 시간. 비는 언젠가 그치겠지만, 이 비가 내 마음에 남긴 촉촉한 위안은 한동안 나를 지탱해 줄 것이다. 그리고 비가 갠 뒤의 하늘이 더 맑고 투명하듯, 나의 내일도 오늘보다 한 뼘 더 단단하고 맑아져 있을 것이라 믿는다.` },
        { title: "선택하지 않은 길", content: `나는 가끔, 내가 선택하지 않은 길을 상상해 본다. 만약 그때, 그 사람의 손을 놓지 않았더라면. 만약 그때, 안정적인 직장 대신 꿈을 좇았더라면. 만약 그때, 다른 도시로 떠나기로 결심했더라면. 지금의 나는 어떤 모습으로, 어디에서, 누구와 함께 살고 있을까. 그 길은 왠지 지금 내가 걷고 있는 길보다 더 아름답고 행복했을 것만 같다. 후회라는 이름의 잿빛 안개가, 내가 가지 않은 길을 신비롭게 포장하기 때문이다. 하지만 정말 그럴까. 그 길 위에도 분명 나름의 고통과 시련, 그리고 또 다른 후회가 존재했을 것이다. 어떤 길을 선택하든, 우리는 가지 않은 길에 대한 미련을 품고 살아가는 불완전한 존재일 뿐이다. 중요한 것은, 내가 선택한 길을 '나의 길'로 만들어가는 과정이다. 비록 그 길이 때로는 자갈밭이고, 때로는 낭떠러지일지라도, 그 위에서 만나는 작은 들꽃 한 송이에 감사하고, 함께 걷는 사람의 온기에 의지하며, 묵묵히 내 발자국을 새겨나가는 것. 그것이 바로 '삶'이라는 이름의 여행이 아닐까. 나는 더 이상 가지 않은 길을 돌아보며 한숨 쉬지 않기로 했다. 대신, 지금 내가 서 있는 이 길을 사랑하고, 이 길 위에서 만나는 모든 순간을 소중히 여기기로 했다. 나의 길은, 내가 걸어감으로써 비로소 완성될 테니까.` },
        { title: "그저, 안아주세요", content: `엄마, 저 너무 힘들어요. 이 한마디를 하기까지, 저는 얼마나 많은 밤을 혼자 울었는지 몰라요. 저는 엄마의 자랑스러운 딸이고 싶었어요. 늘 씩씩하고, 뭐든지 잘 해내고, 절대 약한 모습을 보이지 않는. 그래서 힘들어도 안 힘든 척, 아파도 안 아픈 척, 괜찮지 않아도 괜찮은 척, 그렇게 저를 속이며 살아왔어요. 하지만 엄마, 저 이제 더는 못하겠어요. 제 마음의 그릇은 이미 금이 가고 깨져서, 더 이상 아무것도 담아낼 수가 없어요. 저에게 '힘내라', '이겨내라', '너는 할 수 있다'고 말하지 말아 주세요. 그 응원의 말들이, 지금 저에게는 더 잘해야 한다는 채찍질처럼 들려요. '무엇이 힘드냐'고, '왜 그러냐'고 묻지도 말아 주세요. 제 아픔을 조리 있게 설명할 힘조차 남아있지 않아요. 그냥, 아무 말 없이 저를 한 번만 꼭 안아주세요. 제가 어릴 적, 넘어져 무릎이 깨져 울고 있을 때 엄마가 그랬던 것처럼. '우리 딸, 많이 아팠지. 괜찮아, 엄마가 있잖아.' 그 따뜻한 품 안에서, 저는 아마 어린아이처럼 서럽게 울어버릴지도 몰라요. 하지만 그렇게 실컷 울고 나면, 깨진 마음의 조각들을 다시 붙일 수 있는 작은 힘이 생길지도 몰라요. 엄마, 그냥, 저를 좀 안아주세요.` },
        { title: "새벽 호숫가", content: `이른 새벽, 안개가 자욱한 호숫가를 홀로 걸었다. 물안개는 마치 살아있는 생명체처럼 부드럽게 수면 위를 감돌았고, 멀리 보이는 산자락은 희미한 먹빛 그림자처럼 느껴졌다. 세상의 모든 소음이 잠든 듯, 오직 내 발걸음 소리와 이따금 들려오는 물새 소리만이 적막을 깨뜨렸다. 차가운 새벽 공기가 코끝을 스치자 정신이 맑아지는 기분이었다. 나는 호숫가 작은 벤치에 앉아, 서서히 밝아오는 동쪽 하늘을 바라보았다. 안개 너머로 붉은 기운이 조금씩 번지기 시작하더니, 이윽고 장엄한 해가 그 모습을 드러냈다. 떠오르는 태양은 밤새 호수를 뒤덮었던 안개를 부드럽게 걷어내었고, 그 아래 숨겨져 있던 맑고 투명한 호수의 민낯이 햇살 아래 눈부시게 반짝였다. 그 순간, 나는 마치 새로운 세상이 열리는 듯한 경이로움을 느꼈다. 어둠과 혼돈 속에서도 희망은 언제나 그렇게 떠오르는 것이라고, 자연은 말없이 가르쳐주는 듯했다. 삶이 때로 짙은 안개 속에 갇힌 것처럼 느껴질 때도 있겠지만, 그 안개 너머에는 분명 찬란한 아침이 기다리고 있음을, 그리고 그 아침을 맞이하기 위해서는 묵묵히 자신의 길을 걸어가야 함을, 나는 새벽 호숫가에서 깨달았다. 해가 완전히 떠오르자, 호수는 금빛으로 물들었고, 나는 새로운 하루를 시작할 용기를 얻어 다시 발걸음을 옮겼다.` },
        { title: "담쟁이덩굴", content: `오래된 골목길 모퉁이를 돌자, 담벼락에 기대어 자라는 작은 담쟁이덩굴이 눈에 들어왔다. 거친 시멘트 벽을 가느다란 줄기로 힘겹게 부여잡고, 초록빛 잎사귀들을 햇살을 향해 힘껏 펼치고 있는 모습이었다. 그 작은 생명체의 강인함 앞에서 나는 잠시 발걸음을 멈추었다. 척박한 환경 속에서도 포기하지 않고, 자신의 자리를 묵묵히 지키며 생명의 푸르름을 피워내는 그 모습이 경이롭게 느껴졌다. 어쩌면 우리의 삶도 저 담쟁이덩굴과 크게 다르지 않을지도 모른다. 때로는 거칠고 힘겨운 현실이라는 벽에 부딪히고, 예상치 못한 시련의 바람에 흔들리기도 하지만, 그럼에도 불구하고 우리는 어떻게든 살아남아 자신의 이야기를 써 내려간다. 마음속 깊은 곳에 간직한 작은 희망의 씨앗을 붙들고, 한 뼘이라도 더 햇살을 향해 나아가려 애쓰면서 말이다. 담쟁이덩굴은 화려한 꽃을 피우거나 달콤한 열매를 맺지는 않지만, 그 자체로 충분히 아름답고 의미 있는 존재였다. 그것은 우리에게 말없이 가르쳐주고 있었다. 삶의 가치는 결과에만 있는 것이 아니라, 그 과정을 묵묵히 견뎌내고 자신의 자리에서 최선을 다하는 그 모든 순간에 깃들어 있다는 것을. 나는 작은 담쟁이덩굴에게서 큰 위로와 용기를 얻고, 다시금 내 삶의 담벼락을 향해 한 걸음 내디뎠다.` },
        { title: "기차를 기다리며", content: `늦은 오후, 텅 빈 기차역 플랫폼에 홀로 앉아 곧 떠나갈 기차를 기다렸다. 하늘에는 회색빛 구름이 낮게 드리워져 있었고, 바람은 스산하게 옷깃을 파고들었다. 어디론가 떠나고 싶은 마음과 어딘가에 머무르고 싶은 마음이 교차하는, 그런 묘한 감상에 젖어들었다. 잠시 후, 저 멀리서 기차가 육중한 소리를 내며 플랫폼으로 서서히 들어왔다. 낡았지만 정감 가는 기차의 창문 너머로, 각자의 사연을 안고 떠나는 사람들의 모습이 어렴풋이 보였다. 설렘과 아쉬움, 기대와 불안이 뒤섞인 그들의 표정 속에서 나는 내 삶의 여러 여정들을 떠올렸다. 새로운 시작을 향해 떠났던 길, 아쉬운 이별을 뒤로하고 돌아섰던 길, 목적지도 모른 채 그저 발길 닿는 대로 걸었던 길까지. 그 모든 길 위에서 나는 수많은 사람들을 만났고, 다양한 감정들을 경험했으며, 조금씩 성장해왔다. 기차가 멈춰 서고 문이 열리자, 나는 가방을 고쳐 메고 자리에서 일어섰다. 이번 여정의 끝에는 무엇이 기다리고 있을지 알 수 없지만, 그것 또한 내 삶의 한 페이지를 채워줄 소중한 경험이 될 것이라 믿었다. 기차는 다시 한번 육중한 기적 소리를 내며 천천히 움직이기 시작했고, 나는 창밖으로 멀어져 가는 익숙한 풍경들을 바라보며, 새로운 이야기가 시작될 미지의 공간을 향해 나아갔다.` },
        { title: "오래된 소설책", content: `작은 도서관 구석, 햇살이 비껴드는 창가 자리에 앉아 오래된 소설책을 펼쳤다. 종이에서는 세월의 흔적이 느껴지는 희미한 냄새가 풍겨왔고, 손때 묻은 페이지들은 수많은 독자들의 이야기를 품고 있는 듯했다. 나는 한 자 한 자 천천히 글자를 따라 읽어 내려가며, 작가가 만들어낸 세계 속으로 깊이 빠져들었다. 그곳에는 내가 미처 경험하지 못한 삶과 감정들이 있었고, 현실에서는 만날 수 없는 매력적인 인물들이 살아가고 있었다. 때로는 주인공의 기쁨에 함께 웃고, 때로는 그의 슬픔에 함께 눈물 흘리며, 나는 책 속의 이야기와 온전히 하나가 되었다. 책을 읽는다는 것은 어쩌면, 시간과 공간을 초월하여 다른 누군가의 삶을 잠시 빌려 살아보는 것과 같은 경험일지도 모른다. 그 경험을 통해 우리는 세상을 바라보는 새로운 시각을 얻고, 인간과 삶에 대한 깊은 이해에 다가서게 된다. 한 권의 책은 때로 백 명의 스승보다 더 큰 가르침을 주기도 하고, 그 어떤 위로보다 더 따뜻한 안식을 선물하기도 한다. 나는 마지막 책장을 덮으며, 마음속에 잔잔하게 퍼지는 깊은 여운을 느꼈다. 책 속에서 만난 이야기와 인물들은 한동안 내 곁을 떠나지 않고, 내 삶의 중요한 일부가 되어 함께할 것 같았다. 그것이 바로 책이 가진 위대한 힘이리라.` },
        { title: "강변의 노을", content: `어스름이 내리는 저녁, 나는 강변을 따라 천천히 걷고 있었다. 강물은 해 질 녘의 붉은 노을을 온통 담아내며 고요히 흘러갔고, 강 건너편 도시의 불빛들은 하나둘씩 반짝이기 시작했다. 바람은 잔잔했고, 공기는 상쾌했다. 나는 강둑에 잠시 멈춰 서서, 아름다운 저녁 풍경을 가만히 바라보았다. 매일 반복되는 일상 속에서 우리는 종종 이런 순간의 아름다움을 잊고 살아간다. 하지만 잠시 멈춰 서서 주변을 둘러보면, 세상은 우리가 생각하는 것보다 훨씬 더 다채롭고 경이로운 모습으로 가득 차 있다는 것을 깨닫게 된다. 저녁노을이 만들어내는 황홀한 빛의 향연, 밤하늘을 수놓는 무수한 별들의 반짝임, 이름 모를 풀꽃의 소박한 아름다움까지. 이런 작은 것들 속에 삶의 진정한 기쁨과 위안이 숨겨져 있는지도 모른다. 중요한 것은 그것을 발견할 수 있는 열린 마음과 세상을 바라보는 따뜻한 시선이다. 어둠이 완전히 내려앉고 도시의 불빛이 더욱 선명해지자, 나는 다시 발걸음을 옮겼다. 짧은 산책이었지만, 내 마음은 어느새 평온함과 감사함으로 가득 차 있었다. 일상의 소중함을 다시 한번 깨닫게 해준 아름다운 저녁이었다.` },
        { title: "봉숭아 꽃물", content: `오랜만에 찾은 고향 집 마당에는 할머니가 심어두신 봉숭아 꽃이 곱게 피어 있었다. 어릴 적, 할머니 손을 잡고 봉숭아 꽃잎을 빻아 손톱에 물들이던 기억이 아련하게 떠올랐다. 빨갛게 물든 작은 손톱을 보하며 세상을 다 가진 듯 기뻐했던 그 시절. 그때는 모든 것이 단순했고, 작은 것 하나에도 큰 행복을 느낄 수 있었다. 세월이 흘러 어른이 된 지금, 나는 많은 것을 가졌지만 그때만큼 순수하게 행복하다고 말할 수 있을까. 문득 그런 생각이 들었다. 어쩌면 우리는 성장하면서 세상을 너무 복잡하게 바라보고, 진정한 행복의 의미를 잊어버리는 것은 아닐까. 봉숭아 꽃은 예전과 다름없이 여전히 그 자리에서 소박한 아름다움을 뽐내고 있었다. 그것은 나에게 말없이 가르쳐주는 듯했다. 행복은 멀리 있는 것이 아니라, 바로 우리 마음속에, 그리고 우리가 지나쳐온 소중한 추억들 속에 있다는 것을. 나는 마당 한쪽에 쪼그리고 앉아, 바람에 흔들리는 봉숭아 꽃잎을 한참 동안 바라보았다. 그리고 어린 시절의 나에게, 그리고 지금의 나에게 조용히 속삭였다. 괜찮아, 지금 이 순간을 소중히 여기면 돼. 그것이 바로 행복이야.` },
        { title: "비 내리는 오후", content: `비 내리는 오후, 나는 창가에 앉아 하염없이 창밖을 바라보았다. 굵은 빗방울들이 유리창을 세차게 두드렸고, 세상은 온통 잿빛 물감으로 덧칠한 듯 흐릿했다. 이런 날이면 괜스레 마음이 차분해지고, 평소에는 떠오르지 않던 생각들이 꼬리에 꼬리를 물고 이어지곤 한다. 빗소리는 마치 세상의 모든 소음을 잠재우고, 오직 내면의 목소리에만 귀 기울이도록 만드는 마법과 같았다. 나는 잊고 지냈던 사람들을 떠올리고, 지나간 시간들을 반추하며, 미래의 불확실함에 대해 조용히 고민했다. 어쩌면 비는, 우리에게 잠시 멈춰 서서 자신을 돌아볼 시간을 선물하는 것일지도 모른다. 빠르게 변화하는 세상 속에서 미처 돌보지 못했던 마음의 상처들을 어루만지고, 잊고 지냈던 소중한 가치들을 다시 한번 되새길 수 있도록 말이다. 빗줄기가 조금씩 가늘어지더니, 이윽고 먹구름 사이로 희미한 햇살 한 줄기가 비쳐들었다. 비 온 뒤의 세상은 이전보다 더욱 깨끗하고 싱그러워 보였다. 내 마음도 한바탕 비를 맞고 난 뒤처럼, 한결 가볍고 맑아진 것을 느꼈다. 비는 모든 것을 쓸어내리고, 또다시 새로운 시작을 준비하게 만드는 자연의 경이로운 순환이었다.` },
        { title: "늦가을 오솔길", content: `늦가을, 낙엽이 수북이 쌓인 오솔길을 혼자 걸었다. 발걸음을 옮길 때마다 바스락거리는 낙엽 소리가 정겹게 들려왔고, 코끝에는 쌉싸름하면서도 향긋한 가을 냄새가 스며들었다. 하늘은 더없이 높고 푸르렀으며, 나뭇가지 사이로 부서지는 햇살은 따스했다. 나는 천천히 걸으며, 화려했던 여름을 보내고 이제 겨울을 맞이할 준비를 하는 자연의 모습을 가만히 관찰했다. 울긋불긋 아름다운 색으로 물들었던 단풍잎들은 이제 마지막 빛을 발하며 땅으로 떨어져 내렸고, 앙상한 가지만 남은 나무들은 다가올 추위를 묵묵히 견뎌낼 준비를 하는 듯했다. 그 모습에서 나는 삶의 순환과 자연의 섭리를 느꼈다. 모든 것에는 시작과 끝이 있고, 성장의 시간이 있으면 쇠퇴의 시간도 있으며, 화려한 순간이 있으면 고요한 침묵의 순간도 있다는 것을. 그리고 그 모든 과정은 그 자체로 의미 있고 아름답다는 것을. 낙엽은 끝이 아니라 새로운 시작을 위한 준비였다. 땅으로 돌아가 거름이 되어, 다음 해 봄에 새로운 생명이 움틀 수 있도록 자신을 내어주는 것이다. 나는 깊어가는 가을의 정취 속에서, 삶의 유한함과 그 속에서 우리가 가져야 할 겸손함, 그리고 모든 것을 받아들이고 순응하는 지혜에 대해 생각했다. 낙엽 밟는 소리가 배경음악처럼 깔리는 그 길 위에서, 나는 자연이 주는 깊은 위안과 가르침을 얻었다.` },
        { title: "바닷가 등대", content: `바람이 세차게 불던 어느 겨울날, 나는 바닷가 작은 등대를 찾아갔다. 하얀 포말을 일으키며 거칠게 밀려오는 파도와 매서운 바닷바람 속에서도 등대는 조금의 흔들림 없이 굳건히 서 있었다. 그 모습은 마치 세상의 온갖 풍파를 견뎌내며 자신의 자리를 지키는 고독한 수호자 같았다. 어둠이 내리면 등대는 어김없이 밝은 빛을 발하여, 밤바다를 항해하는 배들에게 길을 안내할 것이다. 그 빛은 단순한 불빛이 아니라, 험난한 바다 위에서 길을 잃은 이들에게 희망과 안도를 주는 생명의 빛이리라. 나는 문득 우리 삶에도 저런 등대와 같은 존재가 필요하다는 생각을 했다. 때로는 거친 파도처럼 힘겨운 시련이 몰아치고, 짙은 안개처럼 방향을 잃고 방황할 때, 우리를 올바른 길로 인도해주고 마음의 등불이 되어줄 그런 존재 말이다. 그것은 때로는 현명한 조언을 해주는 스승일 수도 있고, 변함없는 사랑을 주는 가족일 수도 있으며, 혹은 마음속 깊이 간직한 신념이나 가치관일 수도 있다. 중요한 것은 자신만의 등대를 가지고, 그 빛을 따라 꿋꿋이 나아가는 것이다. 세찬 바람 속에서도 묵묵히 빛을 밝히는 등대를 바라보며, 나는 내 삶의 등대는 무엇인지 다시 한번 생각해보았다.` },
        { title: "플라타너스 나무", content: `어린 시절, 동네 어귀에는 커다란 플라타너스 나무가 한 그루 서 있었다. 여름이면 무성한 잎으로 시원한 그늘을 만들어주었고, 가을이면 황금빛 낙엽을 아름답게 흩날렸으며, 겨울이면 앙상한 가지에 눈꽃을 피워 장관을 이루었다. 그 나무 아래는 언제나 아이들의 웃음소리가 끊이지 않는 놀이터였고, 동네 어른들의 정겨운 이야기가 오가는 쉼터였다. 나는 그 나무 아래에서 친구들과 술래잡기를 하고, 딱지치기를 하고, 때로는 가만히 앉아 하늘을 바라보며 엉뚱한 상상에 빠지기도 했다. 플라타너스 나무는 나의 유년 시절 모든 기억을 말없이 지켜봐 준 든든한 친구이자 보호자였다. 세월이 흘러 나는 어른이 되었고, 그 동네를 떠나온 지도 오래되었다. 하지만 문득 그 플라타너스 나무가 그리워질 때가 있다. 모든 것이 빠르게 변해가는 이 세상 속에서, 변함없이 그 자리를 지키고 있을 것 같은 그 나무의 존재가 주는 안정감 때문일까. 어쩌면 그 나무는 나에게 단순한 나무 이상의 의미였는지도 모른다. 그것은 돌아갈 수 없는 아름다운 시절에 대한 그리움이자, 순수했던 마음을 다시 찾고 싶은 작은 소망의 상징이었을 것이다. 언젠가 다시 그 나무 아래 서면, 나는 잠시나마 모든 것을 잊고 어린 시절의 나로 돌아갈 수 있을 것만 같다.` },
        { title: "오래된 엘피판", content: `나는 가끔 오래된 엘피판을 꺼내 턴테이블 위에 올려놓는다. 지지직거리는 작은 소음과 함께 바늘이 레코드의 검은 골을 따라 천천히 움직이기 시작하면, 곧이어 따뜻하고 풍부한 아날로그 사운드가 공간을 가득 채운다. 디지털 음원에서는 느낄 수 없는 그 특유의 깊이와 온기는 마치 시간 여행을 하는 듯한 묘한 감흥을 불러일으킨다. 엘피판 한 장에는 단순히 음악만 담겨 있는 것이 아니다. 그 음악이 유행했던 시대의 공기, 그 음악을 함께 들었던 사람들과의 추억, 그리고 그 음악을 들으며 느꼈던 나의 젊은 날의 감정들이 고스란히 담겨 있다. 그래서 엘피를 듣는 것은 단순한 음악 감상을 넘어, 지나간 시간과의 조우이자 잊혀진 기억과의 재회이기도 하다. 때로는 빛바랜 앨범 재킷을 어루만지며 그 시절을 추억하고, 때로는 가사를 음미하며 그 의미를 되새기기도 한다. 세상은 점점 더 빠르고 편리한 것을 추구하지만, 나는 가끔 이렇게 느리고 불편한 아날로그의 세계에 머무르는 것을 좋아한다. 그 속에는 디지털이 결코 흉내 낼 수 없는 인간적인 따뜻함과 시간의 깊이가 존재하기 때문이다. 엘피판이 돌아가는 것을 가만히 바라보며, 나는 오늘도 잊혀진 시간 속으로 짧은 여행을 떠난다.` },
        { title: "시골 간이역", content: `작은 시골 간이역, 해 질 녘 플랫폼에는 기차를 기다리는 사람들보다 먼저 와 자리를 잡은 저녁노을이 더 짙었다. 나는 낡은 나무 의자에 앉아, 서쪽 하늘을 붉게 물들이며 서서히 스러져가는 노을의 마지막 장관을 바라보았다. 세상의 모든 색을 다 끌어모은 듯한 그 찬란한 빛의 향연 앞에서, 인간의 언어는 한없이 초라하게 느껴졌다. 노을은 낮과 밤의 경계에서 피어나는 짧지만 강렬한 예술과 같았다. 뜨거웠던 하루의 열정을 모두 불태우고, 이제 고요한 휴식의 시간으로 접어들기 위한 마지막 인사처럼. 나는 그 아름다움에 매료되어 한동안 아무 말도 할 수 없었다. 잠시 후, 노을이 완전히 자취를 감추고 어둠이 내려앉자, 하늘에는 하나둘씩 별들이 모습을 드러내기 시작했다. 그것은 마치 화려한 무대가 끝나고 다음 막이 오르기 전의 고요한 설렘과도 같았다. 삶에도 저런 노을과 같은 순간들이 있을 것이다. 모든 것을 쏟아부은 뒤 맞이하는 찬란한 마무리, 그리고 새로운 시작을 예비하는 고요한 성찰의 시간. 우리는 그 순간들을 통해 지나온 길을 돌아보고, 앞으로 나아갈 힘을 얻는다. 나는 깊어가는 밤의 적막 속에서, 오늘 하루 나에게 주어진 시간과 경험들에 감사하며, 내일 또다시 떠오를 새로운 태양을 기다렸다.` },
        { title: "만년필 일기", content: `나는 오래된 만년필로 일기를 쓰는 것을 좋아한다. 사각거리는 펜촉이 종이 위를 스치는 소리, 손끝으로 전해져 오는 잉크의 미세한 흐름, 그리고 한 자 한 자 정성스럽게 써 내려가는 글자들이 만들어내는 그 모든 과정이 나에게는 작은 의식과도 같다. 디지털 시대에 손으로 글을 쓴다는 것은 어쩌면 비효율적이고 번거로운 일일지도 모른다. 하지만 나는 그 느림과 불편함 속에서 오히려 더 깊은 사색과 진정한 자기표현의 즐거움을 발견한다. 컴퓨터 자판으로는 미처 담아낼 수 없는 생각의 결들과 감정의 미묘한 떨림들이, 만년필을 통해 종이 위에 고스란히 새겨지는 것을 느낀다. 일기장에는 그날 있었던 소소한 사건들뿐만 아니라, 마음속 깊은 곳에 숨겨두었던 생각들, 누구에게도 말하지 못했던 비밀들, 그리고 미래에 대한 막연한 기대와 불안까지 모든 것이 담긴다. 그것은 오롯이 나 자신과 마주하는 시간이며, 내 삶의 발자취를 기록하는 소중한 작업이다. 훗날 이 일기장을 다시 펼쳐보았을 때, 나는 지금 이 순간의 나를 만나고, 그 시절의 고민과 기쁨을 공유하며, 내가 얼마나 성장했는지를 돌아볼 수 있을 것이다. 만년필의 잉크가 마르듯 시간은 흘러가겠지만, 종이 위에 남겨진 나의 이야기는 영원히 그 자리에 남아 빛날 것이다.` },
        { title: "산사의 풍경 소리", content: `어느 늦봄, 나는 이름 모를 작은 산사의 툇마루에 앉아 있었다. 산사는 깊은 산속에 고즈넉이 자리 잡아, 세상의 모든 번뇌와 소음으로부터 벗어난 듯 평화로웠다. 처마 끝에 매달린 풍경은 바람이 불 때마다 맑고 청아한 소리를 냈고, 그 소리는 내 마음속까지 잔잔하게 울려 퍼졌다. 마당에는 수령을 알 수 없는 오래된 매화나무 한 그루가 마지막 꽃잎을 떨구고 있었고, 그 아래에는 작은 새 한 마리가 날아와 지저귀고 있었다. 나는 눈을 감고 가만히 그 모든 소리와 풍경을 마음에 담았다. 자연의 소리는 그 어떤 음악보다 아름다웠고, 산사의 고요함은 그 어떤 명상보다 깊은 평화를 가져다주었다. 복잡했던 머릿속은 어느새 텅 비고, 무거웠던 마음은 한결 가벼워졌다. 우리는 종종 너무 많은 것을 보고 듣고 생각하며 살아간다. 그래서 정작 중요한 내면의 소리에는 귀 기울이지 못하고, 진정한 휴식의 의미를 잊어버리곤 한다. 하지만 이렇게 잠시 모든 것을 내려놓고 자연 속에 머무르다 보면, 비로소 우리가 얼마나 작은 존재인지, 그리고 우리가 진정으로 추구해야 할 가치는 무엇인지 깨닫게 된다. 풍경 소리가 다시 한번 맑게 울리자, 나는 깊은 숨을 내쉬며 자리에서 일어섰다. 짧은 시간이었지만, 산사가 준 깊은 평화와 깨달음은 오랫동안 내 마음속에 남아 있을 것 같았다.` },
        { title: "오래된 흑백사진", content: `나는 가끔 오래된 흑백사진을 들여다본다. 빛바랜 사진 속에는 지금은 만날 수 없는 사람들의 미소와 다시 돌아갈 수 없는 풍경들이 담겨 있다. 컬러사진이 현실을 있는 그대로 생생하게 재현한다면, 흑백사진은 현실 너머의 어떤 아련한 감성과 시간의 깊이를 느끼게 해주는 묘한 매력이 있다. 색이 사라진 세상은 오히려 더 많은 것을 상상하게 만들고, 인물의 표정과 배경의 분위기에 더욱 집중하게 만든다. 사진 속 인물들은 어떤 이야기를 간직하고 있을까, 그들은 어떤 꿈을 꾸고 어떤 사랑을 했을까. 나는 그런 상상을 하며 사진 속 시간으로 잠시 여행을 떠나곤 한다. 흑백사진은 단순한 기록이 아니라, 한 시대의 초상이자 누군가의 삶의 증거이다. 그 속에는 기쁨과 슬픔, 만남과 이별, 희망과 절망 등 인간이 겪을 수 있는 모든 감정들이 응축되어 있다. 그래서 흑백사진을 보고 있으면, 때로는 알 수 없는 그리움에 가슴이 아련해지기도 하고, 때로는 삶의 숙연함에 고개가 숙여지기도 한다. 사진 한 장이 건네는 수많은 이야기들. 나는 그 이야기들을 통해 과거와 현재를 잇고, 사라진 시간 속에서 변치 않는 가치를 발견한다. 흑백사진은 나에게 침묵으로 더 많은 것을 말해주는 오래된 친구와 같다.` },
        { title: "겨울밤의 눈", content: `한겨울 밤, 창밖에는 하얀 눈이 소리 없이 내리고 있었다. 나는 따뜻한 코코아 한 잔을 들고 창가에 서서, 밤새 세상을 하얗게 뒤덮을 것 같은 눈송이들을 하염없이 바라보았다. 가로등 불빛 아래 춤추듯 흩날리는 눈송이들은 마치 동화 속 한 장면처럼 비현실적으로 아름다웠다. 눈은 세상의 모든 더러움과 소음을 하얗게 덮어버리고, 고요하고 순수한 평화를 가져다주는 것 같았다. 나는 어린아이처럼 창문에 입김을 불어 작은 그림을 그리기도 하고, 손을 내밀어 차가운 눈송이를 직접 만져보기도 했다. 눈이 내리는 풍경은 언제나 나를 설레게 하고, 잊고 지냈던 동심을 일깨워준다. 어쩌면 눈은, 하늘이 우리에게 보내는 하얀 편지일지도 모른다. 잠시 모든 것을 잊고 순수한 기쁨을 느껴보라고, 그리고 새로운 시작을 준비하라고 속삭이는 아름다운 편지. 나는 코코아의 마지막 한 모금을 마시며, 내일 아침 눈부시게 펼쳐질 하얀 세상을 상상했다. 발자국 하나 없는 깨끗한 눈밭 위를 처음으로 걷는 기분은 얼마나 상쾌할까. 눈이 그치고 아침이 오면, 나는 가장 먼저 하얀 세상 속으로 달려 나가, 겨울이 주는 특별한 선물을 만끽할 것이다.` },
        { title: "사람 사는 시장", content: `나는 가끔 오래된 시장을 찾는 것을 좋아한다. 대형마트의 깔끔함과 편리함도 좋지만, 시장에는 그곳에서만 느낄 수 있는 특별한 활기와 정겨움이 있다. 좌판 가득 싱싱한 채소와 과일을 진열해놓고 구성진 목소리로 손님을 부르는 상인들, 흥정을 하며 덤을 얻어가는 손님들의 웃음소리, 맛있는 냄새를 풍기며 발길을 유혹하는 길거리 음식들까지. 시장은 살아있는 사람들의 이야기로 가득한 공간이다. 나는 천천히 시장 골목을 걸으며, 다양한 물건들을 구경하고 사람들의 살아가는 모습을 관찰한다. 그 속에서 나는 잊고 지냈던 인간적인 따뜻함과 소박한 삶의 아름다움을 발견한다. 시장 상인들의 거친 손마디에는 정직한 땀의 가치가 담겨 있고, 그들의 구릿빛 얼굴에는 세월의 흔적과 삶의 지혜가 새겨져 있다. 그들은 단순히 물건을 파는 것이 아니라, 자신의 삶을 나누고 사람들과 정을 주고받는다. 그래서 시장에서의 거래는 단순한 매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다.` },
    ],
    engLong: [
        { title: "The Old Attic", content: "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper and faint wood, a nostalgic perfume that seemed to whisper tales of bygone eras. Tiny dust motes danced in the invading sunbeams, sparkling like miniature galaxies, and the world outside, viewed through the grimy pane, appeared as a distant, dreamlike watercolor. I had creaked my way up the wooden stairs, settling into the worn comfort of a rocking chair by the window. Below, an ancient oak stood sentinel, its leaves rustling a quiet, timeless song with every breeze, a silent observer of centuries unfolding. In that tranquil tableau, I found myself sifting through childhood memories: a grandmother's gentle voice narrating fairy tales, the vibrant hues of a sunset over a familiar alleyway, the first stirrings of a young heart's joy and sorrow. Time, in its relentless march, may alter all things, yet the warmth embedded in memory, I realized, remains an immutable sanctuary. Perhaps we all carry a small, secret attic within our souls, a place of solace filled with cherished recollections, a haven to retreat to when the world outside grows too loud." },
        { title: "The Night Sky", content: "Under the velvet cloak of a moonless night, countless stars were scattered across the celestial canvas like diamonds on black silk. With a warm cup of herbal tea cradled in my hands, I stood by the window, lost in the profound mystery of the infinite expanse. The deeper the darkness, the more intensely the starlight seemed to pierce through, its serene luminescence seeping into the very core of my being. One distant, unnamed star shone with a particular brilliance, a beacon for a lost traveler, perhaps, or a tiny lantern carrying a whispered wish to the heavens. Gazing at it, I was transported back to the untainted dreams of youth: a daring explorer charting unknown territories, an artist evoking profound emotions, an astronomer unravelling cosmic secrets. Those aspirations, once so vivid but gradually set aside against the unyielding walls of reality, flickered faintly back to life under the starlight. Maybe dreams never truly vanish; perhaps they merely slumber in the night sky of our hearts, awaiting the courage to be pursued once more. As I sipped the last of my tea, I made a quiet promise to those stars, and to myself: to keep writing the unfinished chapters of my own story, guided by their distant, unwavering light." },
        { title: "The Ancient Woods", content: "The scent of pine needles and damp earth filled the air as she walked deeper into the ancient woods. Sunlight struggled to penetrate the thick canopy, casting an ethereal, green-tinged light on the forest floor. Moss grew like velvet on the trunks and branches of old trees, and delicate ferns uncurled their fronds in the damp places where shadows lingered. She paused by a gnarled oak, its bark a tapestry of a thousand storms weathered and a thousand suns embraced. It seemed to whisper secrets of the ages, of creatures seen and unseen, of seasons turning in an endless, graceful dance. Here, away from the clamor of human invention, she felt a profound connection to something primal, something enduring. The forest was not merely a collection of trees, but a living, breathing entity, a sanctuary for the soul seeking quietude and a reminder of the intricate beauty of the natural world. Each fallen leaf crunched underfoot was a note in an ancient song, a testament to the cycle of life, death, and renewal, a humbling perspective in the grand theatre of existence." },
        { title: "The Secret Courtyard", content: "In the heart of the bustling city, there existed a small, almost forgotten courtyard, a tiny oasis of green amidst the towering steel and glass. Ivy climbed the old brick walls, and a single, resilient cherry tree bloomed defiantly each spring, its blossoms a soft pink rebellion against the urban grey. Few knew of this place, tucked away behind a narrow alley, and those who did cherished it as a secret haven. Here, the city's roar subsided to a distant hum, and one could hear the cooing of pigeons or the rustle of leaves in the gentle breeze. It was a place for quiet contemplation, for stolen moments of peace in a world that seldom seemed to pause. Sometimes, an artist would sit on the worn stone bench, sketching the play of light and shadow, or a writer would fill a notebook with fleeting thoughts and observations, inspired by the unexpected tranquility found in such an urban pocket of serenity. This courtyard was a reminder that even in the most concrete of jungles, nature, and a moment's peace, could always find a way to endure." },
        { title: "The Lighthouse", content: "The old lighthouse stood sentinel on the jagged cliff, its stoic form a familiar silhouette against the turbulent, grey sky. For generations, its beam had cut through the darkest storms, a steadfast promise of guidance to sailors navigating the treacherous coastal waters. The keeper, a man with a weather-beaten face and eyes that held the wisdom of the sea, lived a solitary life, his only companions the cry of gulls and the ceaseless rhythm of the waves. He knew every mood of the ocean, from its gentle summer caress to its furious winter rage. His days were marked by routine: tending the great lamp, polishing the massive Fresnel lens, and scanning the horizon for any sign of a vessel in distress. It was a life of responsibility, of quiet dedication to a purpose larger than himself. The lighthouse was more than just a structure of stone and light; it was a symbol of hope, a beacon of resilience against the raw, untamed power of nature, and a testament to the enduring human spirit that sought to illuminate the darkness and bring wanderers safely home, a silent guardian watching over the restless sea." },
        { title: "A Rainy Evening", content: "A gentle rain began to fall as evening descended, a soft, persistent patter against the windowpanes. Inside, the warmth of the hearth cast a flickering, amber glow across the room, a stark contrast to the cool, damp air outside. She sat curled in an old armchair, a half-read book resting in her lap, a pensive expression on her face. The rain was a soothing melody, a lullaby that seemed to wash away the day's accumulated anxieties and quiet the relentless chatter of the mind. It was on nights like these, cocooned in the quiet solitude of her home, that her thoughts roamed free, unburdened by the demands of the world. She pondered the intricate tapestry of human connection, the fragile threads that bound one soul to another, the unexpected joys and inevitable sorrows that colored the human experience. The rhythmic drumming of the rain provided a comforting backdrop to her reflections, a reminder of nature's constant, gentle presence, and the quiet beauty to be found in a simple, rainy evening spent in peaceful contemplation." },
        { title: "The Desert's Beauty", content: "The desert stretched out before him, an endless expanse of undulating dunes under a sky so vast it seemed to swallow the horizon. The sun beat down relentlessly, and the air shimmered with an almost palpable heat. Yet, amidst this harsh and unforgiving landscape, there was a stark, austere beauty that captivated the soul. The way the wind sculpted the sand into ever-changing, sinuous patterns, the resilience of the sparse, thorny vegetation clinging stubbornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding." },
    ],
js: [
        `const name = 'key-therapy';`, `let score = 100;`, `const isActive = true;`, `let userProfile = null;`, `let lastLoginDate = undefined;`,
        `const PI = 3.14159;`, `const id = Symbol('id');`, `const bigIntValue = 9007199254740991n;`, `const userInfo = { name: 'Alex', age: 30 };`,
        `const permissions = ['read', 'write', 'execute'];`, `document.getElementById('app-container');`, `document.querySelector('.user-panel');`,
        `const newElement = document.createElement('div');`, `parentElement.appendChild(newElement);`, `element.classList.add('active');`,
        `element.classList.remove('hidden');`, `element.setAttribute('data-id', '123');`, `element.style.backgroundColor = '#f0f0f0';`,
        `window.addEventListener('scroll', handleScroll);`, `button.removeEventListener('click', handleClick);`, `let total = price * quantity;`,
        `let remainder = 10 % 3;`, `let i = 0; i++;`, `let j = 5; j--;`, `const isEqual = (a == b);`, `const isStrictEqual = (a === b);`,
        `const result = (a > 10) && (b < 5);`, `const value = x || 'default';`, `const type = typeof variable;`, `const isArray = variable instanceof Array;`,
        `if (isValid && !isComplete) { proceed(); }`, `if (score > 90) { grade = 'A'; }`, `else if (score > 80) { grade = 'B'; }`, `else { grade = 'C'; }`,
        `switch (status) { case 'pending': break; }`, `for (let i = 0; i < array.length; i++) {}`, `for (const item of iterable) {}`,
        `for (const key in object) {}`, `while (condition) { statement; }`, `do { statement; } while (condition);`,
        `function calculate(a, b) { return a + b; }`, `const greet = () => { console.log('Hello!'); };`, `const multiply = (x, y) => x * y;`,
        `const sum = (...args) => args.reduce((a, b) => a + b, 0);`, `function process(data, callback) {}`,
        `const result = (function() { return 'IIFE'; })();`, `function* generator() { yield 1; }`, `const { name, age } = user;`,
        `const [first, second] = numbers;`, `const defaultParams = (p = 1) => {};`, `const arr = new Array(5);`, `const len = permissions.length;`,
        `permissions.push('delete');`, `const last = permissions.pop();`, `const first = permissions.shift();`, `permissions.unshift('create');`,
        `const sliced = permissions.slice(1, 3);`, `const str = permissions.join(', ');`, `const sorted = numbers.sort((a, b) => a - b);`,
        `const mapped = numbers.map(x => x * 2);`, `const car = { make: 'Toyota', model: 'Camry' };`, `const value = car['make'];`,
        `car.year = 2021;`, `delete car.model;`, `const keys = Object.keys(car);`, `const values = Object.values(car);`, `const entries = Object.entries(car);`,
        `const newObj = { ...car, color: 'blue' };`, `Object.freeze(car);`, `const hasProp = car.hasOwnProperty('year');`, `console.log('Start');`,
        `setTimeout(() => { console.log('Timeout!'); }, 2000);`, `const intervalId = setInterval(updateClock, 1000);`,
        `clearInterval(intervalId);`, `const promise = new Promise((resolve, reject) => {});`, `promise.then(value => {}).catch(error => {});`,
        `async function fetchData() {}`, `const data = await fetch(url);`, `try { let response = await apiCall(); } catch (e) {}`,
        `Promise.all([p1, p2, p3]).then(values => {});`, `class Person { constructor(name) { this.name = name; } }`,
        `class Student extends Person { constructor(name) { super(name); } }`, `const template = \`Name: \${user.name}\`;`, `import { utility } from './utils.js';`,
        `export const constantValue = 42;`, `const mySet = new Set([1, 1, 2, 3]);`, `const myMap = new Map([['key', 'value']]);`, `for (const [key, value] of myMap) {}`,
        `const proxy = new Proxy(target, handler);`, `const weakSet = new WeakSet();`, `const jsonString = JSON.stringify(userInfo);`, `const parsedObject = JSON.parse(jsonString);`,
        `localStorage.setItem('session', jsonString);`, `const session = localStorage.getItem('session');`, `sessionStorage.setItem('temp', 'data');`,
        `const req = new XMLHttpRequest();`, `history.pushState(null, '', '/new-url');`, `const canvas = document.getElementById('myCanvas');`, `const ctx = canvas.getContext('2d');`,
        `navigator.geolocation.getCurrentPosition(success);`, `// This is a single-line comment.`, `/* This is a multi-line comment. */`,
        `/** @param {string} name - The user's name. */`, `'use strict';`, `// FIXME: This logic is not efficient.`, `// REVIEW: Is this the correct approach?`,
        `const MAX_RETRIES = 3;`, `// Ensure the input is a valid number.`, `// Deprecated: Do not use this function.`, `// End of JavaScript short examples.`
    ],
    jsLong: [
        { title: "API 데이터 가져오기", content: `// Example 1: Fetching and displaying data from an API\nasync function displayUsers() {\n  const userList = document.getElementById('user-list');\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    const users = await response.json();\n    userList.innerHTML = ''; // Clear previous list\n    users.forEach(user => {\n      const li = document.createElement('li');\n      li.textContent = \`\${user.name} (@\${user.username}) - \${user.email}\`;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    userList.innerHTML = '<li>Error loading users.</li>';\n    console.error('Fetching users failed:', error);\n  }\n}` },
        { title: "카운트다운 타이머", content: `// Example 2: Simple class for a countdown timer\nclass CountdownTimer {\n  constructor(duration, displayElement) {\n    this.duration = duration; // in seconds\n    this.display = displayElement;\n    this.timerId = null;\n  }\n\n  start() {\n    let remaining = this.duration;\n    const tick = () => {\n      const minutes = String(Math.floor(remaining / 60)).padStart(2, '0');\n      const seconds = String(remaining % 60).padStart(2, '0');\n      this.display.textContent = \`\${minutes}:\${seconds}\`;\n      if (--remaining < 0) { this.stop(); }\n    };\n    this.stop(); // Clear any existing timer\n    this.timerId = setInterval(tick, 1000);\n  }\n\n  stop() {\n    clearInterval(this.timerId);\n    this.display.textContent = 'Time is up!';\n  }\n}` },
        { title: "배열 필터링 및 매핑", content: `// Example 3: Filtering and mapping an array of objects\nconst products = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200, inStock: true },\n  { id: 2, name: 'T-Shirt', category: 'Apparel', price: 25, inStock: true },\n  { id: 3, name: 'Coffee Maker', category: 'Appliances', price: 80, inStock: false },\n  { id: 4, name: 'Smartphone', category: 'Electronics', price: 800, inStock: true }\n];\n\nconst availableElectronics = products\n  .filter(p => p.category === 'Electronics' && p.inStock)\n  .map(p => {\n    const priceWithTax = p.price * 1.10;\n    return { ...p, priceWithTax: priceWithTax.toFixed(2) };\n  });\n\nconsole.log(availableElectronics);` },
        { title: "Pub/Sub 패턴", content: `// Example 4: Implementing a simple Pub/Sub (Event Emitter) pattern\nconst eventBus = {\n  events: {},\n  subscribe(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    const index = this.events[event].push(listener) - 1;\n    return {\n      unsubscribe: () => {\n        this.events[event].splice(index, 1);\n      }\n    };\n  },\n  publish(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n};\n\nconst subscription = eventBus.subscribe('userLogin', (user) => console.log(\`\${user} logged in.\`));\neventBus.publish('userLogin', 'Alice');\nsubscription.unsubscribe();` },
        { title: "Debounce 함수", content: `// Example 5: Debounce function for performance optimization\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(context, args);\n    }, delay);\n  };\n}\n\nconst handleSearchInput = (query) => {\n  console.log(\`Searching for: \${query}\`);\n  // API call would go here\n};\n\nconst searchInput = document.getElementById('search');\nif (searchInput) {\n    searchInput.addEventListener('keyup', debounce((e) => handleSearchInput(e.target.value), 300));\n}` },
        { title: "모듈 패턴", content: `// Example 6: Module revealing pattern\nconst dataModule = (function() {\n  let privateData = []; // This is private\n\n  function add(item) {\n    privateData.push(item);\n    console.log('Item added.');\n  }\n\n  function get(index) {\n    return privateData[index];\n  }\n\n  // Publicly expose methods\n  return {\n    addItem: add,\n    getItem: get\n  };\n})();\n\ndataModule.addItem('First item');\nconsole.log(dataModule.getItem(0));` }
    ],
    python: [
        `name = "key_therapy"`,
        `score: int = 100`,
        `is_active: bool = True`,
        `user_profile = None`,
        `my_list = [1, 'a', 3.14]`,
        `my_tuple = (1, 'a', 3.14)`,
        `my_dict = {'key': 'value'}`,
        `my_set = {1, 2, 3, 3, 2}`,
        `from decimal import Decimal`,
        `price = Decimal('10.99')`,
        `print(f"Hello, {name}!")`,
        `length = len(my_list)`,
        `user_input = input('Enter your name: ')`,
        `num = int('123')`,
        `is_instance = isinstance(num, int)`,
        `sorted_list = sorted(my_list, reverse=True)`,
        `for i, v in enumerate(my_list):`,
        `zipped = zip(list1, list2)`,
        `abs_value = abs(-10)`,
        `all_true = all([True, True, False])`,
        `if is_active and score > 50:`,
        `if x in my_list:`,
        `elif choice == 'b':`,
        `else:`,
        `for item in my_list:`,
        `for i in range(1, 10, 2):`,
        `while count < 10:`,
        `while True: break`,
        `try: result = 10 / 0`,
        `except ZeroDivisionError as e:`,
        `def greet(name: str) -> str:`,
        `def power(base, exp=2):`,
        `def register(*args, **kwargs):`,
        `global_var = 10`,
        `def my_func(): global global_var`,
        `my_lambda = lambda x, y: x + y`,
        `def my_generator(): yield 1`,
        `return f"Welcome, {name}!"`,
        `from functools import reduce, lru_cache`,
        `product = reduce((lambda x, y: x * y), [1, 2, 3])`,
        `import os`,
        `with open('file.txt', 'w', encoding='utf-8') as f:`,
        "f.write('Hello, world!\\n')",
        `lines = f.readlines()`,
        `current_dir = os.getcwd()`,
        `file_exists = os.path.exists('file.txt')`,
        `import json`,
        `data = json.load(f)`,
        `json.dump(my_dict, f, indent=4)`,
        `import csv`,
        `squares = [x**2 for x in range(10)]`,
        `even_squares = [x**2 for x in range(10) if x % 2 == 0]`,
        `my_dict_comp = {i: i*i for i in range(5)}`,
        `my_set_comp = {s.lower() for s in list_of_strings}`,
        `matrix = [[0 for _ in range(5)] for _ in range(5)]`,
        `flat_list = [item for sublist in matrix for item in sublist]`,
        `names = ['Bruce', 'Clark', 'Peter']`,
        `lengths = {name: len(name) for name in names}`,
        `inverted_dict = {v: k for k, v in my_dict.items()}`,
        `unique_letters = {letter for word in text for letter in word}`,
        `class MyClass:`,
        `    def __init__(self, name):`,
        `        self.name = name`,
        `    def method(self):`,
        `class Child(MyClass):`,
        `    def __init__(self, name, age):`,
        `        super().__init__(name)`,
        `        self.age = age`,
        `instance = MyClass('test')`,
        `@staticmethod`,
        `@classmethod`,
        `from datetime import datetime, timedelta`,
        `now = datetime.now()`,
        `import math`,
        `pi_val = math.pi`,
        `import random`,
        `rand_int = random.randint(1, 100)`,
        `import re`,
        "pattern = re.compile(r'\\d+')",
        `from collections import Counter, deque, defaultdict`,
        `from pathlib import Path`,
        `import numpy as np`,
        `arr = np.array([1, 2, 3])`,
        `import pandas as pd`,
        `df = pd.DataFrame(data)`,
        `import requests`,
        `response = requests.get('https://api.example.com')`,
        `from bs4 import BeautifulSoup`,
        `soup = BeautifulSoup(html_doc, 'html.parser')`,
        `import matplotlib.pyplot as plt`,
        `plt.plot(x, y)`,
        `# This is a single-line comment.`,
        `"""This is a docstring."""`,
        `# TODO: Implement error handling.`,
        `# FIXME: This causes a bug under certain conditions.`,
        `if __name__ == "__main__":`,
        `from typing import List, Dict, Tuple, Optional, Union`,
        `app.config['SECRET_KEY'] = os.urandom(24)`,
        `db.session.add(new_user)`,
        `db.session.commit()`,
        `logging.basicConfig(level=logging.INFO)`,
        `assert sum([1, 2, 3]) == 6, "Should be 6"`,
        `d = {k: v for k, v in data.items()}`,
        `for index, row in df.iterrows():`,
        `yield from generator_function()`,
        `raise ValueError('Invalid argument provided')`,
        `# End of Python short examples.`
    ],
    pythonLong: [
        { title: "웹 스크래핑 예제", content: `# Example 1: Web scraping with requests and BeautifulSoup\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_website_title(url: str) -> str:\n    """Scrapes the title of a given URL."""\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        soup = BeautifulSoup(response.text, 'html.parser')\n        title = soup.find('h1')\n        return title.string.strip() if title else 'No H1 title found.'\n    except requests.exceptions.RequestException as e:\n        print(f"An error occurred: {e}")\n        return "Error: Could not retrieve title."` },
        { title: "CLI 인자 파서", content: `# Example 2: A simple command-line argument parser using argparse\nimport argparse\n\ndef process_file(input_path, output_path, is_verbose):\n    if is_verbose:\n        print(f"Reading from {input_path} and writing to {output_path}.")\n    with open(input_path, 'r') as infile, open(output_path, 'w') as outfile:\n        for line in infile:\n            outfile.write(line.upper()) # Example processing: convert to uppercase\n\ndef main():\n    parser = argparse.ArgumentParser(description="A simple file processing CLI.")\n    parser.add_argument('-i', '--input', required=True, help='Input file path')\n    parser.add_argument('-o', '--output', default='output.txt', help='Output file path')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')\n    args = parser.parse_args()\n    process_file(args.input, args.output, args.verbose)\n\nif __name__ == '__main__':\n    main()` },
        { title: "To-Do 리스트 클래스", content: `# Example 3: Class for managing a simple To-Do list with file persistence\nimport json\n\nclass TodoList:\n    def __init__(self, filename='todolist.json'):\n        self.filename = filename\n        self.tasks = self._load_tasks()\n\n    def _load_tasks(self):\n        try:\n            with open(self.filename, 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return []\n\n    def _save_tasks(self):\n        with open(self.filename, 'w') as f:\n            json.dump(self.tasks, f, indent=4)\n\n    def add_task(self, task: str):\n        self.tasks.append({'task': task, 'done': False})\n        self._save_tasks()` },
        { title: "Pandas 데이터 분석", content: `# Example 4: Data analysis with pandas for more complex data\nimport pandas as pd\n\ndef analyze_sales_data(file_path: str):\n    """Reads sales data and calculates per-category metrics."""\n    try:\n        df = pd.read_csv(file_path)\n        df['Revenue'] = df['Quantity'] * df['Price']\n        category_revenue = df.groupby('Category')['Revenue'].sum().sort_values(ascending=False)\n        print("--- Revenue by Category ---")\n        print(category_revenue)\n\n        avg_price = df.groupby('Category')['Price'].mean()\n        print("\\n--- Average Price by Category ---")\n        print(avg_price)\n    except (FileNotFoundError, KeyError) as e:\n        print(f"An error occurred during analysis: {e}")` },
        { title: "데코레이터 예제", content: `# Example 5: Creating a decorator with arguments\nfrom functools import wraps\n\ndef repeat(num_times):\n    """A decorator that repeats the execution of a function."""\n    def decorator_repeat(func):\n        @wraps(func)\n        def wrapper_repeat(*args, **kwargs):\n            last_value = None\n            for _ in range(num_times):\n                last_value = func(*args, **kwargs)\n            return last_value\n        return wrapper_repeat\n    return decorator_repeat\n\n@repeat(num_times=3)\ndef say_whee():\n    print("Whee!")\n\nsay_whee()` },
        { title: "SQLite 데이터베이스", content: `# Example 6: Working with a simple SQLite database\nimport sqlite3\n\ndef setup_database(db_name: str):\n    # Connect to the database (or create it)\n    conn = sqlite3.connect(db_name)\n    cursor = conn.cursor()\n\n    # Create a table\n    cursor.execute('''\n    CREATE TABLE IF NOT EXISTS users\n    (id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT NOT NULL UNIQUE)\n    ''')\n\n    # Insert a row of data\n    try:\n        cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('John Doe', 'john.doe@email.com'))\n    except sqlite3.IntegrityError:\n        print("User already exists.")\n    \n    # Save (commit) the changes and close\n    conn.commit()\n    conn.close()` }
    ]
};
function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}
function initializeAudioPoolForPack(packKey) {
    if (!soundFiles[packKey] || soundFiles[packKey].length === 0) return;
    audioPool[packKey] = [];
    soundFiles[packKey].forEach(soundSrc => {
        const audio = new Audio(soundSrc);
        audio.preload = 'auto';
        audioPool[packKey].push(audio);
    });
}
function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}
function playTypingSound() {
    clearTimeout(soundTimer);
    soundTimer = setTimeout(() => {
        if (!soundEnabled || !currentSoundPack) return;
        const masterAudioPool = audioPool[currentSoundPack];
        if (!masterAudioPool || masterAudioPool.length === 0) {
            initializeAudioPoolForPack(currentSoundPack);
            return;
        }
        const masterAudio = getRandom(masterAudioPool);
        if (!masterAudio) return;
        const audioToPlay = masterAudio.cloneNode();
        audioToPlay.play().catch(e => {});
    }, 1);
}
function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('no-transition');
  languageSelectEl = document.getElementById('languageSelect');
  languageSelectLabelEl = document.getElementById('languageSelectLabel');
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  toggleLayoutBtn = document.getElementById('toggleLayoutBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');
  helpModal = document.getElementById('helpModal');
  helpModalBody = document.getElementById('helpModalBody');
  helpModalClose = document.querySelector('.help-modal-close');
  freestyleAreaContainerEl = document.getElementById('freestyle-area-container');
  freestyleInputAreaEl = document.getElementById('freestyle-input-area');
  downloadFreestyleBtnEl = document.getElementById('download-freestyle-btn');
  freestyleFilenameInputEl = document.getElementById('freestyle-filename-input');
  freestyleToolbarEl = document.getElementById('freestyle-toolbar');
  insertDateBtn = document.getElementById('insertDateBtn');
  insertTimeBtn = document.getElementById('insertTimeBtn');
  emojiBtn = document.getElementById('emojiBtn');
  emojiPicker = document.getElementById('emoji-picker');
  copyAllBtn = document.getElementById('copyAllBtn');
  clearAllBtn = document.getElementById('clearAllBtn');
  insertHrBtn = document.getElementById('insertHrBtn');
  charCountEl = document.getElementById('charCount');
  wordCountEl = document.getElementById('wordCount');
  longTextSelectContainerEl = document.getElementById('longTextSelectContainer');
  longTextSelectEl = document.getElementById('longTextSelect');
  practiceTitleDisplayEl = document.getElementById('practice-title-display');
  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  const allElements = [languageSelectEl, lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, toggleLayoutBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl, freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl, freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker, copyAllBtn, clearAllBtn, insertHrBtn, charCountEl, wordCountEl, helpModal, helpModalBody, helpModalClose, longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl];
  if (!allElements.every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다. 누락된 요소를 확인해주세요.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }
  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;
  soundPackSelectEl.innerHTML = '';
  for (let i = 1; i <= totalSoundPacks; i++) {
    const option = document.createElement('option');
    option.value = String(i);
    option.textContent = String(i);
    soundPackSelectEl.appendChild(option);
  }
  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;
  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';
  initializeAudioPool();
  buildKeyboard();
  if (toggleLayoutBtn) {
    toggleLayoutBtn.addEventListener('click', () => {
        layoutCollapsed = !layoutCollapsed;
        updateLayout();
        localStorage.setItem('layoutCollapsed', layoutCollapsed);
    });
  }
  document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(button => {
    button.addEventListener('click', function() {
      showShortcutTooltipTemporarily(); 
      const type = this.dataset.practiceType;
      if (type === 'freestyle') {
          startFreestyleMode();
          return;
      }
      const lang = languageSelectEl.value;
      const isLong = (type === 'long');
      const mode = isLong ? `${lang}Long` : lang;
      startPractice(mode, true);
    });
  });
  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('rainfall');
    });
  }
  if (gameAreaContainerEl) {
    gameAreaContainerEl.addEventListener('click', function(e) {
      if (e.target.closest('#gameHelpBtn')) {
        if (currentGameType) {
          showHelpModal(currentGameType);
        }
      }
    });
  }
  const restartPractice = () => {
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (!activePracticeBtn || currentMode === 'freestyle') return;
    const type = activePracticeBtn.dataset.practiceType;
    const lang = languageSelectEl.value;
    const isLong = (type === 'long');
    const mode = isLong ? `${lang}Long` : lang;
    startPractice(mode, true);
  };
  languageSelectEl.addEventListener('change', restartPractice);
  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }
  typingInputField.addEventListener('input', (e) => {
    soundPlayedForThisInput = false;
    handleInputEvent(e);
  });
 typingInputField.addEventListener('compositionstart', () => {
    isComposingNow = true;
  });
  typingInputField.addEventListener('compositionend', (e) => {
    isComposingNow = false;
    // 조합이 끝난 직후, 완성된 입력값으로 handleInputEvent를 수동으로 한번 더 호출합니다.
    handleInputEvent(e); 
  });
  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }
  document.body.addEventListener('click', function(e) {
    if (emojiPicker.classList.contains('visible') && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
        emojiPicker.classList.remove('visible');
    }
    if (helpModal.classList.contains('visible') && !e.target.closest('.help-modal-content')) {
        hideHelpModal();
    }
    const isInteractiveElement = e.target.closest('button, a, select, input, textarea, #emoji-picker span, .help-modal-content');
    if (!isInteractiveElement) {
      if (document.body.classList.contains('game-mode-active')) {
        if (gameInputField && !gameInputField.disabled) gameInputField.focus();
      } else if (document.body.classList.contains('freestyle-mode-active')) {
        if (freestyleInputAreaEl) freestyleInputAreaEl.focus();
      } else {
        if (typingInputField && !typingInputField.disabled) typingInputField.focus();
      }
    }
  });
  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });
  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    
    // [수정] getTypingAnalysis를 사용하여 화면을 즉시 갱신합니다.
    const analysis = getTypingAnalysis(typingInputField.value, linesToPractice[currentDisplayLineIndex] || "");
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl) {
        const innerSpan = currentLineEl.querySelector('span');
        if (innerSpan) {
            innerSpan.innerHTML = analysis.html;
        }
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    initializeAudioPoolForPack(currentSoundPack);
  });
  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });
  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });
  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> 자리연습 ON' : '<i class="far fa-keyboard"></i> 자리연습 OFF';
    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }
    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });
  helpModalClose.addEventListener('click', hideHelpModal);
  freestyleInputAreaEl.addEventListener('input', () => {
    soundPlayedForThisInput = false; 
    playTypingSound();
    if (!startTime) {
        startTime = Date.now();
    }
    updateFreestyleStats();
  });
  freestyleInputAreaEl.addEventListener('keydown', (e) => {
    soundPlayedForThisInput = false;
    if (e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
        playTypingSound();
    }
  });
  downloadFreestyleBtnEl.addEventListener('click', handleFreestyleDownload);
  insertDateBtn.addEventListener('click', insertDate);
  insertTimeBtn.addEventListener('click', insertTime);
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('visible');
  });
  emojiPicker.querySelectorAll('span').forEach(emoji => {
    emoji.addEventListener('click', () => {
        insertAtCursor(freestyleInputAreaEl, emoji.textContent);
        emojiPicker.classList.remove('visible');
        freestyleInputAreaEl.focus();
    });
  });
  copyAllBtn.addEventListener('click', copyAllFreestyleText);
  clearAllBtn.addEventListener('click', clearAllFreestyleText);
  insertHrBtn.addEventListener('click', () => insertAtCursor(freestyleInputAreaEl, '\n\n---\n\n'));
  longTextSelectEl.addEventListener('change', () => {
      const lang = languageSelectEl.value;
      const mode = lang + 'Long';
      startPractice(mode, false);
  });
  
 const copyEmailBtn = document.getElementById('copyEmailBtn');
  if (copyEmailBtn) {
    copyEmailBtn.addEventListener('click', () => {
      const email = 'keytherapy@naver.com';
      navigator.clipboard.writeText(email).then(() => {
        showSharePopup('이메일 주소가 복사되었습니다!');
      }).catch(err => {
        console.error('이메일 복사 실패:', err);
        showSharePopup('복사에 실패했습니다.');
      });
    });
  }

  applyFontFamily("'Gowun Dodum', sans-serif");
  
  document.addEventListener('keydown', (e) => {
    const activeElTag = document.activeElement.tagName.toLowerCase();
    
    const isOverlayVisible = gameOverlayEl && gameOverlayEl.classList.contains('visible');
    const isStartMsgVisible = gameStartMessageEl && gameStartMessageEl.style.display !== 'none';

    if ((isOverlayVisible || isStartMsgVisible) && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        const nextBtn = document.getElementById('nextStepBtnOverlay');
        const startBtn = document.getElementById('startGameBtn');
        if (isOverlayVisible && nextBtn) nextBtn.click();
        else if (isStartMsgVisible && startBtn) startBtn.click();
        return;
    }

    if (e.key === 'Escape') {
      if (helpModal.classList.contains('visible')) {
          hideHelpModal();
      } else if (!document.body.classList.contains('game-mode-active')) {
          if (toggleLayoutBtn) {
              toggleLayoutBtn.click();
          }
      }
    }

    if (activeElTag === 'input' || activeElTag === 'textarea') {
      if (e.altKey) {
        if (document.activeElement.id === 'freestyle-filename-input') return;
      } else {
        return;
      }
    }

        if (e.altKey) {
        e.preventDefault();

                       // 수정된 코드
switch (e.key.toLowerCase()) { // 대소문자 구분 없이 처리하기 위해 toLowerCase() 추가
    // === 네비게이션 단축키 ===
    case 'arrowdown':
        if (currentMode === 'game' && currentGameType) {
            if (!isOverlayVisible) {
                handleGameEnd(false, 'level_change'); // 게임 레벨 변경 시 재시작
            }
        } else if (currentMode !== 'freestyle') {
            restartCurrentPractice(); // 현재 연습 다시 시작
        }
        break;
    
    case 'arrowright':
        if (currentMode === 'game' && currentGameType) {
            if (!isOverlayVisible) changeGameLevel(1);
        } else if (currentMode.endsWith('Long')) {
            changeLongText(1);
        } else if (currentMode !== 'freestyle') {
            startPractice(currentMode, false);
        }
        break;

    case 'arrowleft':
        if (currentMode === 'game' && currentGameType) {
            if (!isOverlayVisible) changeGameLevel(-1);
        } else if (currentMode.endsWith('Long')) {
            changeLongText(-1);
        } else if (currentMode !== 'freestyle') {
            startPractice(currentMode, false);
        }
        break;

    // === 기능 토글 단축키 ===
    case "'": // 다음 타건음
        if (soundPackSelectEl) {
            let currentIndex = soundPackSelectEl.selectedIndex;
            let nextIndex = (currentIndex + 1) % soundPackSelectEl.options.length;
            soundPackSelectEl.selectedIndex = nextIndex;
            soundPackSelectEl.dispatchEvent(new Event('change'));
        }
        break;
        
    case ';': // 이전 타건음
        if (soundPackSelectEl) {
            let currentIndex = soundPackSelectEl.selectedIndex;
            let prevIndex = (currentIndex - 1 + soundPackSelectEl.options.length) % soundPackSelectEl.options.length;
            soundPackSelectEl.selectedIndex = prevIndex;
            soundPackSelectEl.dispatchEvent(new Event('change'));
        }
        break;
    
    // [수정된 단축키]
    case 'm': // 타건음 ON/OFF (기존 Alt+N에서 변경)
        if (toggleSoundBtn) toggleSoundBtn.click();
        break;

    case ',': // 오타체크 ON/OFF (새로 할당)
        if (toggleHighlightBtn) toggleHighlightBtn.click();
        break;
    
    case '.': // 측정 ON/OFF (유지)
        if (toggleStatsBtn) toggleStatsBtn.click();
        break;

    case '/': // 자리연습 ON/OFF (유지)
        if (toggleKeyboardGuideBtn) toggleKeyboardGuideBtn.click();
        break;
}
    }
  });

  const savedLayoutState = localStorage.getItem('layoutCollapsed') === 'true';
  if (savedLayoutState) {
      layoutCollapsed = true;
      updateLayout();
  }
  
  window.addEventListener('resize', alignInputField);

  startPractice('kor', true);
  setTimeout(() => {
    document.body.classList.remove('no-transition');
  }, 100);
});

function applyFontFamily(family) {
    const root = document.documentElement;
    const config = fontConfig[family] || { scale: 1.0 };
    
    root.style.setProperty('--font-typing', family);
    root.style.setProperty('--font-scale-multiplier', config.scale);
}

function cleanupActiveModes() {
    document.body.classList.remove('game-mode-active', 'freestyle-mode-active', 'focus-mode-active');
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    freestyleStatsInterval = null;
    startTime = null;
    if(typingInputField) typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    if(gameInputField) gameInputField.removeEventListener('keydown', handleKeyDownEvent);
    enablePracticeControls();
}
function disableFreestyleControls() {
    toggleHighlightBtn.classList.add('disabled');
    toggleKeyboardGuideBtn.classList.add('disabled');
    languageSelectEl.closest('.language-settings').classList.add('disabled');
}

function enablePracticeControls() {
    toggleHighlightBtn.classList.remove('disabled');
    toggleKeyboardGuideBtn.classList.remove('disabled');
    languageSelectEl.closest('.language-settings').classList.remove('disabled');
}
function populateLongTextDropdown(lang) {
    const source = sentencePool[lang + 'Long'];
    if (!longTextSelectEl || !source) return;

    longTextSelectEl.innerHTML = '';

    const randomOption = document.createElement('option');
    randomOption.value = "-1";
    randomOption.textContent = "랜덤";
    longTextSelectEl.appendChild(randomOption);

    source.forEach((item, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = item.title;
        longTextSelectEl.appendChild(option);
    });
}
function startPractice(mode, resetSessionStats = false) {
    cleanupActiveModes();
    currentMode = mode;
    currentGameType = '';

    const isLongMode = mode.endsWith('Long');
    const lang = mode.replace('Long', '');

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        const type = btn.dataset.practiceType;
        btn.classList.toggle('active', (isLongMode && type === 'long') || (!isLongMode && type === 'short'));
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    if (longTextSelectContainerEl) {
        longTextSelectContainerEl.classList.toggle('hidden', !isLongMode);
    }
    
    if(resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';
    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }
    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }
    currentLineStartTime = null;
    currentArticleCorrectChars = 0;
    currentDisplayLineIndex = 0;
    
    const source = sentencePool[mode];
    let textToPractice = "";
    let titleToDisplay = "";

    if (!source || source.length === 0) {
        linesToPractice = ["선택한 언어 또는 모드에 대한 예문이 없습니다."];
    } else {
        if (isLongMode) {
            if (resetSessionStats) {
                populateLongTextDropdown(lang);
            }
            
            let selectedIndex = parseInt(longTextSelectEl.value, 10);
            
            if (resetSessionStats || selectedIndex === -1 || isNaN(selectedIndex)) {
                const randomIndex = Math.floor(Math.random() * source.length);
                textToPractice = source[randomIndex].content;
                titleToDisplay = source[randomIndex].title;
                longTextSelectEl.value = randomIndex;
            } else {
                textToPractice = source[selectedIndex].content;
                titleToDisplay = source[selectedIndex].title;
            }
        } else {
            textToPractice = getRandom(source);
        }
        linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    }

    if (practiceTitleDisplayEl) {
        practiceTitleDisplayEl.textContent = titleToDisplay;
    }
    
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    
    if (progressBarContainerEl) {
        progressBarContainerEl.style.display = isLongMode && linesToPractice.length > 1 ? 'block' : 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();
    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}
function startFreestyleMode() {
    cleanupActiveModes();
    document.body.classList.add('freestyle-mode-active');
    currentMode = 'freestyle';
    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === 'freestyle');
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');
    if (longTextSelectContainerEl) {
        longTextSelectContainerEl.classList.add('hidden');
    }
    disableFreestyleControls();
    if (statsVisible) {
        statsVisible = false;
        toggleStatsBtn.classList.remove('active');
        toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
        statsEl.classList.add('hidden');
    }
    if (toggleHighlightBtn.classList.contains('active')) toggleHighlightBtn.classList.remove('active');
    if (toggleKeyboardGuideBtn.classList.contains('active')) toggleKeyboardGuideBtn.classList.remove('active');
    highlightEnabled = false;
    keyboardGuideEnabled = false;
    if (keyboardGuideEl) keyboardGuideEl.classList.remove('visible');
    if (resultEl) resultEl.textContent = '자유롭게 글을 작성하고 타건을 즐겨보세요.';
    startTime = null;
    overallMaxSpeed = 0;
    overallAvgSpeedLog = [];
    sessionTotalValidChars = 0;
    sessionTotalCorrectChars = 0;
    sessionTotalMistypedChars = 0;
    lastArticleSpeed = 0;
    updateStatsDisplay(true);
    if (document.getElementById('accuracyStat')) document.getElementById('accuracyStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('avgSpeedStat')) document.getElementById('avgSpeedStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('maxSpeedStat')) document.getElementById('maxSpeedStat').innerHTML = '<span class="value">—</span>';
    freestyleInputAreaEl.value = '';
    freestyleInputAreaEl.focus();
    updateFreestyleStats();
    if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    freestyleStatsInterval = setInterval(updateFreestyleStats, 500);
}
function updateFreestyleStats() {
    if (currentMode !== 'freestyle') {
        if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
        return;
    };
    const text = freestyleInputAreaEl.value;
    const charLength = text.length;
    const wordLength = text.trim().split(/\s+/).filter(Boolean).length;
    charCountEl.textContent = `${charLength}자`;
    wordCountEl.textContent = `${wordLength}단어`;
    if (startTime) {
        const elapsedMinutes = (Date.now() - startTime) / 60000;
        if (elapsedMinutes > 0) {
            const speed = Math.round((charLength / elapsedMinutes) * KOR_SPEED_FACTOR);
            if (statsVisible && document.getElementById('speedStat')) {
                document.getElementById('speedStat').textContent = `${speed} 타/분`;
            }
        }
    }
}
function handleFreestyleDownload() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        alert('저장할 내용이 없습니다.');
        return;
    }
    let filename = freestyleFilenameInputEl.value.trim();
    if (filename === '') {
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        filename = `keytherapy_${timestamp}`;
    }
    if (!filename.toLowerCase().endsWith('.txt')) {
        filename += '.txt';
    }
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function insertAtCursor(myField, myValue) {
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length;
        myField.selectionEnd = startPos + myValue.length;
    } else {
        myField.value += myValue;
    }
    updateFreestyleStats();
    myField.focus();
}
function copyAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        showSharePopup("복사할 내용이 없습니다.");
        return;
    }
    navigator.clipboard.writeText(text).then(() => {
        showSharePopup("클립보드에 복사되었습니다.");
    }).catch(err => {
        console.error('클립보드 복사 실패:', err);
        showSharePopup("복사에 실패했습니다.");
    });
    freestyleInputAreaEl.focus();
}
function clearAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') return;
    if (confirm("정말 모든 내용을 삭제하시겠습니까?")) {
        freestyleInputAreaEl.value = '';
        updateFreestyleStats();
        freestyleInputAreaEl.focus();
    }
}
function insertDate() {
    const now = new Date();
    const dateString = `${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일`;
    insertAtCursor(freestyleInputAreaEl, dateString + " ");
}
function insertTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const formattedHours = (hours % 12) || 12;
    const timeString = `${ampm} ${formattedHours}:${minutes}`;
    insertAtCursor(freestyleInputAreaEl, timeString + " ");
}
function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function splitTextIntoLines(text, mode, screenWidth) {
    if (mode.startsWith('js') || mode.startsWith('python')) {
        return text.split('\n');
    }
    let maxLength;
    if (mode.endsWith('Long')) {
        if (screenWidth <= 480) maxLength = mode.startsWith('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.startsWith('eng') ? 55 : 35;
        else maxLength = mode.startsWith('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }
    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.endsWith('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}
function handleHighlightUpdate(typedValue, originalLine) {
    if (typeof originalLine !== 'string' || !originalLine) {
        return ' ';
    }

    let builtHTML = "";
    let originalIdx = 0;
    let typedIdx = 0;

    // 입력된 텍스트나 원본 텍스트 중 하나라도 끝에 도달할 때까지 반복
    while (originalIdx < originalLine.length || typedIdx < typedValue.length) {
        const originalChar = originalLine[originalIdx];
        const typedChar = typedValue[typedIdx];

        // 1. 원본 텍스트는 끝났는데 사용자가 더 입력한 경우 (글자 수 추가 오타)
        if (originalIdx >= originalLine.length) {
            // 남은 오타 글자들을 highlight 처리
            const remainingTyped = typedValue.substring(typedIdx).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
            builtHTML += `<span class="highlight">${remainingTyped}</span>`;
            break; // 더 이상 비교할 원본이 없으므로 종료
        }

        // 2. 입력된 텍스트가 아직 원본보다 짧은 경우 (아직 입력 안 한 부분)
        if (typedIdx >= typedValue.length) {
            // [핵심 수정] 남은 텍스트 전체를 가져와서 formatCodeLineForDisplay로 처리
            const remainingLine = originalLine.substring(originalIdx);
            builtHTML += `<span class="untyped-char">${formatCodeLineForDisplay(remainingLine)}</span>`;
            break; // 나머지 부분을 한 번에 처리했으므로 루프 종료
        }

        const displayChar = originalChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');

        // 3. 글자가 정확히 일치하는 경우
        if (originalChar === typedChar) {
            builtHTML += `<strong>${displayChar}</strong>`;
            originalIdx++;
            typedIdx++;
        }
        // 4. 글자가 일치하지 않는 경우 (지능적 오타 처리)
        else {
            // [삭제 오타 감지] 사용자가 한 글자 건너뛰었는가?
            if (originalIdx + 1 < originalLine.length && originalLine[originalIdx + 1] === typedChar) {
                builtHTML += `<span class="highlight">${displayChar}</span>`; // 건너뛴 글자를 오타 처리
                originalIdx++;
            }
            // [삽입 오타 감지] 사용자가 한 글자 더 쳤는가?
            else if (typedIdx + 1 < typedValue.length && originalChar === typedValue[typedIdx + 1]) {
                const wrongTypedChar = typedChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                builtHTML += `<span class="highlight">${wrongTypedChar}</span>`; // 잘못 삽입된 글자를 오타 처리
                typedIdx++;
            }
            // [단순 오타] 위 두 경우가 모두 아니면 단순 오타로 처리
            else {
                builtHTML += `<span class="highlight">${displayChar}</span>`;
                originalIdx++;
                typedIdx++;
            }
        }
    }

    return builtHTML || ' ';
}
function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';
    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();
    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.innerHTML = `<span>${formatCodeLineForDisplay(passedLineText)}</span>`;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);
    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');
    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        const highlightedHTML = handleHighlightUpdate("", currentLineText);
        currentEl.innerHTML = `<span>${highlightedHTML}</span>`;
    } else {
        currentEl.innerHTML = '<span>&nbsp;</span>';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);
    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        const upcomingEl = document.createElement('div');
        upcomingEl.classList.add('typing-line', 'upcoming');
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            upcomingEl.innerHTML = `<span>${formatCodeLineForDisplay(upcomingLineText)}</span>`;
        } else {
            upcomingEl.innerHTML = '<span>&nbsp;</span>';
            upcomingEl.style.visibility = 'hidden';
        }
        fragmentUpcoming.appendChild(upcomingEl);
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
    alignInputField();
}

function isSpecialCharacter(char) {
    return /[.,?!;:'"(){}[\]\/\-=\+_`~@#$%^&*|\\<>]/.test(char);
}
function isSpecialCharacterForAutoComplete(char) {
    return /[.,?!;:'"(){}[\]\/\-=\+_`~@#$%^&*|\\<>]/.test(char);
}
function formatCodeLineForDisplay(line) {
    if (!line) return '';
    const isCodeMode = currentMode.startsWith('js') || currentMode.startsWith('python');
    if (isCodeMode) {
        const match = line.match(/^( +)/);
        if (match) {
            const spaces = match[1];
            const restOfLine = line.substring(spaces.length);
            const visibleSpaces = `<span class="whitespace-char">${'·'.repeat(spaces.length)}</span>`;
            const escapedRest = restOfLine.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
            return visibleSpaces + escapedRest;
        }
    }
    return line.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
}

function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;

    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">타자 연습 시작...</span>`;
        return;
    }
    
    const placeholder = fakeInputField.querySelector('.placeholder');
    if (placeholder) placeholder.remove();

    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span><span id="cursor"></span></span>`;
    } else {
        const escapedValue = typedValue.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
        fakeInputField.innerHTML = `<span>${escapedValue}<span id="cursor"></span></span>`;
    }
}

function getTypingAnalysis(typedValue, originalLine) {
    if (!originalLine) {
        return { html: `<span class="highlight">${typedValue}</span>`, effectiveIndex: 0, correctChars: 0 };
    }
    if (typedValue.length === 0) {
        return {
            html: `<span class="untyped-char">${formatCodeLineForDisplay(originalLine)}</span>`,
            effectiveIndex: 0,
            correctChars: 0
        };
    }

    let builtHTML = "";
    let typedIdx = 0;
    let originalIdx = 0;
    let correctChars = 0;

    while (typedIdx < typedValue.length && originalIdx < originalLine.length) {
        const originalChar = originalLine[originalIdx];
        const typedChar = typedValue[typedIdx];
        const safeOriginalChar = originalChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/ /g, ' ');
        const safeTypedChar = typedChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/ /g, ' ');
        
        const errorTag = highlightEnabled ? 'span' : 'strong';
        const highlightClass = highlightEnabled ? 'highlight' : '';

        if (typedChar === originalChar) {
            builtHTML += `<strong>${safeOriginalChar}</strong>`;
            correctChars++;
            typedIdx++;
            originalIdx++;
        } else {
            const nextOriginalChar = (originalIdx + 1 < originalLine.length) ? originalLine[originalIdx + 1] : null;
            const nextTypedChar = (typedIdx + 1 < typedValue.length) ? typedValue[typedIdx + 1] : null;
            
            if (typedChar === nextOriginalChar) {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeOriginalChar}</${errorTag}>`;
                originalIdx++;
            } else if (nextTypedChar === originalChar) {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeTypedChar}</${errorTag}>`;
                typedIdx++;
            } else {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeOriginalChar}</${errorTag}>`;
                typedIdx++;
                originalIdx++;
            }
        }
    }

    if (typedIdx < typedValue.length) {
        const remainingTyped = typedValue.substring(typedIdx).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
        const highlightClass = highlightEnabled ? 'highlight' : '';
        builtHTML += `<span class="${highlightClass}">${remainingTyped}</span>`;
    }

    if (originalIdx < originalLine.length) {
        const remaining = originalLine.substring(originalIdx);
        builtHTML += `<span class="untyped-char">${formatCodeLineForDisplay(remaining)}</span>`;
    }

    return { html: builtHTML, effectiveIndex: originalIdx, correctChars: correctChars };
}

// ▼▼▼▼▼ 기존 handleInputEvent 함수 ▼▼▼▼▼
// ▼▼▼▼▼ 이 함수 전체를 복사해서 기존 함수와 교체하세요. ▼▼▼▼▼
function handleInputEvent(e) {
    if (isProgrammaticallyChangingInput) {
        return;
    }

    playTypingSound();

    if (currentMode !== 'game' && currentMode !== 'freestyle' && e.target === typingInputField) {
        const typedValue = e.target.value;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        // --- 1. 시각적 업데이트는 항상 즉시 실행 ---
        const analysis = getTypingAnalysis(typedValue, originalLine);
        
        const currentLineEl = document.getElementById('current-typing-line');
        if (currentLineEl) {
            const innerSpan = currentLineEl.querySelector('span');
            if (innerSpan) innerSpan.innerHTML = analysis.html;
        }
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight();

        // --- 2. 한글 조합 중이라면 여기서 실행을 멈춤 ---
        if (isComposingNow) {
            return;
        }
        
        // --- 3. 조합이 끝난 후에만 아래의 기능적 로직을 실행 ---
        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        
        // [핵심 수정] 모든 입력 후, 입력값과 원본이 정확히 일치하는지 확인
        if (typedValue === originalLine) {
            processCurrentLineCompletion();
            return; // 일치하면 즉시 함수를 종료하여 아래 로직을 타지 않도록 함
        }

        // ▼▼▼▼▼ [스페이스바를 이용한 중간 특수문자 자동 완성 로직] ▼▼▼▼▼
        const isDeletion = e.inputType && e.inputType.startsWith('delete');
        const justTypedSpace = typedValue.endsWith(' ');

        if (autoCompleteEnabled && !isDeletion && justTypedSpace) {
            const baseTyped = typedValue.slice(0, -1);
            const analysisForBase = getTypingAnalysis(baseTyped, originalLine);
            let startIndex = analysisForBase.effectiveIndex;
            let textToAppend = "";

            while (startIndex < originalLine.length && isSpecialCharacterForAutoComplete(originalLine[startIndex])) {
                textToAppend += originalLine[startIndex];
                startIndex++;
            }

            if (textToAppend.length > 0) {
                isProgrammaticallyChangingInput = true;
                
                const isLineNowComplete = (analysisForBase.effectiveIndex + textToAppend.length === originalLine.length);

                if (isLineNowComplete) {
                    typingInputField.value = baseTyped + textToAppend;
                    processCurrentLineCompletion(); 
                    
                    setTimeout(() => {
                        isProgrammaticallyChangingInput = false;
                    }, 0);
                    return;
                } else {
                    const finalReplacement = textToAppend + ' ';
                    const newTypedValue = baseTyped + finalReplacement;
                    
                    typingInputField.value = newTypedValue;
                    
                    const newAnalysis = getTypingAnalysis(newTypedValue, originalLine);
                    const innerSpan = document.querySelector('#current-typing-line span');
                    if (innerSpan) innerSpan.innerHTML = newAnalysis.html;
                    updateFakeInput(newTypedValue, false);
                    updateKeyboardHighlight();

                    setTimeout(() => {
                        isProgrammaticallyChangingInput = false;
                    }, 0);
                }
            }
        }
        // ▲▲▲▲▲ [자동 완성 로직 끝] ▲▲▲▲▲
    }
}
function handleKeyDownEvent(e) {
    if (e.isComposing) return;
    playTypingSound();
    const targetInput = e.target;
    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }
   if (currentMode !== 'game' && currentMode !== 'freestyle' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;
        if (e.key === 'Enter') {
            e.preventDefault();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            processCurrentLineCompletion();
        }
    }
}

// ▼▼▼▼▼ 이 함수 전체를 복사해서 기존 함수와 교체하세요. ▼▼▼▼▼

function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        // 이미 연습이 끝난 상태에서 Enter를 누르면 새 연습 시작
        startPractice(currentMode, true); // 새 연습은 통계 리셋
        return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, true); // 새 연습은 통계 리셋
        return;
    }

    const analysis = getTypingAnalysis(typedValue, originalLine);
    const lineCorrectCharsThisLine = analysis.correctChars;
    const lineMistypedCharsOnThisLine = typedValue.length - lineCorrectCharsThisLine;

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;
    
    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * speedFactor);
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * speedFactor);
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }

    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;
    if (!currentMode.endsWith('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }

    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.endsWith('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        // 모든 줄이 끝났을 때
        updateStatsDisplay(false);
        updateProgressBar();

        if (currentMode.endsWith('Long')) {
            const finalAccuracy = sessionTotalValidChars > 0 ? Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100) : 0;
            const avgSpeed = overallAvgSpeedLog.length > 0 ? Math.round(overallAvgSpeedLog.reduce((a, b) => a + b, 0) / overallAvgSpeedLog.length) : 0;
            
            const resultData = {
                type: 'practice',
                title: '연습 완료!',
                stats: {
                    "평균 속도": `${avgSpeed} 타/분`,
                    "최고 속도": `${overallMaxSpeed} 타/분`,
                    "정확도": `${finalAccuracy}%`
                },
                nextAction: () => {
                    if (longTextSelectEl) {
                        longTextSelectEl.value = "-1";
                    }
                    startPractice(currentMode, true);
                },
                nextActionText: "다음 글 (Enter)"
            };
            
            showResultOverlay(resultData);
            
            currentArticleCorrectChars = 0;
            startTime = null;
        } else {
            if(resultEl) resultEl.textContent = '연습 완료! 새로운 문제 준비 중...';
            // [핵심 변경] 단문 연습이 끝나고 다음 문제로 넘어갈 때, 세션 통계를 유지하도록 false로 변경
            setTimeout(() => startPractice(currentMode, false), 200);
        }
    }
}

// ▼▼▼▼▼ 이 함수 전체를 복사해서 기존 함수와 교체하세요. ▼▼▼▼▼
function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;

  let currentSpeedToShow = 0;
  if (isSessionReset) {
      // 세션이 완전히 리셋될 때 (예: 모드 변경) 모든 값을 0으로 설정
      currentSpeedToShow = 0;
  } else if (currentMode.endsWith('Long') && startTime && currentArticleCorrectChars > 0) {
      // 장문 연습 중일 때: 실시간 타수 표시
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * speedFactor);
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      // 단문 연습 중이거나, 장문 연습 시작 전: 마지막으로 완료한 문장의 타수를 표시
      currentSpeedToShow = lastArticleSpeed;
  }

  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;

  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;

  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;
  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} 타/분`;
}
function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.endsWith('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}
function activateGameMode(gameType) {
    cleanupActiveModes();
    document.body.classList.add('game-mode-active');
    currentMode = 'game';
    currentGameType = gameType;
    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;
    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;
    gameStartMessageEl = gameAreaContainerEl.querySelector('#game-start-message');
    gameCanvas = gameAreaContainerEl.querySelector('#game-canvas');
    if (gameCanvas) {
        gameCtx = gameCanvas.getContext('2d');
    } else {
        console.error("activateGameMode: game-canvas 요소를 찾을 수 없습니다.");
        return;
    }
    gameInputField = gameAreaContainerEl.querySelector('#game-input-field');
    gameOverlayEl = gameAreaContainerEl.querySelector('#gameOverlay');
    itemEffectPopupEl = gameAreaContainerEl.querySelector('#item-effect-popup');
    lbbTimerBarContainerEl = gameAreaContainerEl.querySelector('#lbb-timer-bar-container');
    lbbTimerBarEl = gameAreaContainerEl.querySelector('#lbb-timer-bar');
    lbbTimerTextEl = gameAreaContainerEl.querySelector('#lbb-timer-text');
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }
    const gameTypeRow = gameAreaContainerEl.querySelector('#gameTypeSelectionRow');
    const settingsRow1 = gameAreaContainerEl.querySelector('#gameSettingsRow1');
    const settingsRow2 = gameAreaContainerEl.querySelector('#gameSettingsRow2');
    if (!gameTypeRow || !settingsRow1 || !settingsRow2) {
        console.error("게임 컨트롤 바 요소를 찾을 수 없습니다. HTML 구조를 확인하세요.");
        return;
    }
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('rainfall');
    });
    gameTypeRow.appendChild(sonagiBtn);
    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('letterBlockBattle');
    });
    gameTypeRow.appendChild(letterBlockBtn);
    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> 타이핑 배틀';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('giantBattle');
    });
    gameTypeRow.appendChild(typingBattleBtn);
    settingsRow1.innerHTML = ''; 
    settingsRow2.innerHTML = '';
    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);
    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);
    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);
    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';
    let maxLevelForSelect;
    let currentLevelForSelect;
    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }
    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
     gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        let isCountingDown = !!countdownTimerId;

        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }
        if (isActive || isCountingDown) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);
    settingsRow2.appendChild(levelControlItem);
    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);
    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);
    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }

    const startGameButtonHTML = `<button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작 (Enter)</button>`;
    
    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 생명)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3초 멈춤)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (화면 정리)</div>
             </div>
             ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>상하좌우 블록의 단어를 입력하여 이동하고, 적과 빈 칸으로 연결되면 승리합니다!<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> 타이핑 배틀</h2>
            <p>쏟아지는 단어들을 정확히 입력하여 적의 공격을 막아내고,<br>당신의 공격 단어로 적을 격파하세요! 2분 안에 승리하세요!</p>
            <p>레벨을 선택하고 게임 시작 버튼을 누르세요.</p>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
    document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.classList.add('active');
    }
}
function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}
function showSharePopup(message) {
    const popup = document.getElementById('result-share-popup');
    popup.textContent = message;
    popup.style.opacity = '1';
    popup.style.transform = 'translateX(-50%) translateY(0)';
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(20px)';
    }, 2000);
}
// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);

    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}
function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }

        drawRainfallGame();

        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }

        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}
function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }

    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) {
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}
function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }

    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`점수: ${rainfall_gameScore}`, 15 + 40, 30);

    gameCtx.textAlign = 'center';
    gameCtx.fillText(`레벨: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);

    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`생명: ${'❤️'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;

        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;

        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}
function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

            function generateWord() {
                if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;

                let newWordText;
                let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
                let itemDetails = null;

                if (isItem) {
                    const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
                    itemDetails = getRandom(itemTypes);
                    newWordText = itemDetails.text;
                } else {
                    const wordPool = gameWordsKor.filter(w => w.length <= 4);
                    const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
                    newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
                    if (!newWordText) newWordText = '단어';
                }

                rainfall_usedWordsInLevel.add(newWordText);
                if (rainfall_usedWordsInLevel.size > 100) {
                    const oldestWord = rainfall_usedWordsInLevel.values().next().value;
                    rainfall_usedWordsInLevel.delete(oldestWord);
                }

                const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

                rainfall_wordsOnScreen.push({
                    text: newWordText,
                    x: Math.random() * (gameCanvas.width - 100) + 50,
                    y: -20,
                    speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
                    isFast: isFast,
                    itemType: isItem ? itemDetails.type : null,
                    color: isItem ? itemDetails.color : null,
                    duration: isItem ? itemDetails.duration : 0
                });
            }

            generateWord();
            rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
        }
        function handleRainfallGameInputSubmit() {
            if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
            const typedWord = gameInputField.value.trim();
            if (typedWord === "") return;

            const wordsToKeep = [];
            const matchedWords = [];

            // 1. 입력된 단어와 일치하는 단어와 그렇지 않은 단어를 분리합니다.
            for (const word of rainfall_wordsOnScreen) {
                if (word.text === typedWord) {
                    matchedWords.push(word);
                } else {
                    wordsToKeep.push(word);
                }
            }

            // 2. 일치하는 단어가 있었는지 확인합니다.
            if (matchedWords.length > 0) {
                // 화면에 남을 단어 목록을 미리 업데이트하여 충돌을 방지합니다.
                rainfall_wordsOnScreen = wordsToKeep;

                // 3. 일치했던 모든 단어의 효과를 처리합니다.
                for (const word of matchedWords) {
                    if (word.itemType) {
                        // 아이템 효과를 발동시킵니다.
                        activateRainfallItemEffect(word.itemType, word.duration);
                    } else {
                        // 일반 단어는 점수를 추가합니다.
                        rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
                    }
                }
            } else {
                // 일치하는 단어가 없으면 입력창에 효과를 줍니다.
                if(gameInputField) gameInputField.classList.add('shake-effect');
                setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
            }
            
            gameInputField.value = "";
        }
        function activateRainfallItemEffect(itemType, duration) {
            let popupText = "";
            const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
            if (!itemInfo) return;

            switch(itemType) {
                case 'extraLife':
                    if (rainfall_gameLives < 10) rainfall_gameLives++;
                    popupText = `생명 +1 ${itemInfo.icon}`;
                    break;
                case 'timeStop':
                    rainfall_isTimeStopped = true;
                    popupText = `시간 정지! ${itemInfo.icon}`;
                    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
                    window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
                    break;
                case 'clearScreen':
                    popupText = `화면 정리! ${itemInfo.icon}`;
                    for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                        if (!rainfall_wordsOnScreen[j].itemType) {
                            rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                            rainfall_wordsOnScreen.splice(j, 1);
                        }
                    }
                    break;
            }
            if (popupText) showGamePopup(popupText, 1500);
        }
        function triggerRainfallLifeLostEffect() {
            if (gameCanvas) {
                gameCanvas.classList.add('flash-effect');
                setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
            }
        }
        // --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
        function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
            if(level) lbb_gameLevel = level;
            if(fromStartButtonOrNextLevel) {
                if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
                if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
            }

            if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
            if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
            if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
            if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;

            lbb_isGameActive = true;
            lbb_gamePausedForOverlay = false;
            lbb_gamePausedForEffect = false;
            lbb_isRelocating = false;

            lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];

            lbb_playerScore = 0;
            lbb_enemyScore = 0;

            generateLBBGameBoard();
            lbb_playerPos = { r: 0, c: 0 };
            lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
            lbb_enemyOriginalStartPos = { ...lbb_enemyPos };

            if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
                lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
            }
            if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
                lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
            }

            if (gameInputField) {
                gameInputField.disabled = false;
                gameInputField.value = '';
                gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
                setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
            }

            lbb_gameStartTime = Date.now();
            lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
            startLBBGameLoop();
        }

        function startLBBGameLoop() {
            if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
            function loop() {
                if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
                    cancelAnimationFrame(lbb_gameLoopId);
                    lbb_gameLoopId = null;
                    return;
                }
                drawLetterBlockBattleGame();
                if(lbb_isGameActive && !lbb_gamePausedForOverlay){
                    updateLBBGameLogic();
                }
                lbb_gameLoopId = requestAnimationFrame(loop);
            }
            lbb_gameLoopId = requestAnimationFrame(loop);
        }

        function updateLBBGameLogic() {
            if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

            if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
                handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
                return;
            }

            if (lbb_swapEffect.active) {
                updateLBBSwapAnimation();
            } else if (lbb_finalBattleAnimation.isActive) {
                updateLBBFinalBattleAnimation();
            } else {
                if (!lbb_isRelocating) {
                     checkAndTriggerPlayerLBBRelocation();
                }
            }

            lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
            lbb_blockBreakParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.alpha -= 0.02;
            });
        }

        function drawLetterBlockBattleGame() {
            if (!gameCtx || !gameCanvas) return;

            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
                return;
            }

            const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
            const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
            const boardX = (gameCanvas.width - boardWidth) / 2;
            const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

            const bodyClasses = document.body.classList;
            let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
            if (bodyClasses.contains('light-theme')) {
                textColor = '#524a42';
                inputBgColor = '#fefcf9';
                brokenColor = '#f9f5f0';
                playerBlockBg = '#fffacd';
                playerColor = '#4A90E2';
                enemyColor = '#D0021B';
            } else if (bodyClasses.contains('pink-theme')) {
                textColor = '#4F333D';
                inputBgColor = '#fffafa';
                brokenColor = '#fff5f8';
                playerBlockBg = '#ffe8f0';
                playerColor = '#E91E63';
                enemyColor = '#7B1FA2';
            } else {
                textColor = '#e8e0d8';
                inputBgColor = '#33302e';
                brokenColor = '#262422';
                playerBlockBg = 'rgba(212, 175, 122, 0.08)';
                playerColor = 'dodgerblue';
                enemyColor = 'tomato';
            }

            const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();

            for (let r = 0; r < LBB_BOARD_ROWS; r++) {
                for (let c = 0; c < LBB_BOARD_COLS; c++) {
                    const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
                    if (!block) continue;

                    const x = boardX + c * LBB_BLOCK_SIZE;
                    const y = boardY + r * LBB_BLOCK_SIZE;

                    gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

                    if (!block.broken) {
                        const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                        if (isPlayerAdjacent) {
                            gameCtx.fillStyle = playerBlockBg;
                            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                        }

                        gameCtx.font = lbb_blockTextFont;
                        gameCtx.textAlign = 'center';
                        gameCtx.textBaseline = 'middle';
                        gameCtx.fillStyle = block.effect.color || textColor;
                        gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                        if (block.effect.icon) {
                            gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                            gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                        }
                    }
                    gameCtx.strokeStyle = borderColor;
                    gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }
            }

            lbb_blockBreakParticles.forEach(p => {
                gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
                gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
            });

            function drawCharacter(pos, color, isPlayer) {
                const x = boardX + pos.c * LBB_BLOCK_SIZE;
                const y = boardY + pos.r * LBB_BLOCK_SIZE;
                gameCtx.fillStyle = color;
                gameCtx.beginPath();
                gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
                gameCtx.fill();
                if (isPlayer) {
                    gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                    gameCtx.lineWidth = 1;
                }
            }

            if (lbb_swapEffect.active) {
                drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
                drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
            } else if (lbb_finalBattleAnimation.isActive) {
                drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
                drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
            } else {
                drawCharacter(lbb_playerPos, playerColor, true);
                drawCharacter(lbb_enemyPos, enemyColor, false);
            }

            gameCtx.font = "bold 18px 'Poppins', sans-serif";
            gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
            gameCtx.shadowBlur = 4;
            gameCtx.textAlign = 'left';
            gameCtx.fillStyle = playerColor;
            gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 15 + 40, 30);
            gameCtx.textAlign = 'right';
            gameCtx.fillStyle = enemyColor;
            gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
            gameCtx.textAlign = 'center';
            gameCtx.fillStyle = textColor;
            gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);

            if (lbb_relocationCountdown > 0) {
                gameCtx.font = "bold 16px 'Poppins', sans-serif";
                gameCtx.fillStyle = 'orange';
                gameCtx.textAlign = 'center';
                gameCtx.fillText(`길을 찾는 중... ${lbb_relocationCountdown}초`, gameCanvas.width / 2, gameCanvas.height - 20);
            }

            gameCtx.shadowBlur = 0;

            if (lbbTimerBarContainerEl && lbb_isGameActive) {
                const elapsedTime = Date.now() - lbb_gameStartTime;
                const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
                if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
                const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
                const minutes = Math.floor(remainingTimeSec / 60);
                const seconds = remainingTimeSec % 60;
                if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function generateLBBGameBoard() {
            lbb_gameBoard = [];
            const wordPoolSource = gameWordsKor;
            const wordPool = wordPoolSource.filter(word => word.length >= 2 && word.length <= 3);

            for (let r = 0; r < LBB_BOARD_ROWS; r++) {
                lbb_gameBoard[r] = [];
                for (let c = 0; c < LBB_BOARD_COLS; c++) {
                    const effectRoll = Math.random();
                    let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
                    if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                        const itemRoll = Math.random();
                        if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                        else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                        else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                        else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
                    }
                    lbb_gameBoard[r][c] = {
                        word: getRandom(wordPool.length > 0 ? wordPool : wordPoolSource),
                        broken: false,
                        effect: effectType
                    };
                }
            }
        }

        function getSurroundingLBBBlocks(pos, checkBroken = true) {
            const blocks = [];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (const [dr, dc] of directions) {
                const r = pos.r + dr;
                const c = pos.c + dc;

                if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
                    const block = lbb_gameBoard[r][c];
                    if (!checkBroken || (block && !block.broken)) {
                        blocks.push({ ...block, r, c });
                    }
                }
            }
            return blocks;
        }

        function handleLetterBlockBattleInputSubmit() {
            if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
            const typedWord = gameInputField.value.trim();
            if (!typedWord) return;

            const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);

            const matchedBlock = surroundingBlocks.find(block => {
                if (!block) return false;
                return block.word === typedWord;
            });

            if (matchedBlock) {
                lbb_playerMoveAndBreak(matchedBlock);
                checkLBBBattleCondition();
            } else {
                if (gameInputField) gameInputField.classList.add('shake-effect');
                setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
            }
            if (gameInputField) gameInputField.value = '';
        }

        function lbb_playerMoveAndBreak(targetBlock) {
            lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
            const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
            block.broken = true;

            lbb_playerScore += block.effect.score;
            lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
            if (block.effect.effect) {
                lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
            }
        }

        function lbb_enemyAIAction() {
            if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;

            const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
            if (surroundingBlocks.length > 0) {
                if (lbb_enemyNoPlayableBlocksTimerId) {
                    clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
                    lbb_enemyNoPlayableBlocksTimerId = null;
                }
                const targetBlock = getRandom(surroundingBlocks);
                lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
                const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
                block.broken = true;
                lbb_enemyScore += block.effect.score;
                lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
                if (block.effect.effect) {
                     lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
                }
                checkLBBBattleCondition();
            } else {
                if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
                    lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                        lbb_initiateRelocation(false);
                        lbb_enemyNoPlayableBlocksTimerId = null;
                    }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
                }
            }
        }

        function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
            lbb_gamePausedForEffect = true;
            let popupText = '';

            switch (effect) {
                case 'freezeEnemy':
                    if (isPlayer) {
                        lbb_isEnemyFrozen = true;
                        popupText = `적 정지! ${icon}`;
                        if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                        lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
                    }
                    break;
                case 'swapPositions':
                    lbb_swapEffect.active = true;
                    lbb_swapEffect.step = 0;
                    lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
                    lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
                    lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
                    lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
                    popupText = `위치 변경! ${icon}`;
                    break;
            }

            if (popupText) {
                showGamePopup(popupText, 1500);
            }

            setTimeout(() => {
                if(effect !== 'swapPositions') lbb_gamePausedForEffect = false;
            }, 500);
        }

        function updateLBBSwapAnimation() {
            if (!lbb_swapEffect.active) return;
            lbb_swapEffect.step++;
            const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

            const playerTarget = lbb_swapEffect.enemyOld;
            const enemyTarget = lbb_swapEffect.playerOld;

            lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
            lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;

            lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
            lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;

            if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
                lbb_swapEffect.active = false;
                lbb_playerPos = { ...playerTarget };
                lbb_enemyPos = { ...enemyTarget };
                lbb_gamePausedForEffect = false;
            }
        }
        function lbb_triggerBlockBreakEffect(r, c, colorHex) {
            const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
            for (let i = 0; i < 15; i++) {
                lbb_blockBreakParticles.push({
                    x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
                    y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    ...colorRgb,
                    alpha: 1
                });
            }
        }

        function checkLBBBattleCondition() {
            const path = findPath(lbb_playerPos, lbb_enemyPos);
            if (path) {
                lbb_triggerFinalBattleAnimation(path);
            }
        }

        function findPath(start, end) {
            const queue = [[start, [start]]];
            const visited = new Set([`${start.r},${start.c}`]);

            while (queue.length > 0) {
                const [current, path] = queue.shift();

                if (current.r === end.r && current.c === end.c) {
                    return path;
                }

                const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);

                for (const neighbor of neighbors) {
                    const posKey = `${neighbor.r},${neighbor.c}`;
                    if (!visited.has(posKey)) {
                        visited.add(posKey);
                        const newPath = [...path, neighbor];
                        queue.push([neighbor, newPath]);
                    }
                }
            }
            return null;
        }
        function lbb_triggerFinalBattleAnimation(pathToMeet) {
            if (lbb_finalBattleAnimation.isActive) return;

            lbb_finalBattleAnimation.isActive = true;
            lbb_finalBattleAnimation.step = 0;
            lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
            lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
            lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
            lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
            lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
        }

        function updateLBBFinalBattleAnimation() {
            if (!lbb_finalBattleAnimation.isActive) return;

            lbb_finalBattleAnimation.step++;
            const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;

            const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
            const meetingC = lbb_finalBattleAnimation.meetingPoint.c;

            lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
            lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
            lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
            lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;

            if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
                lbb_finalBattleAnimation.isActive = false;
                handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
            }
        }
        function checkAndTriggerPlayerLBBRelocation() {
            if(lbb_isRelocating) return;
            const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
            if(surroundingBlocks.length === 0){
                if(!lbb_playerNoPlayableBlocksTimerId) {
                    lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
                    lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                        lbb_initiateRelocation(true);
                        lbb_playerNoPlayableBlocksTimerId = null;
                        clearInterval(lbb_relocationCountdownIntervalId);
                        lbb_relocationCountdownIntervalId = null;
                    }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

                    lbb_relocationCountdownIntervalId = setInterval(() => {
                        lbb_relocationCountdown--;
                        if(lbb_relocationCountdown <= 0) {
                            clearInterval(lbb_relocationCountdownIntervalId);
                            lbb_relocationCountdownIntervalId = null;
                        }
                    }, 1000);
                }
            } else {
                if (lbb_playerNoPlayableBlocksTimerId) {
                    clearTimeout(lbb_playerNoPlayableBlocksTimerId);
                    lbb_playerNoPlayableBlocksTimerId = null;
                }
                if(lbb_relocationCountdownIntervalId) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
                lbb_relocationCountdown = 0;
            }
        }

        function lbb_initiateRelocation(isPlayerRelocation) {
            if (isPlayerRelocation) {
                lbb_isRelocating = true;
                showGamePopup("길이 막혔습니다! 재배치합니다...", 2000);
                setTimeout(() => lbb_performRelocation(true), 1000);
            } else {
                lbb_performRelocation(false);
            }
        }

        function lbb_performRelocation(isPlayerRelocation) {
            const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
            const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);

            if(newPos) {
                if(isPlayerRelocation) {
                    lbb_playerPos = newPos;
                } else {
                    lbb_enemyPos = newPos;
                }
                lbb_gameBoard[newPos.r][newPos.c].broken = true;
            } else {
                handleGameEnd(false, "stuck");
            }
            if (isPlayerRelocation) {
               lbb_isRelocating = false;
            }
        }

        function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
            const allSpots = [];
            for(let r=0; r<boardRows; r++){
                for(let c=0; c<boardCols; c++){
                    if(!lbb_gameBoard[r][c].broken){
                         const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                         if(dist >= minDistanceFromOpponent){
                            allSpots.push({r, c});
                         }
                    }
                }
            }
            return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
        }


        // === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
        function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
            if (level) gb_currentLevel = level;
            if(fromStartButtonOrNextLevel) {
                if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
                if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
            }

            if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
            if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId); 

            gb_isGameActive = true;
            gb_gamePausedForOverlay = false;
            gb_playerHealth = GB_MAX_PLAYER_HEALTH;
            gb_enemyAttacks = [];
            gb_gameStartTime = Date.now();
            gb_enemyHitEffectTimer = 0;

            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            gb_enemyHealth = currentLevelConfig.enemyHealth;

            gb_spawnPlayerAttackWord();

            if(gameInputField) {
              gameInputField.disabled = false;
              gameInputField.value = '';
              gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
              setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
            }
            
            let lastAttackTime = 0;
            function enemyAttackLoop(timestamp) {
                if (!gb_isGameActive) {
                    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
                    return;
                };
                if (!lastAttackTime) lastAttackTime = timestamp;
                const elapsed = timestamp - lastAttackTime;
                const interval = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))].attackInterval;
                if(elapsed > interval) {
                    gb_spawnEnemyAttack();
                    lastAttackTime = timestamp;
                }
                gb_enemyAttackIntervalId = requestAnimationFrame(enemyAttackLoop);
            }
            requestAnimationFrame(enemyAttackLoop);

            startGiantBattleGameLoop();
        }
        function startGiantBattleGameLoop() {
            if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
            function loop() {
                if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
                     cancelAnimationFrame(gb_gameLoopId);
                     gb_gameLoopId = null;
                     return;
                }
                drawGiantBattleGame();
                if (gb_isGameActive && !gb_gamePausedForOverlay) {
                    updateGiantBattleGameLogic();
                }
                gb_gameLoopId = requestAnimationFrame(loop);
            }
            gb_gameLoopId = requestAnimationFrame(loop);
        }
        function updateGiantBattleGameLogic() {
            if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

            if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
                handleGameEnd(gb_playerHealth > 0, "timeUp");
                return;
            }

            if (gb_enemyHitEffectTimer > 0) {
                gb_enemyHitEffectTimer -= 1000 / 60;
                if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
            }

            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
                const attack = gb_enemyAttacks[i];
                attack.y += currentLevelConfig.attackSpeed;

                const attackObjectHeight = 40;
                const playerHpBarY = gameCanvas.height - 35 - 18;
                const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;

                if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
                    gb_enemyAttacks.splice(i, 1);
                    gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
                    const damageText = attack.isSpecial ? `특별 공격 피격! 🔥` : `피격! 🤕`;
                    showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
                    if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

                    if (gb_playerHealth <= 0) {
                        gb_playerHealth = 0;
                        handleGameEnd(false, "hp");
                        return;
                    }
                } else if (attack.y > gameCanvas.height + attackObjectHeight) {
                     gb_enemyAttacks.splice(i, 1);
                }
            }

            if (gb_enemyHealth <= 0) {
                gb_enemyHealth = 0;
                handleGameEnd(true, "hp");
                return;
            }
        }
        function drawGiantBattleGame() {
            if (!gameCtx || !gameCanvas) return;

            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
                return;
            }

            const bodyClasses = document.body.classList;
            let mainTextColor, accentColor, specialAttackColor;
            if (bodyClasses.contains('light-theme')) {
                mainTextColor = '#524a42';
                accentColor = '#b89a6c';
                specialAttackColor = '#b89a6c';
            } else if (bodyClasses.contains('pink-theme')) {
                mainTextColor = '#4F333D';
                accentColor = '#E85D75';
                specialAttackColor = '#E85D75';
            } else {
                mainTextColor = '#e8e0d8';
                accentColor = '#d4af7a';
                specialAttackColor = '#d4af7a';
            }

            function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
                const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
                const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();

                gameCtx.fillStyle = bgColor;
                gameCtx.fillRect(x, y, width, height);

                const healthPercentage = Math.max(0, currentHealth) / maxHealth;
                const currentHealthWidth = width * healthPercentage;

                const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
                gradient.addColorStop(0, healthColor);
                gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
                gameCtx.fillStyle = gradient;
                gameCtx.fillRect(x, y, currentHealthWidth, height);

                gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
                gameCtx.fillRect(x, y, currentHealthWidth, height / 2);

                if (label) {
                    gameCtx.fillStyle = mainTextColor;
                    gameCtx.font = "bold 12px 'Poppins', sans-serif";
                    gameCtx.textAlign = textAlign;
                    gameCtx.textBaseline = "bottom";
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 4;
                    gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
                    gameCtx.shadowBlur = 0;
                }
            }

            function hexToDarker(hex, percent) {
              let { r, g, b } = hexToRgb(hex);
              r = parseInt(r * (1 - percent));
              g = parseInt(g * (1 - percent));
              b = parseInt(b * (1 - percent));
              return `rgb(${r}, ${g}, ${b})`;
            }
            const topUiY = 30;
            const uiMargin = 15;
            const healthBarHeight = 18;

            const enemyHealthBarWidth = gameCanvas.width * 0.3;
            drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "적 HP", 'right');

            const playerAreaBottomMargin = 50;
            const playerHpBarWidth = gameCanvas.width * 0.3;
            const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
            const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
            drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "플레이어 HP", 'right');

            gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 16px 'Poppins', sans-serif";
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.fillText(`레벨: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

            if (gb_gameStartTime) {
                const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
                const minutes = Math.floor(remainingTime / 60000);
                const seconds = Math.floor((remainingTime % 60000) / 1000);
                gameCtx.font = "bold 14px 'Poppins', sans-serif";
                gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
            }

            const attackWordBoxHeight = 40;
            const attackWordBoxWidth = gameCanvas.width * 0.3;
            const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
            const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20;

            gameCtx.strokeStyle = accentColor;
            gameCtx.lineWidth = 2;
            gameCtx.beginPath();
            gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
            gameCtx.stroke();
            gameCtx.lineWidth = 1;

            gameCtx.font = "bold 18px 'Poppins', sans-serif";
            gameCtx.fillStyle = accentColor;
            gameCtx.textAlign = "center";
            gameCtx.textBaseline = "middle";
            gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
            gameCtx.shadowBlur = 2;
            gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);

            gameCtx.font = "bold 24px 'Poppins', sans-serif";
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
            gameCtx.shadowOffsetX = 1;
            gameCtx.shadowOffsetY = 1;

            for (const attack of gb_enemyAttacks) {
                gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
                if (attack.isSpecial) {
                    gameCtx.shadowColor = accentColor;
                    gameCtx.shadowBlur = 10;
                } else {
                    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
                    gameCtx.shadowBlur = 5;
                }
                gameCtx.fillText(attack.word, attack.x, attack.y);
            }
            gameCtx.shadowBlur = 0;
            gameCtx.shadowOffsetX = 0;
            gameCtx.shadowOffsetY = 0;
        }
        function gb_spawnPlayerAttackWord() {
            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            const wordPool = gameWordsKor;
            const minLen = Math.max(3, currentLevelConfig.wordMinLen);
            const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
            gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "공격";
        }
        function gb_spawnDefenseWord(currentLevelConfig) {
            const wordPool = gameWordsKor;
            const minLen = Math.max(3, currentLevelConfig.wordMinLen);
            const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
            return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "수비";
        }
        function gb_spawnEnemyAttack() {
            if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            const wordPool = gameWordsKor;

            let word = "";
            let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
            let originalWordForSpecial = "";
            const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);

            if (isSpecialAttack) {
                const specialMinLen = 4;
                const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
                word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || "강타";
                originalWordForSpecial = word;
            } else {
                const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
                word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || "돌격";
            }

            const startY = -20;

            gb_enemyAttacks.push({
                word: word,
                originalWord: isSpecialAttack ? originalWordForSpecial : word,
                x: Math.random() * (gameCanvas.width - 100) + 50,
                y: startY,
                speed: currentLevelConfig.attackSpeed,
                element: 'rock',
                isSpecial: isSpecialAttack
            });
        }
        function handleGiantBattleInputSubmit() {
            if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
            const typedWordFull = gameInputField.value.trim();
            if (typedWordFull === "") return;

            const typedWord = typedWordFull;

            const playerAttackWordToMatch = gb_playerAttackWord;
            if (typedWord === playerAttackWordToMatch) {
                gb_playerAttack();
                if(gameInputField) gameInputField.value = "";
                return;
            }

            const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
            for (let i = 0; i < sortedEnemyAttacks.length; i++) {
                const enemyAttack = sortedEnemyAttacks[i];
                const enemyWordToMatch = enemyAttack.word;

                if (typedWord === enemyWordToMatch) {
                    if (enemyAttack.isSpecial) {
                        enemyAttack.isSpecial = false;
                        const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                        enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                        showGamePopup("특수 공격 무력화! 🛡️", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
                    } else {
                        gb_playerDefend(enemyAttack);
                    }
                    if(gameInputField) gameInputField.value = "";
                    return;
                }
            }

            if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
            setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
            if(gameInputField) gameInputField.value = "";
        }
        function gb_playerAttack() {
            gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
            gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
            showGamePopup(`명중! 💥`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
            gb_spawnPlayerAttackWord();
            if (gb_enemyHealth <= 0) {
                gb_enemyHealth = 0;
                handleGameEnd(true, "hp");
            }
        }
        function gb_playerDefend(rock) {
            const index = gb_enemyAttacks.indexOf(rock);
            if (index > -1) {
                gb_enemyAttacks.splice(index, 1);
                showGamePopup("방어! 🛡️", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
            }
        }

        // ---------------------------------------------------
        // ▼▼▼▼▼ 단축키 헬퍼 함수 ▼▼▼▼▼
        // ---------------------------------------------------
        function restartCurrentPractice() {
            if (currentMode === 'freestyle' || currentMode === 'game') return;

            typingInputField.value = '';
            currentDisplayLineIndex = 0;
            currentLineStartTime = null;
            disassembledLine = Hangul.disassemble(linesToPractice[0] || '');

            if (currentMode.endsWith('Long')) {
                startTime = null;
                currentArticleCorrectChars = 0;
            }
            
            renderTypingLayout();
            updateProgressBar();
            updateFakeInput('', true);
            updateKeyboardHighlight();
            if(resultEl) resultEl.textContent = '다시 시작!';
            setTimeout(() => typingInputField.focus(), 50);
        }

        function changeGameLevel(direction) { // direction: 1 for next, -1 for previous
            if (currentMode !== 'game' || !currentGameType) return;
            
            const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');
            if (!gameLevelSelectEl) return;

            let maxLevel = 1;
            if (currentGameType === 'rainfall') maxLevel = rainfall_gameMainLevelsConfig.length;
            else if (currentGameType === 'letterBlockBattle') maxLevel = LBB_MAX_LEVEL;
            else if (currentGameType === 'giantBattle') maxLevel = GB_MAX_LEVEL;

            let currentLevel = parseInt(gameLevelSelectEl.value);
            let newLevel = currentLevel + direction;

            newLevel = Math.max(1, Math.min(newLevel, maxLevel));

            if (newLevel !== currentLevel) {
                const levelVarName = {
                    rainfall: 'rainfall_gameLevel',
                    letterBlockBattle: 'lbb_gameLevel',
                    giantBattle: 'gb_currentLevel'
                }[currentGameType];

                window[levelVarName] = newLevel;
                updateDropdown(newLevel);
                
                handleGameEnd(false, 'level_change'); 
            }
        }
        function changeLongText(direction) { // direction: 1 for next, -1 for previous
            if (!currentMode.endsWith('Long') || !longTextSelectEl) return;

            const options = Array.from(longTextSelectEl.options);
            let currentIndex = longTextSelectEl.selectedIndex;

            if (currentIndex <= 0) {
                currentIndex = 1;
            }

            let nextIndex = currentIndex + direction;

            if (nextIndex >= options.length) {
                nextIndex = 1;
            } else if (nextIndex < 1) {
                nextIndex = options.length - 1;
            }

            longTextSelectEl.value = options[nextIndex].value;
            startPractice(currentMode, false);
        }
        // ---------------------------------------------------
        // ▼▼▼▼▼ 게임 종료 처리 함수 ▼▼▼▼▼
        // ---------------------------------------------------
        function handleGameEnd(playerWins, reason) {
            let isActive;
            switch (currentGameType) {
                case 'rainfall': isActive = rainfall_isGameActive; rainfall_isGameActive = false; break;
                case 'letterBlockBattle': isActive = lbb_isGameActive; lbb_isGameActive = false; break;
                case 'giantBattle': isActive = gb_isGameActive; gb_isGameActive = false; break;
                default: return;
            }
            if (!isActive && reason !== 'level_change') return;

            if (currentGameType === 'rainfall') {
                if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
                if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
                rainfall_gameLoopId = null;
                rainfall_wordGenerationIntervalId = null;
            } else if (currentGameType === 'letterBlockBattle') {
                if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
                if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
                lbb_gameLoopId = null;
                lbb_enemyActionIntervalId = null;
            } else if (currentGameType === 'giantBattle') {
                if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
                if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
                gb_gameLoopId = null;
                gb_enemyAttackIntervalId = null;
            }

            if(gameInputField) gameInputField.disabled = true;

            let gameConfig, currentLevel, resultData;
            window.gameResultData = null;
            const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

            if (currentGameType === 'rainfall') {
                gameConfig = { name: '소나기', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
                currentLevel = rainfall_gameLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 클리어!` : '게임 오버', gameName: '소나기', stats: { '레벨': currentLevel, '점수': rainfall_gameScore } };
            } else if (currentGameType === 'letterBlockBattle') {
                gameConfig = { name: '블록 배틀', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
                currentLevel = lbb_gameLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '블록 배틀', stats: { '레벨': currentLevel, '내 점수': lbb_playerScore, '적 점수': lbb_enemyScore } };
            } else if (currentGameType === 'giantBattle') {
                gameConfig = { name: '타이핑 배틀', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
                currentLevel = gb_currentLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '타이핑 배틀', stats: { '레벨': currentLevel, '남은 HP': Math.round(gb_playerHealth) } };
            } else {
                return;
            }

            const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;

            if (reason === 'level_change') {
                showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
                return;
            }
            
            let nextActionText = '';
            if (playerWins && currentLevel < gameConfig.maxLevel) {
                nextActionText = `다음 레벨 (${currentLevel + 1}) (Enter)`;
                resultData.nextAction = () => {
                    const nextLevel = currentLevel + 1;
                    window[gameConfig.levelVarName] = nextLevel;
                    updateDropdown(nextLevel);
                    showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
                };
            } else if (playerWins) {
                resultData.title = `🏆 모든 레벨 클리어!`;
                nextActionText = "처음부터 다시하기 (Enter)";
                resultData.nextAction = () => {
                     window[gameConfig.levelVarName] = 1;
                     updateDropdown(1);
                     showCountdownThenStart(gameConfig.initFunc, [true, 1]);
                };
            } else {
                if(reason === 'timeUp' && ((currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > 0))) {
                     resultData.title = `시간 종료 (판정승)`;
                }
                nextActionText = "다시 도전 (Enter)";
                resultData.nextAction = () => {
                    const levelToRetry = selectedLevelInDropdown;
                    window[gameConfig.levelVarName] = levelToRetry;
                    updateDropdown(levelToRetry);
                    showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
                };
            }
            resultData.nextActionText = nextActionText;
            
            window.gameResultData = resultData;
            showResultOverlay(resultData);
        }
        function showCountdownThenStart(startGameFunction, args = [true, 1]) {
            if (countdownTimerId) {
                clearTimeout(countdownTimerId);
                countdownTimerId = null;
            }

            if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
            if(gameOverlayEl) gameOverlayEl.classList.remove('visible');

            let count = 3;
            const countdown = () => {
                const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];
                if (drawFunc) drawFunc(); 
                
                if (count > 0) {
                    gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
                    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    gameCtx.font = "bold 80px 'Poppins', sans-serif";
                    gameCtx.fillStyle = 'white';
                    gameCtx.textAlign = 'center';
                    gameCtx.textBaseline = 'middle';
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 10;
                    gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
                    gameCtx.shadowBlur = 0;
                    count--;
                    countdownTimerId = setTimeout(countdown, 1000);
                } else {
                    gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
                    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    gameCtx.font = "bold 70px 'Poppins', sans-serif";
                    gameCtx.fillStyle = 'white';
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 10;
                    gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
                    gameCtx.shadowBlur = 0;
                    countdownTimerId = setTimeout(() => {
                        countdownTimerId = null;
                        startGameFunction(...args);
                    }, 500);
                }
            };
            countdown();
        }
        function returnToPracticeMode(resetSessionStats = true) {
            cleanupActiveModes();
            const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
            if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
                if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
                     originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
                }
                if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
                    originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
                }
            }
            if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
                gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
                gameToggleSoundBtn = null;
            }
            if (!statsVisible) {
                statsVisible = true;
                toggleStatsBtn.classList.add('active');
                toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
                statsEl.classList.remove('hidden');
            }
            let lastPracticeMode = 'kor';
            const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
            if (activePracticeBtn && languageSelectEl) {
                const type = activePracticeBtn.dataset.practiceType;
                const lang = languageSelectEl.value;
                if(type !== 'freestyle' && type !== 'game'){
                    lastPracticeMode = (type === 'long') ? `${lang}Long` : lang;
                }
            }
            updateKeyboardDisplay();
            updateKeyboardHighlight();
            startPractice(lastPracticeMode, resetSessionStats);
        }
        const charToKeyMap = {
            'ㅂ': 'q', 'ㅈ': 'w', 'ㄷ': 'e', 'ㄱ': 'r', 'ㅅ': 't', 'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅔ': 'p',
            'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l',
            'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
            'ㅃ': 'q', 'ㅉ': 'w', 'ㄸ': 'e', 'ㄲ': 'r', 'ㅆ': 't', 'ㅒ': 'o', 'ㅖ': 'p',
            '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
            '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/',
            '`': 'backquote', '~': 'backquote', '!': '1', '@': '2', '#': '3', '$': '4', '%': '5',
            '^': '6', '&': '7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '='
        };

        const Hangul = (() => {
            const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
            const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const HANGUL_OFFSET = 0xAC00;

            const disassemble = (str) => {
                return str.split('').map(char => {
                    const code = char.charCodeAt(0);
                    if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                        const uniValue = code - HANGUL_OFFSET;
                        const jong = uniValue % 28;
                        const jung = Math.floor((uniValue - jong) / 28) % 21;
                        const cho = Math.floor(uniValue / (21 * 28));
                        
                        const result = [CHO[cho]];
                        const jungJamo = JUNG[jung];
                        switch(jungJamo) {
                            case 'ㅘ': result.push('ㅗ', 'ㅏ'); break;
                            case 'ㅙ': result.push('ㅗ', 'ㅐ'); break;
                            case 'ㅚ': result.push('ㅗ', 'ㅣ'); break;
                            case 'ㅝ': result.push('ㅜ', 'ㅓ'); break;
                            case 'ㅞ': result.push('ㅜ', 'ㅔ'); break;
                            case 'ㅟ': result.push('ㅜ', 'ㅣ'); break;
                            case 'ㅢ': result.push('ㅡ', 'ㅣ'); break;
                            default: result.push(jungJamo); break;
                        }
                        
                        if (jong > 0) {
                            const jongJamo = JONG[jong];
                            switch(jongJamo) {
                                case 'ㄳ': result.push('ㄱ', 'ㅅ'); break;
                                case 'ㄵ': result.push('ㄴ', 'ㅈ'); break;
                                case 'ㄶ': result.push('ㄴ', 'ㅎ'); break;
                                case 'ㄺ': result.push('ㄹ', 'ㄱ'); break;
                                case 'ㄻ': result.push('ㄹ', 'ㅁ'); break;
                                case 'ㄼ': result.push('ㄹ', 'ㅂ'); break;
                                case 'ㄽ': result.push('ㄹ', 'ㅅ'); break;
                                case 'ㄾ': result.push('ㄹ', 'ㅌ'); break;
                                case 'ㄿ': result.push('ㄹ', 'ㅍ'); break;
                                case 'ㅀ': result.push('ㄹ', 'ㅎ'); break;
                                case 'ㅄ': result.push('ㅂ', 'ㅅ'); break;
                                default: result.push(jongJamo); break;
                            }
                        }
                        return result;
                    }
                    return [char];
                }).flat();
            };
            return { disassemble };
        })();

        function alignInputField() {
            const currentLineEl = document.getElementById('current-typing-line');
            const fakeInputEl = document.getElementById('fake-input-field');

            if (!currentLineEl || !fakeInputEl) return;

            const lineSpan = currentLineEl.querySelector('span');
            
            // 예문 텍스트가 없으면 기본 패딩으로 리셋
            if (!lineSpan || lineSpan.textContent.trim() === '') {
                fakeInputEl.style.paddingLeft = '16px'; // CSS에 정의된 기본값
                return;
            }

            const lineRect = lineSpan.getBoundingClientRect();
            const inputContainerRect = fakeInputEl.getBoundingClientRect();
            
            // 예문 시작 X좌표와 입력창 컨테이너 시작 X좌표의 차이를 계산
            const requiredPadding = lineRect.x - inputContainerRect.x;
            
            // 계산된 패딩 적용 (음수 방지)
            if (requiredPadding >= 0) {
                fakeInputEl.style.paddingLeft = `${requiredPadding}px`;
            }
        }

        function buildKeyboard() {
            if (!keyboardGuideEl) return;
            keyboardGuideEl.innerHTML = '';
            
            const layout = [
                ['`','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
                ['Tab','q','w','e','r','t','y','u','i','o','p','[',']','\\'],
                ['CapsLock','a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
                ['ShiftLeft','z','x','c','v','b','n','m',',','.','/','ShiftRight'],
                ['ControlLeft', 'AltLeft', 'Space', 'AltRight', 'ControlRight']
            ];

            const keyInfo = {
                '`': { base: '`', shift: '~' }, '1': { base: '1', shift: '!' },
                '2': { base: '2', shift: '@' }, '3': { base: '3', shift: '#' },
                '4': { base: '4', shift: '$' }, '5': { base: '5', shift: '%' },
                '6': { base: '6', shift: '^' }, '7': { base: '7', shift: '&' },
                '8': { base: '8', shift: '*' }, '9': { base: '9', shift: '(' },
                '0': { base: '0', shift: ')' }, '-': { base: '-', shift: '_' },
                '=': { base: '=', shift: '+' },

                'q': { eng: 'Q', kor: 'ㅂ', shiftKor: 'ㅃ' }, 'w': { eng: 'W', kor: 'ㅈ', shiftKor: 'ㅉ' },
                'e': { eng: 'E', kor: 'ㄷ', shiftKor: 'ㄸ' }, 'r': { eng: 'R', kor: 'ㄱ', shiftKor: 'ㄲ' },
                't': { eng: 'T', kor: 'ㅅ', shiftKor: 'ㅆ' }, 'y': { eng: 'Y', kor: 'ㅛ' }, 'u': { eng: 'U', kor: 'ㅕ' },
                'i': { eng: 'I', kor: 'ㅑ' }, 'o': { eng: 'O', kor: 'ㅐ', shiftKor: 'ㅒ' }, 'p': { eng: 'P', kor: 'ㅔ', shiftKor: 'ㅖ' },
                '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, '\\': { base: '\\', shift: '|' },
                
                'a': { eng: 'A', kor: 'ㅁ' }, 's': { eng: 'S', kor: 'ㄴ' }, 'd': { eng: 'D', kor: 'ㅇ' },
                'f': { eng: 'F', kor: 'ㄹ' }, 'g': { eng: 'G', kor: 'ㅎ' }, 'h': { eng: 'H', kor: 'ㅗ' },
                'j': { eng: 'J', kor: 'ㅓ' }, 'k': { eng: 'K', kor: 'ㅏ' }, 'l': { eng: 'L', kor: 'ㅣ' },
                ';': { base: ';', shift: ':' }, "'": { base: "'", shift: '"' },

                'z': { eng: 'Z', kor: 'ㅋ' }, 'x': { eng: 'X', kor: 'ㅌ' }, 'c': { eng: 'C', kor: 'ㅊ' },
                'v': { eng: 'V', kor: 'ㅍ' }, 'b': { eng: 'B', kor: 'ㅠ' }, 'n': { eng: 'N', kor: 'ㅜ' }, 'm': { eng: 'M', kor: 'ㅡ' },
                ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' }, '/': { base: '/', shift: '?' }
            };

            layout.forEach((row, index) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = `keyboard-row row-${index + 1}`;
                
                const keysWrapper = document.createElement('div');
                keysWrapper.className = 'keys-wrapper';

                row.forEach(keyId => {
                    const keyDiv = document.createElement('div');
                    let dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
                    if(dataKey === '`') dataKey = 'backquote';
                    keyDiv.dataset.key = dataKey;
                    keyDiv.classList.add('keyboard-key');

                    const data = keyInfo[keyId.toLowerCase()];
                    if (data) {
                        const mainChar = data.eng ? data.eng.toLowerCase() : data.base;
                        const shiftChar = data.eng ? data.eng.toUpperCase() : data.shift;
                        const korMain = data.kor || data.base || '';
                        const korShift = data.shiftKor || data.shift || '';
                        
                        keyDiv.innerHTML = `
                            <div class="key-eng">
                                <span class="key-shift-char">${shiftChar}</span>
                                <span class="key-main-char">${mainChar}</span>
                            </div>
                            <div class="key-kor">
                                <span class="key-shift-char">${korShift}</span>
                                <span class="key-main-char">${korMain}</span>
                            </div>
                        `;
                    } else {
                         keyDiv.classList.add('special-key');
                         keyDiv.textContent = keyId.replace(/Left|Right/, '');
                    }

                    if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId.toLowerCase())) {
                        keyDiv.classList.add('home-row-base');
                    }

                    const keyWidths = {
                        backspace: '2x', tab: '1.5x', capslock: '1.75x', enter: '2.25x',
                        shiftleft: '2.5x', shiftright: '2.5x', space: 'space'
                    };
                    if(keyWidths[keyId.toLowerCase()]) {
                        keyDiv.classList.add(`key-width-${keyWidths[keyId.toLowerCase()]}`);
                    }

                    keysWrapper.appendChild(keyDiv);
                });
                rowDiv.appendChild(keysWrapper);
                keyboardGuideEl.appendChild(rowDiv);
            });
        }

        function updateKeyboardDisplay() {
            if (!keyboardGuideEl) return;
            
            const lang = currentMode.replace('Long', '');
            
            keyboardGuideEl.className = 'keyboard-guide';
            if (keyboardGuideEnabled) {
                keyboardGuideEl.classList.add('visible');
            }
            keyboardGuideEl.classList.add(`lang-${lang}`);
        }

        function clearKeyboardHighlight() {
            if (!keyboardGuideEl) return;
            const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
            highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
        }

        function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game' || currentMode === 'freestyle') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();

    const disassembledTyped = Hangul.disassemble(typingInputField.value);
    let nextCharIndex = disassembledTyped.length;

    // 자동 완성이 항상 켜져 있으므로, 특수문자를 건너뛰는 로직을 항상 실행합니다.
    while (
        nextCharIndex < disassembledLine.length &&
        isSpecialCharacter(disassembledLine[nextCharIndex])
    ) {
        // 다음 글자가 특수문자이면, 인덱스를 1 증가시켜 건너뜁니다.
        nextCharIndex++;
    }

    // 모든 추천 과정을 건너뛰고 문장의 끝에 도달했다면, 함수를 종료합니다.
    if (nextCharIndex >= disassembledLine.length) {
        return;
    }

    const nextCharToPress = disassembledLine[nextCharIndex];
    if (!nextCharToPress) return;

    const shiftKeyMap = {
        '~':'`', '!':'1', '@':'2', '#':'3', '$':'4', '%':'5', '^':'6', '&':'7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '=',
        '{': '[', '}': ']', '|': '\\', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/'
    };
    
    let keyId;
    let isShiftNeeded = false;

    // 한글 쌍자음/쌍모음 처리
    const isKorMode = currentMode.startsWith('kor');
    if (isKorMode && 'ㅃㅉㄸㄲㅆㅒㅖ'.includes(nextCharToPress)) {
        isShiftNeeded = true;
        keyId = charToKeyMap[nextCharToPress];
    } 
    // 영어 대문자 처리
    else if (nextCharToPress >= 'A' && nextCharToPress <= 'Z') {
        isShiftNeeded = true;
        keyId = nextCharToPress.toLowerCase();
    } 
    // 나머지 쉬프트 필요한 특수문자 처리
    else if (shiftKeyMap[nextCharToPress]) {
        isShiftNeeded = true;
        keyId = shiftKeyMap[nextCharToPress];
    } 
    // 일반 문자 처리
    else {
        keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    }
    
    if(keyId === '`') keyId = 'backquote';

    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}

        // === HELP MODAL FUNCTIONS ===
        function getHelpContent(gameType) {
            const contents = {
                rainfall: {
                    title: '<i class="fas fa-cloud-showers-heavy"></i> 소나기 게임 방법',
                    body: `<p>하늘에서 떨어지는 단어들을 사라지기 전에 입력하여 점수를 획득하는 게임입니다.</p>
                           <p>단어가 바닥에 닿으면 생명이 1 감소하며, 생명을 모두 잃으면 게임이 종료됩니다.</p>
                           <div class="item-info">
                                <div><strong>아이템 종류:</strong></div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text}: 생명이 1 증가합니다.</div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text}: 3초 동안 모든 단어의 움직임이 멈춥니다.</div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text}: 화면의 모든 일반 단어를 제거하고 점수를 얻습니다.</div>
                           </div>`
                },
                letterBlockBattle: {
                    title: '<i class="fas fa-th-large"></i> 블록 배틀 게임 방법',
                    body: `<p>상하좌우에 인접한 블록의 단어를 입력하여 이동하고 점수를 얻습니다. 블록을 부숴 적과 나의 캐릭터가 빈 칸으로 연결되면 전투가 일어나며, 점수가 높은 쪽이 승리합니다.</p>
                           <p>2분 안에 승부가 나지 않으면 점수가 더 높은 쪽이 판정승합니다.</p>
                           <div class="item-info">
                                <div><strong>특수 블록:</strong></div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: 2점</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: 3점</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: 적을 2초간 얼립니다.</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 적과 나의 위치를 바꿉니다.</div>
                           </div>`
                },
                giantBattle: {
                    title: '<i class="fas fa-fist-raised"></i> 타이핑 배틀 게임 방법',
                    body: `<p>화면 하단의 공격 단어를 입력하여 적을 공격하고, 위에서 내려오는 적의 공격 단어를 입력하여 방어하세요.</p>
                           <p>2분 내에 적의 HP를 0으로 만들거나, 시간이 종료됐을 때 나의 HP가 더 많으면 승리합니다.</p>`
                }
            };
            return contents[gameType] || { title: '도움말', body: '게임 정보를 찾을 수 없습니다.' };
        }

        function showHelpModal(gameType) {
            const content = getHelpContent(gameType);
            if (helpModalBody) helpModalBody.innerHTML = `<h2>${content.title}</h2>${content.body}`;
            if (helpModal) helpModal.classList.add('visible');
            
            if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = true;
            else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = true;
            else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = true;
        }

        function hideHelpModal() {
            if (helpModal) helpModal.classList.remove('visible');

            if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = false;
            else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = false;
            else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = false;
        }
        // ▼▼▼▼▼ 이 함수 전체를 복사해서 기존 함수와 교체하세요. ▼▼▼▼▼
async function shareResult() {
    if (!window.gameResultData) {
        showSharePopup('공유할 결과 데이터가 없습니다.');
        return;
    }

    const resultData = window.gameResultData;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    const width = 500;
    const height = 340; // [수정] 이미지 세로 길이 증가 (280 -> 340)
    const padding = 30;
    const borderRadius = 12;

    canvas.width = width;
    canvas.height = height;

    const theme = document.body.classList.contains('light-theme') ? 'light' : (document.body.classList.contains('pink-theme') ? 'pink' : 'dark');
    
    const colors = {
        dark: { bg: '#2a2826', text: '#e8e0d8', accent: '#d4af7a', secondary: '#b2aca2' },
        light: { bg: '#fff', text: '#524a42', accent: '#b89a6c', secondary: '#756A5F' },
        pink: { bg: '#ffffff', text: '#4F333D', accent: '#E85D75', secondary: '#735A64' }
    };
    const currentTheme = colors[theme];
    
    ctx.fillStyle = currentTheme.bg;
    ctx.beginPath();
    ctx.moveTo(borderRadius, 0);
    ctx.lineTo(width - borderRadius, 0);
    ctx.quadraticCurveTo(width, 0, width, borderRadius);
    ctx.lineTo(width, height - borderRadius);
    ctx.quadraticCurveTo(width, height, width - borderRadius, height);
    ctx.lineTo(borderRadius, height);
    ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
    ctx.lineTo(0, borderRadius);
    ctx.quadraticCurveTo(0, 0, borderRadius, 0);
    ctx.closePath();
    ctx.fill();

    // --- 제목 그리기 ---
    ctx.fillStyle = currentTheme.accent;
    ctx.font = "bold 36px 'Playfair Display', serif";
    ctx.textAlign = 'center';
    ctx.fillText(resultData.title, width / 2, padding + 40);

    // --- [추가] 게임 이름 그리기 ---
    ctx.fillStyle = currentTheme.secondary;
    ctx.font = "normal 18px 'Poppins', sans-serif";
    ctx.fillText(`- ${resultData.gameName} -`, width / 2, padding + 75);
    
    // --- 통계 그리기 ---
    ctx.font = "500 18px 'Poppins', sans-serif";
    const stats = Object.entries(resultData.stats);
    const statY = 160; // [수정] 통계 위치 아래로 조정 (130 -> 160)
    const statXMargin = width / (stats.length + 1);

    stats.forEach(([key, value], index) => {
        const x = statXMargin * (index + 1);
        ctx.fillStyle = currentTheme.secondary;
        ctx.fillText(key + ':', x, statY);
        ctx.fillStyle = currentTheme.text;
        ctx.fillText(value, x, statY + 30);
    });

    // --- [추가] 사이트 이름과 주소 (푸터) 그리기 ---
    ctx.fillStyle = currentTheme.secondary;
    ctx.font = "bold 16px 'Poppins', sans-serif";
    ctx.fillText("Key Therapy", width / 2, height - padding - 30);

    ctx.globalAlpha = 0.7;
    ctx.font = "normal 12px 'Poppins', sans-serif";
    ctx.fillText("https://keytherapy.vercel.app", width / 2, height - padding - 10);
    ctx.globalAlpha = 1.0; // 투명도 초기화

    // --- 이미지 생성 및 공유 로직 ---
    canvas.toBlob(async (blob) => {
        if (!blob) return;
        
        const file = new File([blob], 'keytherapy-result.png', { type: 'image/png' });
        const shareTitle = 'Key Therapy 게임 결과';
        const shareText = `🎉 ${resultData.title} 🎉\n\n지금 바로 Key Therapy에서 타자 실력을 확인해보세요!`;
        const shareUrl = 'https://keytherapy.vercel.app';

        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    files: [file],
                    title: shareTitle,
                    text: shareText,
                    url: shareUrl,
                });
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Web Share API 공유 실패:', error);
                    showSharePopup('결과 공유에 실패했습니다.');
                }
            }
        } else {
            try {
                const clipboardItem = new ClipboardItem({
                    'image/png': blob,
                    'text/plain': new Blob([`${shareTitle}\n${shareText}\n${shareUrl}`], { type: 'text/plain' })
                });
                await navigator.clipboard.write([clipboardItem]);
                showSharePopup('결과 이미지와 링크가 복사되었습니다!');
            } catch (error) {
                console.error('클립보드 복사 실패:', error);
                showSharePopup('결과 공유에 실패했습니다.');
            }
        }
    }, 'image/png');
}

        function showResultOverlay(resultData) {
            // [핵심 추가] 팝업 표시 전 타이핑 입력 필드 비활성화
            if (typingInputField) {
                typingInputField.disabled = true;
            }

            if (!gameOverlayEl) {
                // gameOverlayEl이 없으면 생성
                gameOverlayEl = document.createElement('div');
                gameOverlayEl.id = 'gameOverlay';
                gameOverlayEl.className = 'game-overlay';
                
                // main-content의 자식으로 추가해야 다른 요소들을 덮을 수 있음
                const mainContent = document.querySelector('.main-content');
                if(mainContent) {
                    mainContent.appendChild(gameOverlayEl);
                } else {
                    document.body.appendChild(gameOverlayEl);
                }
            }

            let statsHtml = '';
            for (const [key, value] of Object.entries(resultData.stats)) {
                statsHtml += `<div class="stat-item"><span class="label">${key}:</span><span class="value">${value}</span></div>`;
            }

            const shareButtonHtml = `<button id="shareResultBtn" class="game-button secondary"><i class="fas fa-share-alt"></i> 결과 공유하기</button>`;

            gameOverlayEl.innerHTML = `
                <div class="result-card">
                    <h2>${resultData.title}</h2>
                    <div class="result-card-stats">${statsHtml}</div>
                    <div class="result-buttons">
                        <button id="nextStepBtnOverlay" class="game-button">${resultData.nextActionText}</button>
                        ${resultData.type === 'game' ? shareButtonHtml : ''}
                    </div>
                </div>`;

            setTimeout(() => {
                gameOverlayEl.classList.add('visible');
            }, 100);

            const nextBtn = document.getElementById('nextStepBtnOverlay');
            const shareBtn = document.getElementById('shareResultBtn');
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    gameOverlayEl.classList.remove('visible');
                    // [핵심 추가] 팝업 닫힐 때 입력 필드 다시 활성화
                    if (typingInputField) {
                        typingInputField.disabled = false;
                        typingInputField.focus();
                    }
                    resultData.nextAction();
                });
            }

            if (shareBtn) {
                shareBtn.addEventListener('click', shareResult);
            }
        }
        function updateLayout() {
            if (!toggleLayoutBtn) return;

            document.body.classList.toggle('layout-collapsed', layoutCollapsed);
            if (layoutCollapsed) {
                toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-down"></i> 메뉴 펼치기(Esc)';
            } else {
                toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-up"></i> 메뉴 숨기기(Esc)';
            }
        }

        function applyTheme(theme) {
            document.body.classList.remove('light-theme', 'pink-theme');
            if (theme === 'light') document.body.classList.add('light-theme');
            else if (theme === 'pink') document.body.classList.add('pink-theme');

            if (gameCanvas && currentGameType) {
                requestAnimationFrame(() => {
                    if (currentGameType === 'rainfall') drawRainfallGame();
                    else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
                    else if (currentGameType === 'giantBattle') drawGiantBattleGame();
                });
            }
        }
</script>
<script>
  window.va = window.va || function () { (window.va.q = window.va.q || []).push(arguments); };
</script>
<script defer src="/_vercel/insights/script.js"></script>
<script>
  window.addEventListener('load', () => {
    if (window.va) {
      window.va('auto');
    }
  });
</script>
</body>
</html>
