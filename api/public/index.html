<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - 온라인 타자연습 & 게임</title>
  <link rel="icon" href="data:,">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
.no-transition * {
  transition: none !important;
}
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}
#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}
    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Noto Sans KR', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Courier New', monospace;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ub20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);
      --font-size-typing: 1.15rem;
      --typing-letter-spacing: 0px;
      --typing-word-spacing: 0px;
      --font-size-typing-mobile: 1.05rem;
      --typing-letter-spacing-mobile: 0px;
      --typing-word-spacing-mobile: 0px;
      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;
      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);
      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);
      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;
    }
    .light-theme {
      --bg-main: #fdfaf6;
      --bg-container: #fff;
      --bg-typing-area: #f9f5f0;
      --bg-progress-bar: #c0a580;
      --bg-progress-bar-track: #ede7de;
      --text-primary: #524a42;
      --text-secondary: #756A5F;
      --accent-primary: #b89a6c;
      --accent-secondary: #c8ad82;
      --accent-active: #a88a5c;
      --accent-darker: #987b4f;
      --accent-rgb: 184, 154, 108;
      --accent-primary-rgb: 184, 154, 108;
      --input-bg: #fefcf9;
      --input-text: #4a4037;
      --input-border: #dcd3c9;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.25);
      --button-text: #4a4037;
      --button-text-on-accent: #fefcf9;
      --current-line-bg: rgba(var(--accent-rgb), 0.06);
      --current-line-text: #504840;
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.25);
      --current-line-shadow: 0 2px 8px rgba(var(--accent-rgb),0.1);
      --highlight-error: #d3546d;
      --highlight-error-bg: rgba(211, 84, 109, 0.07);
      --shadow-soft: 0 6px 20px rgba(170, 150, 130, 0.08);
      --shadow-inset: inset 0 1px 2px rgba(0,0,0,0.025);
      --shadow-button: 0 3px 8px rgba(170, 150, 130, 0.07);
      --shadow-button-hover: 0 5px 12px rgba(170, 150, 130, 0.1);
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
        transition: padding-top 0.4s ease-out;
    }
    body.layout-collapsed .main-content-wrapper {
        padding-top: 23vh;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: center;
        padding-top: 3vh;
    }
    body.focus-mode-active {
        overflow: hidden;
    }
    body.focus-mode-active .main-content-wrapper {
        padding: 0;
        align-items: stretch;
        justify-content: stretch;
    }
    body.focus-mode-active .main-content {
        max-width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    body.focus-mode-active .layout-toggle-container,
    body.focus-mode-active .hero-section,
    body.focus-mode-active .controls-and-stats-wrapper,
    body.focus-mode-active .footer {
        display: none !important;
    }
    body.focus-mode-active #freestyle-area-container {
        height: 100%;
        border-radius: 0;
    }
    .layout-toggle-container {
        width: 100%;
        max-width: 1200px;
        position: relative;
        z-index: 10;
        height: 0;
    }
    #toggleLayoutBtn {
      position: absolute;
      left: 0; 
      transform: translateX(0);
      top: 0;
      padding: 6px 15px;
      font-size: 0.85em;
      border-radius: 0 0 var(--border-radius-small) var(--border-radius-small);
      cursor: pointer;
      font-family: var(--font-ui);
      font-weight: 500;
      border: 1.5px solid transparent;
      border-top: none;
      background: transparent;
      color: var(--text-secondary);
      transition: all 0.2s ease-in-out;
      box-shadow: none;
      opacity: 0.6;
    }
    #toggleLayoutBtn:hover {
        background: var(--bg-container);
        color: var(--accent-primary);
        border-color: var(--input-border);
        opacity: 1;
    }
    #toggleLayoutBtn i {
        margin-right: 7px;
    }
    #result,
    #toggleLayoutBtn {
        transition: opacity 0.4s ease-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }
    .main-content {
      max-width: 1200px;
      width: 100%; background-color: var(--bg-container);
      border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
      display: flex; flex-direction: column;
      border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
      transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out;
    }
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }
    .hidden { display: none !important; }
    body.game-mode-active .layout-toggle-container,
    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #freestyle-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.freestyle-mode-active .layout-toggle-container,
    body.freestyle-mode-active .typing-area-container,
    body.freestyle-mode-active .progress-bar-container,
    body.freestyle-mode-active #game-area-container,
    body.freestyle-mode-active #keyboard-guide.visible {
        display: none !important;
    }
    #freestyle-area-container { display: none; }
    body.freestyle-mode-active #freestyle-area-container { display: flex; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }
    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 35px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s 0.1s, border-width 0.4s, border-radius 0.3s ease, visibility 0.4s;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper {
        padding: 25px 25px 15px;
        max-height: 500px;
        overflow: hidden;
        transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s, visibility 0.4s;
    }
    body.layout-collapsed .hero-section,
    body.layout-collapsed .controls-and-stats-wrapper {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
        visibility: hidden;
    }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }
    .main-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button.disabled,
    .selection-controls .disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
        background: transparent !important;
        color: var(--text-secondary) !important;
        border-color: var(--input-border) !important;
        box-shadow: none !important;
        transform: none !important;
    }
    .practice-mode-controls,
    .feature-toggles {
        width: 100%;
        justify-content: center;
    }
    .practice-mode-controls button { min-width: 90px; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }
    .selection-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        width: 100%;
    }
    .language-settings, .sound-settings, .theme-settings, .long-text-settings {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }
    #languageSelect, #soundPackSelect, #themeSelect, #longTextSelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #languageSelect:focus, #soundPackSelect:focus, #themeSelect:focus, #longTextSelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 15px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 8px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }
    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #practice-title-display {
        font-family: var(--font-ui);
        font-size: 1.1em;
        font-weight: 500;
        color: var(--accent-secondary);
        text-align: center;
        margin-bottom: 15px;
        padding: 5px 10px;
        min-height: 1.2em;
    }
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc((var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }
.typing-line {
    width: 100%; max-width: 800px;
    padding-left: 16px;
    padding-right: 16px;
    margin: 1px auto;
    font-family: var(--font-typing);
    font-size: var(--font-size-typing);
    font-weight: 400;
    line-height: var(--line-height-typing);
    letter-spacing: var(--typing-letter-spacing);
    word-spacing: var(--typing-word-spacing);
    box-sizing: border-box;
    text-align: left;
    border-radius: var(--border-radius-small);
    border: 1px solid transparent;
    font-synthesis: none;
    font-kerning: normal;
    text-rendering: optimizeLegibility;
    padding-top: 12px;
    padding-bottom: 12px;
    transition: opacity 0.3s ease, font-size 0.25s ease, color 0.25s ease, background-color 0.25s ease, box-shadow 0.25s ease, border-radius 0.3s ease;
    min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
    display: flex;
    align-items: center;
    background-color: transparent;
    white-space: pre-wrap;
}
    .whitespace-char {
        color: var(--text-secondary);
        opacity: 0.6;
        user-select: none;
        font-weight: bold;
    }
    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }
    .typing-line strong {
        color: var(--current-line-typed-text);
    }
    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }
    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }
    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }
    #typing-input-field-container {
        width: 100%;
        max-width: 800px;
        margin: 2px auto 0 auto;
        position: relative;
    }
    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }
   .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;
        box-sizing: border-box;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        line-height: var(--line-height-typing);
        font-weight: 400;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
    }
    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }
    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }
    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-typing) * 1.2);
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: text-bottom;
        margin-left: -1px;
    }
    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }
    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}
    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }
    #returnToPracticeBtnGame {
      padding: 12px 24px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 600;
      font-size: 0.95em;
      color: var(--accent-primary);
      border: 2px solid rgba(var(--accent-rgb), 0.4);
      background-color: transparent;
      transition: all 0.25s ease;
      box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
    }
    #returnToPracticeBtnGame:hover {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-active);
      box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
    }
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }
    #gameToggleSoundBtn {
      padding: 10px 16px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 500;
      font-size: 0.9em;
      border: 1.5px solid var(--accent-secondary);
      background-color: transparent;
      color: var(--accent-secondary);
      transition: all 0.25s ease;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: var(--shadow-button);
    }
    #gameToggleSoundBtn.active {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
      font-weight: 600;
    }
    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        .game-overlay {
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .result-card {
        background-color: var(--bg-container);
        padding: 25px 35px;
        border-radius: var(--border-radius-main);
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        max-width: 500px;
        width: 90%;
    }
    .result-card h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin: 0 0 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .result-card-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 25px;
        text-align: left;
    }
    .result-card-stats .stat-item {
        font-size: 1.1em;
    }
    .result-card-stats .stat-item .label {
        color: var(--text-secondary);
        font-size: 0.9em;
        margin-right: 8px;
    }
     .result-card-stats .stat-item .value {
        color: var(--text-primary);
        font-weight: 600;
        font-family: var(--font-ui);
    }
    .result-card .result-buttons {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }
    .light-theme .result-card h2, .pink-theme .result-card h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 0;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button.secondary {
        background: transparent;
        color: var(--accent-secondary);
        border-color: var(--accent-secondary);
    }
    .game-button.secondary:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-secondary);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    #gameHelpBtn {
        position: absolute;
        top: 15px;
        left: 15px;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background-color: rgba(var(--bg-main-rgb, 32, 30, 28), 0.7);
        color: var(--text-secondary);
        border: 1px solid var(--input-border);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.1em;
        z-index: 20;
        transition: all 0.2s ease;
    }
    #gameHelpBtn:hover {
        background-color: var(--accent-primary);
        color: var(--button-text-on-accent);
    }
    .light-theme #gameHelpBtn {
        background-color: rgba(var(--bg-main-rgb, 253, 250, 246), 0.8);
    }
    #helpModal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s, visibility 0s 0.3s;
    }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        #helpModal {
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
    }
    #helpModal.visible {
        opacity: 1; visibility: visible;
        transition: opacity 0.3s, visibility 0s 0s;
    }
    .help-modal-content {
        background-color: var(--bg-container);
        padding: 30px;
        border-radius: var(--border-radius-main);
        max-width: 500px;
        width: 90%;
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        position: relative;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    #helpModal.visible .help-modal-content {
        transform: scale(1);
    }
    .help-modal-close {
        position: absolute;
        top: 15px; right: 15px;
        font-size: 1.5em;
        color: var(--text-secondary);
        cursor: pointer;
        transition: color 0.2s;
    }
    .help-modal-close:hover {
        color: var(--accent-primary);
    }
    .help-modal-content h2 {
        font-family: var(--font-heading);
        color: var(--accent-primary);
        margin-top: 0;
        margin-bottom: 15px;
    }
    .help-modal-content p, .help-modal-content div {
        color: var(--text-secondary);
        line-height: 1.7;
    }
     .help-modal-content .item-info {
        font-size: 0.9em; margin-top: 15px;
    }
    .help-modal-content .item-info div { margin-bottom: 5px; }
    
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}
      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .language-settings,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings,
      body:not(.game-mode-active) .long-text-settings { width: 100%; justify-content: center; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }
      .typing-line,
      .fake-input-field {
          font-size: var(--font-size-typing-mobile);
          letter-spacing: var(--typing-letter-spacing-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-typing-mobile) * 1.2); }
      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .result-card h2 { font-size: 1.6em; }
      .result-card-stats { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .language-settings, .sound-settings, .theme-settings, .long-text-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }
    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .select-label { font-size: 0.85em; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line,
      .fake-input-field {
          font-size: calc(var(--font-size-typing-mobile) * 0.95);
      }
      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .result-card h2 { font-size: 1.4em; }
      .result-card-stats { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }
.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}
.hero-section a:hover {
  transform: scale(1.03);
}
.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}
.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}
.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}
.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}
#keyboard-guide {
    display: none;
    margin-bottom: 25px;
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 900px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}
.keys-wrapper {
    display: flex;
    width: fit-content;
}
.row-1 .keys-wrapper, .row-2 .keys-wrapper, .row-3 .keys-wrapper, .row-4 .keys-wrapper {
    transform: translateX(0);
}
.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
    min-width: 50px;
}
.keyboard-key .key-main-char {
    font-weight: 500;
    font-size: 1.1em;
    color: var(--text-primary);
    margin-top: auto;
    margin-bottom: auto;
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
    align-self: flex-start;
    padding-left: 2px;
}
#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor,
#keyboard-guide.lang-js .key-kor,
#keyboard-guide.lang-python .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char,
#keyboard-guide.lang-js .key-eng .key-main-char,
#keyboard-guide.lang-python .key-eng .key-main-char { 
    font-size: 1.2em; 
}
.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.18);
}
.light-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.15);
}
.pink-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.12);
}
.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}
.light-theme .keyboard-key.highlight-key,
.pink-theme .keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
}
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}
.keyboard-key.special-key {
    font-size: 0.8em;
    font-weight: 400;
    text-align: center;
    line-height: 50px;
}
.key-width-1-5x { min-width: 80px; }
.key-width-1-75x { min-width: 95px; }
.key-width-2x { min-width: 110px; }
.key-width-2-25x { min-width: 125px; }
.key-width-2-5x { min-width: 135px; }
.key-width-space { min-width: 332px; flex-grow: 1; }
#freestyle-area-container {
    padding: 20px 25px 28px;
    background-color: var(--bg-typing-area);
    border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    flex-grow: 1;
    display: none;
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
    min-height: 400px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
}
#freestyle-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    position: relative;
    align-items: center;
}
.freestyle-tool-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.toolbar-divider {
    width: 1px;
    height: 20px;
    background-color: var(--input-border);
    margin: 0 4px;
}
.freestyle-tool-btn {
    background-color: var(--input-bg);
    color: var(--text-secondary);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 8px 12px;
    font-family: var(--font-ui);
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.freestyle-tool-btn:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
    border-color: var(--accent-secondary);
}
.freestyle-tool-btn i {
    margin-right: 6px;
    width: 14px;
    text-align: center;
}
#focusModeBtn { margin-left: auto; }
#emoji-picker {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    transform: translateY(5px);
    background-color: var(--bg-container);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    padding: 10px;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    z-index: 10;
}
#emoji-picker.visible {
    display: grid;
}
#emoji-picker span {
    font-size: 1.4em;
    cursor: pointer;
    text-align: center;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
#emoji-picker span:hover {
    background-color: var(--bg-main);
}
#freestyle-input-area {
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 15px;
    font-family: var(--font-typing);
    font-size: var(--font-size-typing);
    line-height: var(--line-height-typing);
    letter-spacing: var(--typing-letter-spacing);
    word-spacing: var(--typing-word-spacing);
    font-synthesis: none;
    font-kerning: normal;
    text-rendering: optimizeLegibility;
    resize: vertical;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    box-sizing: border-box;
}
#freestyle-input-area:focus {
    outline: none;
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#freestyle-input-area::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
    transition: opacity 0.3s;
}
#freestyle-input-area:focus::placeholder {
    opacity: 0.3;
}
#freestyle-stats-bar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 15px;
    padding: 8px 5px;
    font-size: 0.85em;
    color: var(--text-secondary);
    font-family: var(--font-ui);
}
.freestyle-download-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin-top: 15px;
}
#freestyle-filename-input {
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 10px 12px;
    font-family: var(--font-ui);
    font-size: 0.9em;
    outline: none;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    width: 200px;
}
#freestyle-filename-input:focus {
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#download-freestyle-btn {
    padding: 10px 20px;
    font-size: 0.9em;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    border: 1.5px solid var(--accent-primary);
    background: var(--accent-primary);
    color: var(--button-text-on-accent);
    box-shadow: var(--shadow-button);
    transition: all 0.2s ease;
}
#download-freestyle-btn:hover {
    background: var(--accent-active);
    border-color: var(--accent-active);
    transform: translateY(-1px);
    box-shadow: var(--shadow-button-hover);
}
#download-freestyle-btn i {
    margin-right: 8px;
}
#shortcut-help-container {
    position: fixed;
    bottom: 25px;
    right: 25px;
    z-index: 1000;
    font-size: 1.6em; /* 아이콘 크기 살짝 키움 */
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s ease;
}
#shortcut-help-container:hover {
    color: var(--accent-primary); /* 호버 시 아이콘 색상 변경 */
}
#shortcut-help-container:hover .shortcut-tooltip {
    opacity: 1;
    visibility: visible;
    transform: translate(-5px, -5px); /* 대각선으로 살짝 움직이는 효과 */
}
.shortcut-tooltip {
    position: absolute;
    bottom: 110%; /* 아이콘과의 거리 조정 */
    right: 110%;
    background-color: var(--bg-container);
    color: var(--text-secondary);
    padding: 15px 20px; /* 패딩 증가 */
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    font-size: 0.55em; /* 아이콘 크기 대비 폰트 크기 조정 (최종 약 0.88em) */
    line-height: 1.7;
    width: 180px; /* 너비 증가 */
    opacity: 0;
    visibility: hidden;
    transform: translate(0, 0);
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); /* 부드러운 전환 효과 */
    pointer-events: none;
    border: 1px solid var(--input-border);
}
.shortcut-tooltip strong {
    color: var(--accent-primary);
    font-size: 1.15em;
    font-weight: 600;
    display: block;
    margin-bottom: 10px; /* 제목과 내용 간격 */
    text-align: center;
}
.shortcut-tooltip p {
    margin: 0 0 8px 0; /* 단축키 항목 간격 */
}
.shortcut-tooltip p:last-child {
    margin-bottom: 0;
}
.shortcut-tooltip b {
    color: var(--text-primary);
    background-color: var(--bg-main);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--input-border);
    margin-right: 8px;
    font-family: var(--font-typing);
}
@media (max-width: 920px) {
    #keyboard-guide { max-width: 100%; }
    .keyboard-key { min-width: 42px; margin: 0 3px;}
    .key-width-1-5x { min-width: 68px; }
    .key-width-1-75x { min-width: 78px; }
    .key-width-2x { min-width: 88px; }
    .key-width-2-25x { min-width: 108px; }
    .key-width-2-5x { min-width: 118px; }
    .key-width-space { min-width: 278px; }
}
@media (max-width: 480px) {
    #freestyle-download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    #freestyle-filename-input, #download-freestyle-btn {
        width: 100%;
        box-sizing: border-box;
    }
    #freestyle-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    .freestyle-tool-group {
        justify-content: space-around;
    }
    #focusModeBtn { margin-left: 0; }
}

</style>
</head>
<body class="">
  <div class="main-content-wrapper">
    <div class="layout-toggle-container">
        <button id="toggleLayoutBtn"><i class="fas fa-chevron-up"></i> 메뉴 숨기기</button>
    </div>
    <div class="main-content">
      <div class="hero-section">
          <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
              <h1 class="hero-title">Key Therapy</h1>
              <p class="hero-tagline">깊은 수면과 집중을 위한<br>🎧키보드 타건 ASMR🎧</p>
          </a>
      </div>
      <div class="controls-and-stats-wrapper">
        <div class="settings-container">
            <div class="main-controls">
                <div class="practice-mode-controls control-button-group">
                    <button data-practice-type="short"><i class="fas fa-language"></i> 단문 연습</button>
                    <button data-practice-type="long"><i class="fas fa-align-left"></i> 장문 연습</button>
                    <button data-practice-type="freestyle"><i class="fas fa-pencil-alt"></i> 글쓰기</button>
                    <button id="gameModeBtn"><i class="fas fa-gamepad"></i> 게임하기</button>
                </div>
                <div class="feature-toggles control-button-group">
                    <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                    <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                    <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
                    <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> 자리연습 OFF</button>
                </div>
                <div class="selection-controls">
                    <div class="language-settings">
                        <label for="languageSelect" class="select-label" id="languageSelectLabel">언어:</label>
                        <select id="languageSelect">
                            <option value="kor">한글</option>
                            <option value="eng">영어</option>
                            <option value="js">JavaScript</option>
                            <option value="python">Python</option>
                        </select>
                    </div>
                    <div class="long-text-settings hidden" id="longTextSelectContainer">
                        <label for="longTextSelect" class="select-label">글 선택:</label>
                        <select id="longTextSelect"></select>
                    </div>
                    <div class="sound-settings" id="soundSettingsElement">
                        <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                        <select id="soundPackSelect"></select>
                    </div>
                    <div class="theme-settings" id="themeSettingsElement">
                        <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                        <select id="themeSelect">
                            <option value="dark">다크</option>
                            <option value="light">아이보리</option>
                            <option value="pink">핑크</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div id="stats">
            <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
            <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
            <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
            <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
        </div>
      </div>
      <div class="progress-bar-container">
          <div class="progress-bar"></div>
      </div>
      <div class="typing-area-container">
          <div id="keyboard-guide"></div>
          <h3 id="practice-title-display"></h3>
          <div id="line-display-area"> </div>
          <div id="typing-input-field-container">
              <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
              <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
          </div>
          <div id="upcoming-lines-area"> </div>
      </div>
      <div id="freestyle-area-container">
          <div id="freestyle-toolbar">
              <div class="freestyle-tool-group">
                  <button id="insertDateBtn" class="freestyle-tool-btn" title="오늘 날짜 삽입"><i class="fas fa-calendar-alt"></i></button>
                  <button id="insertTimeBtn" class="freestyle-tool-btn" title="현재 시간 삽입"><i class="fas fa-clock"></i></button>
                  <button id="emojiBtn" class="freestyle-tool-btn" title="이모티콘"><i class="far fa-smile"></i></button>
                   <div id="emoji-picker">
                      <span>😊</span><span>😂</span><span>😍</span><span>🤔</span><span>👍</span><span>❤️</span>
                      <span>🎉</span><span>✨</span><span>🔥</span><span>😭</span><span>🙏</span><span>⭐</span>
                  </div>
              </div>
              <div class="toolbar-divider"></div>
              <div class="freestyle-tool-group">
                  <button id="copyAllBtn" class="freestyle-tool-btn" title="전체 내용 복사"><i class="far fa-copy"></i></button>
                  <button id="clearAllBtn" class="freestyle-tool-btn" title="전체 삭제"><i class="fas fa-trash-alt"></i></button>
                  <button id="insertHrBtn" class="freestyle-tool-btn" title="구분선 삽입"><i class="fas fa-minus"></i></button>
              </div>
              <button id="focusModeBtn" class="freestyle-tool-btn" title="집중 모드 (ESC로 해제)"><i class="fas fa-expand"></i></button>
          </div>
          <textarea id="freestyle-input-area" placeholder="오늘 하루는 어땠나요? 당신의 이야기를 자유롭게 기록해보세요..."></textarea>
          <div id="freestyle-stats-bar">
              <span id="charCount">0자</span>
              <span id="wordCount">0단어</span>
          </div>
          <div class="freestyle-download-controls">
              <input type="text" id="freestyle-filename-input" placeholder="파일 이름 (선택사항)">
              <button id="download-freestyle-btn"><i class="fas fa-download"></i> 텍스트 파일로 저장</button>
          </div>
      </div>
      <div id="game-area-container">
      </div>
      <div id="result"></div>
    </div>
  </div>
  <div class="footer"> <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> </div>

  <div id="helpModal">
    <div class="help-modal-content">
      <span class="help-modal-close">&times;</span>
      <div id="helpModalBody"></div>
    </div>
  </div>

  <div id="result-share-popup" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--accent-active); color: var(--button-text-on-accent); padding: 12px 20px; border-radius: var(--border-radius-small); z-index: 1001; box-shadow: var(--shadow-soft); opacity: 0; transition: opacity 0.3s, transform 0.3s; pointer-events: none;">
      결과가 클립보드에 복사되었습니다!
  </div>

  <div id="shortcut-help-container">
    <div class="shortcut-tooltip">
        <strong>단축키 안내</strong><br>
        <b>Alt + ↓</b> : 다시 시작<br>
        <b>Alt + →</b> : 다음<br>
        <b>Alt + ←</b> : 이전<br>
    </div>
    <i class="fas fa-question-circle"></i>
  </div>

<script>
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = [];

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;
let layoutCollapsed = false;

let freestyleStatsInterval = null;
let freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl;
let freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker;
let copyAllBtn, clearAllBtn, insertHrBtn, focusModeBtn;
let charCountEl, wordCountEl;
let longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl;

let languageSelectEl, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, toggleLayoutBtn;
let languageSelectLabelEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameStartMessageEl, itemEffectPopupEl;
let gameHelpBtn, helpModal, helpModalBody, helpModalClose;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;

let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;
let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;
let gameOverlayEl;

let soundPlayedForThisInput = false;
let currentSoundPack = '1';
const soundFiles = {};
const totalSoundPacks = 13;
const filesPerPack = 10;

for (let i = 1; i <= totalSoundPacks; i++) {
    const packKey = String(i);
    soundFiles[packKey] = [];
    for (let j = 1; j <= filesPerPack; j++) {
        soundFiles[packKey].push(`soundFiles/${i}/${i} (${j}).wav`);
    }
}

let audioPool = {};
let soundTimer = null;

let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: '시간', icon: '⏱️' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: '소멸', icon: '💨' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: '생명', icon: '❤️' }
};
const rainfall_gameMainLevelsConfig = [
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];
let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };
let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;
const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';
let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;
const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '⭐' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: '🔥' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '❄️' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '↔️' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;
let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
let gb_isGameActive = false;
let countdownTimerId = null;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000;
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;
const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "황사", "일기", "예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "보드카", "데킬라", "하이볼", "탄산수",
    "비행기", "기차", "버스", "택시", "자전거", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신", "우주인", "방울뱀", "사막여우",
    "가로등", "가위질", "가정교사", "가족사진", "가지각색", "갈림길", "갈림돌", "감사패", "감정표현", "강강술래", "개발자", "거북선", "건강검진", "건널목", "검정고시", "결혼기념", "경기장", "경찰관", "경호원", "계란후라이", "고속도로", "고인돌", "골목대장", "공기놀이", "공중전화", "공휴일", "과일가게", "과학상자", "관광버스", "광화문", "구급상자", "국회의원", "군고구마", "그림일기", "극장", "기념품", "기상캐스터", "기차여행", "긴급상황", "김장독", "까마귀", "까치밥", "꽃다발", "꿀벌", "꿈나라", "끝말잇기", "나무늘보", "나비넥타이", "낙하산", "낚시꾼", "난센스퀴즈", "날개", "남대문", "낭떠러지", "내비게이션", "냉장고", "네잎클로버", "노랫소리", "노트북", "놀이공원", "농구공", "눈사람", "다리미", "다람쥐", "다이아몬드", "단풍잎", "달리기", "닭꼬치", "담벼락", "당근", "대통령", "대한민국", "도서관", "독수리", "돈가스", "돌고래", "동물원", "두부", "두통약", "드라이기", "등산화", "디지털카메라", "라면", "라디오", "로봇", "리모컨", "마라톤", "마법사", "만두", "만리장성"
].map(word => word.trim());
const sentencePool = {
    kor: ["따뜻한 햇살이 창가에 가득 내린다.", "작은 행복이 모여 큰 기쁨이 된다.", "오늘 하루도 수고했어요 당신 최고.", "좋아하는 노래를 들으며 힐링해요.", "푸른 하늘을 보며 마음껏 숨 쉬세요.", "예쁜 꽃 한 송이가 미소를 선물해요.", "가끔은 모든 걸 잊고 푹 쉬어요.", "좋은 친구는 삶의 큰 보물 같아요.", "새로운 시작은 언제나 설레는 법이죠.", "오늘 저녁은 맛있는 음식을 드세요.", "고요한 밤 별들이 속삭이는 소리.", "작은 친절이 세상을 따뜻하게 해요.", "주말엔 늦잠을 자며 여유를 즐겨요.", "새로운 길을 걷는 건 멋진 도전이야.", "마음속 작은 빛을 따라 나아가세요.", "오늘 하루 감사한 일을 떠올려봐요.", "사랑하는 사람에게 마음을 전하세요.", "힘든 날엔 잠시 하늘을 올려다봐요.", "달콤한 디저트는 기분 전환에 최고죠.", "아침 공기가 상쾌하게 느껴지네요.", "밤하늘의 별들은 저마다의 이야기를 간직하고 있다.", "바람결에 실려 온 꽃 향기가 마음을 간지럽힌다.", "익숙한 골목길에서 문득 새로운 풍경을 발견한다.", "가을비 내리는 날엔 따뜻한 차 한 잔이 위로가 된다.", "오래된 책갈피에서 잊고 지냈던 추억을 만났다.", "마음의 창을 열면 세상은 더 아름답게 보인다.", "작은 연못에 비친 달 그림자가 고요히 흔들린다.", "새벽녘 풀잎에 맺힌 이슬처럼 영롱한 순간들.", "구름 한 점 없는 하늘은 끝없는 가능성을 닮았다.", "모든 끝은 새로운 시작을 의미하기도 한다.", "삶이라는 여행길에서 가장 소중한 것은 경험이다.", "마음이 가는 대로 발길이 이끄는 대로.", "한 줄기 빛이 어둠을 가르듯 희망은 절망 속에서 피어난다.", "소리 없이 내리는 눈처럼 조용한 위로가 필요한 날.", "따뜻한 눈빛 하나가 얼어붙은 마음을 녹인다.", "시간의 강물은 쉼 없이 흐르지만 추억은 그 자리에 남는다.", "나뭇잎 사이로 부서지는 햇살이 보석처럼 반짝인다.", "낯선 곳에서의 우연한 만남은 예기치 못한 선물이다.", "가끔은 길을 잃어야 새로운 길을 찾을 수 있다.", "진정한 아름다움은 꾸밈없는 자연스러움에 있다.", "오늘 걷지 않으면 내일은 뛰어야 한다.", "백지장도 맞들면 낫다.", "뜻이 있는 곳에 길이 있다.", "시작이 반이다.", "하늘은 스스로 돕는 자를 돕는다.", "인내는 쓰지만 그 열매는 달다.", "구슬이 서 말이라도 꿰어야 보배다.", "세 살 버릇 여든까지 간다.", "젊어서 고생은 사서도 한다.", "콩 심은 데 콩 나고 팥 심은 데 팥 난다.", "키읔 티읕 피읖 히읗 거센소리 연습.", "쌍기역 쌍디귿 쌍비읍 쌍시옷 쌍지읒 된소리 연습.", "맑고 높은 가을 하늘 아래 코스모스 한들한들.", "반짝이는 별빛 아래 소중한 추억을 그려본다.", "찹쌀떡 맵쌀떡 온갖 떡들이 가득하다.", "깎아지른 절벽 아래 펼쳐진 푸른 바다.", "닭볶음탕과 칡넝쿨은 최고의 궁합이다.", "읊조리는 시 한 수가 마음을 촉촉하게 적신다.", "빠른 갈색 여우가 게으른 개 위로 뛰어넘는다.",  "외계생명체 존재 여부는 아직 밝혀지지 않았다.", "안녕하세요 만나서 반갑습니다 좋은 하루 되세요.", "대한민국 서울특별시 아름다운 우리 강산 푸르게 푸르게."],
    eng: ["The weather is lovely today perfect for a nice walk.", "Start your morning fresh with a warm cup of coffee.", "Listening to your favorite music always lifts the spirits.", "A small smile can brighten up someone's entire day.", "Sometimes it's nice to just gaze at the clear blue sky.", "A good book can be a wonderful and loyal companion.", "You did a great job today have a restful evening.", "Learning something new is always an exciting endeavor.", "Enjoy a delicious dinner together with your family.", "How about sending a warm greeting to an old friend?", "All that glitters is not gold.", "To be or not to be that is the question.", "The woods are lovely dark and deep.", "Hope is the thing with feathers that perches in the soul.", "It was the best of times it was the worst of times.", "The only thing we have to fear is fear itself.", "Stay hungry. Stay foolish.", "I have a dream that one day this nation will rise up.", "Two roads diverged in a wood and I I took the one less traveled by.", "The journey of a thousand miles begins with a single step.", "Be the change that you wish to see in the world.", "Not all those who wander are lost.", "That which does not kill us makes us stronger.", "Ask not what your country can do for you ask what you can do for your country.", "The unexamined life is not worth living.", "Where there is love there is life.", "The quick brown fox jumps over the lazy dog.", "Pack my box with five dozen liquor jugs.", "Sphinx of black quartz judge my vow.", "Amazingly few discotheques provide jukeboxes.", "How vexingly quick daft zebras jump.", "Bright vixens jump dozy fowl quack.", "Quick wafting zephyrs vex bold Jim.", "Crazy Fredrick bought many very exquisite opal jewels.", "Hello how are you today?", "Thank you very much for your help.", "Pleased to meet you.", "Practice makes perfect.", "Have a wonderful day ahead.", "Good morning sunshine.", "Keep up the good work.", "See you later alligator.", "What a beautiful surprise.", "Actions speak louder than words."],
    korLong: [
        { title: "다락방의 햇살", content: "낡은 다락방 창문으로 스며드는 오후의 햇살은 먼지 쌓인 시간 위로 부드럽게 내려앉았다. 공기 중에는 오래된 책 냄새와 희미한 나무 향기가 뒤섞여, 마치 잊혀진 이야기들이 낮은 목소리로 속삭이는 듯했다. 빛줄기를 따라 부유하는 작은 먼지들은 금빛 가루처럼 반짝였고, 그 너머로 보이는 바깥세상은 한 폭의 수채화처럼 아련했다. 나는 삐걱이는 나무 계단을 밟고 올라와, 창가 낡은 흔들의자에 가만히 몸을 기댔다. 창밖으로 보이는 느티나무는 수백 년의 세월을 말없이 지켜온 듯, 바람이 불 때마다 잎사귀를 흔들며 낮은 노래를 불렀다. 그 풍경 속에서 나는 어린 시절의 기억들을 하나씩 꺼내보았다. 할머니가 들려주시던 옛날이야기, 친구들과 뛰놀던 골목길의 저녁노을, 처음으로 느껴본 설렘과 아픔. 모든 것이 희미한 필름처럼 머릿속을 스쳐 지나갔지만, 그 감정만큼은 여전히 선명하게 남아 가슴 한구석을 아릿하게 만들었다. 시간은 모든 것을 변화시키지만, 기억 속에 새겨진 온기는 영원히 변치 않는다는 것을, 나는 그 순간 깨달았다. 어쩌면 우리는 모두 마음속에 자신만의 작은 다락방을 가지고 살아가는지도 모른다. 힘들고 지칠 때마다 찾아가 위로받을 수 있는, 소중한 추억들이 잠들어 있는 비밀스러운 공간을." },
        { title: "밤하늘의 별", content: "깊은 밤, 창밖으로 무수한 별들이 보석처럼 쏟아질 듯 반짝였다. 나는 따뜻한 차 한 잔을 들고 창가에 서서, 끝없이 펼쳐진 밤하늘의 신비를 가만히 응시했다. 어둠이 짙을수록 별빛은 더욱 선명해졌고, 그 고요한 빛줄기는 내 마음속 깊은 곳까지 스며드는 듯했다. 저 멀리 이름 모를 별 하나가 유난히 밝게 빛나고 있었다. 마치 길 잃은 나그네에게 방향을 알려주는 등대처럼, 혹은 간절한 소망을 담아 하늘로 띄워 보낸 작은 등불처럼. 나는 그 별을 보며 어린 시절 순수했던 꿈들을 떠올렸다. 세상을 탐험하는 용감한 모험가, 사람들에게 감동을 주는 예술가, 밤하늘의 비밀을 푸는 천문학자. 현실의 벽에 부딪혀 하나둘씩 접어두었던 그 꿈들이, 별빛 아래에서 다시금 희미하게 살아나는 것을 느꼈다. 어쩌면 꿈이란, 완전히 사라지는 것이 아니라 잠시 우리 마음속 밤하늘에 숨어 반짝일 기회를 기다리는 별과 같은 것일지도 모른다. 중요한 것은 그 별빛을 잊지 않고, 언젠가 다시 그 빛을 따라 나아갈 용기를 내는 것이리라. 나는 마지막 한 모금의 차를 마시며, 내 마음속 별들을 향해 조용히 다짐했다. 아직 끝나지 않은 나의 이야기를 계속 써 내려가겠다고." },
        { title: "새벽 호숫가", content: "이른 새벽, 안개가 자욱한 호숫가를 홀로 걸었다. 물안개는 마치 살아있는 생명체처럼 부드럽게 수면 위를 감돌았고, 멀리 보이는 산자락은 희미한 먹빛 그림자처럼 느껴졌다. 세상의 모든 소음이 잠든 듯, 오직 내 발걸음 소리와 이따금 들려오는 물새 소리만이 적막을 깨뜨렸다. 차가운 새벽 공기가 코끝을 스치자 정신이 맑아지는 기분이었다. 나는 호숫가 작은 벤치에 앉아, 서서히 밝아오는 동쪽 하늘을 바라보았다. 안개 너머로 붉은 기운이 조금씩 번지기 시작하더니, 이윽고 장엄한 해가 그 모습을 드러냈다. 떠오르는 태양은 밤새 호수를 뒤덮었던 안개를 부드럽게 걷어내었고, 그 아래 숨겨져 있던 맑고 투명한 호수의 민낯이 햇살 아래 눈부시게 반짝였다. 그 순간, 나는 마치 새로운 세상이 열리는 듯한 경이로움을 느꼈다. 어둠과 혼돈 속에서도 희망은 언제나 그렇게 떠오르는 것이라고, 자연은 말없이 가르쳐주는 듯했다. 삶이 때로 짙은 안개 속에 갇힌 것처럼 느껴질 때도 있겠지만, 그 안개 너머에는 분명 찬란한 아침이 기다리고 있음을, 그리고 그 아침을 맞이하기 위해서는 묵묵히 자신의 길을 걸어가야 함을, 나는 새벽 호숫가에서 깨달았다. 해가 완전히 떠오르자, 호수는 금빛으로 물들었고, 나는 새로운 하루를 시작할 용기를 얻어 다시 발걸음을 옮겼다." },
        { title: "담쟁이덩굴", content: "오래된 골목길 모퉁이를 돌자, 담벼락에 기대어 자라는 작은 담쟁이덩굴이 눈에 들어왔다. 거친 시멘트 벽을 가느다란 줄기로 힘겹게 부여잡고, 초록빛 잎사귀들을 햇살을 향해 힘껏 펼치고 있는 모습이었다. 그 작은 생명체의 강인함 앞에서 나는 잠시 발걸음을 멈추었다. 척박한 환경 속에서도 포기하지 않고, 자신의 자리를 묵묵히 지키며 생명의 푸르름을 피워내는 그 모습이 경이롭게 느껴졌다. 어쩌면 우리의 삶도 저 담쟁이덩굴과 크게 다르지 않을지도 모른다. 때로는 거칠고 힘겨운 현실이라는 벽에 부딪히고, 예상치 못한 시련의 바람에 흔들리기도 하지만, 그럼에도 불구하고 우리는 어떻게든 살아남아 자신의 이야기를 써 내려간다. 마음속 깊은 곳에 간직한 작은 희망의 씨앗을 붙들고, 한 뼘이라도 더 햇살을 향해 나아가려 애쓰면서 말이다. 담쟁이덩굴은 화려한 꽃을 피우거나 달콤한 열매를 맺지는 않지만, 그 자체로 충분히 아름답고 의미 있는 존재였다. 그것은 우리에게 말없이 가르쳐주고 있었다. 삶의 가치는 결과에만 있는 것이 아니라, 그 과정을 묵묵히 견뎌내고 자신의 자리에서 최선을 다하는 그 모든 순간에 깃들어 있다는 것을. 나는 작은 담쟁이덩굴에게서 큰 위로와 용기를 얻고, 다시금 내 삶의 담벼락을 향해 한 걸음 내디뎠다." },
        { title: "기차를 기다리며", content: "늦은 오후, 텅 빈 기차역 플랫폼에 홀로 앉아 곧 떠나갈 기차를 기다렸다. 하늘에는 회색빛 구름이 낮게 드리워져 있었고, 바람은 스산하게 옷깃을 파고들었다. 어디론가 떠나고 싶은 마음과 어딘가에 머무르고 싶은 마음이 교차하는, 그런 묘한 감상에 젖어들었다. 잠시 후, 저 멀리서 기차가 육중한 소리를 내며 플랫폼으로 서서히 들어왔다. 낡았지만 정감 가는 기차의 창문 너머로, 각자의 사연을 안고 떠나는 사람들의 모습이 어렴풋이 보였다. 설렘과 아쉬움, 기대와 불안이 뒤섞인 그들의 표정 속에서 나는 내 삶의 여러 여정들을 떠올렸다. 새로운 시작을 향해 떠났던 길, 아쉬운 이별을 뒤로하고 돌아섰던 길, 목적지도 모른 채 그저 발길 닿는 대로 걸었던 길까지. 그 모든 길 위에서 나는 수많은 사람들을 만났고, 다양한 감정들을 경험했으며, 조금씩 성장해왔다. 기차가 멈춰 서고 문이 열리자, 나는 가방을 고쳐 메고 자리에서 일어섰다. 이번 여정의 끝에는 무엇이 기다리고 있을지 알 수 없지만, 그것 또한 내 삶의 한 페이지를 채워줄 소중한 경험이 될 것이라 믿었다. 기차는 다시 한번 육중한 기적 소리를 내며 천천히 움직이기 시작했고, 나는 창밖으로 멀어져 가는 익숙한 풍경들을 바라보며, 새로운 이야기가 시작될 미지의 공간을 향해 나아갔다." },
        { title: "오래된 소설책", content: "작은 도서관 구석, 햇살이 비껴드는 창가 자리에 앉아 오래된 소설책을 펼쳤다. 종이에서는 세월의 흔적이 느껴지는 희미한 냄새가 풍겨왔고, 손때 묻은 페이지들은 수많은 독자들의 이야기를 품고 있는 듯했다. 나는 한 자 한 자 천천히 글자를 따라 읽어 내려가며, 작가가 만들어낸 세계 속으로 깊이 빠져들었다. 그곳에는 내가 미처 경험하지 못한 삶과 감정들이 있었고, 현실에서는 만날 수 없는 매력적인 인물들이 살아가고 있었다. 때로는 주인공의 기쁨에 함께 웃고, 때로는 그의 슬픔에 함께 눈물 흘리며, 나는 책 속의 이야기와 온전히 하나가 되었다. 책을 읽는다는 것은 어쩌면, 시간과 공간을 초월하여 다른 누군가의 삶을 잠시 빌려 살아보는 것과 같은 경험일지도 모른다. 그 경험을 통해 우리는 세상을 바라보는 새로운 시각을 얻고, 인간과 삶에 대한 깊은 이해에 다가서게 된다. 한 권의 책은 때로 백 명의 스승보다 더 큰 가르침을 주기도 하고, 그 어떤 위로보다 더 따뜻한 안식을 선물하기도 한다. 나는 마지막 책장을 덮으며, 마음속에 잔잔하게 퍼지는 깊은 여운을 느꼈다. 책 속에서 만난 이야기와 인물들은 한동안 내 곁을 떠나지 않고, 내 삶의 중요한 일부가 되어 함께할 것 같았다. 그것이 바로 책이 가진 위대한 힘이리라." },
        { title: "강변의 노을", content: "어스름이 내리는 저녁, 나는 강변을 따라 천천히 걷고 있었다. 강물은 해 질 녘의 붉은 노을을 온통 담아내며 고요히 흘러갔고, 강 건너편 도시의 불빛들은 하나둘씩 반짝이기 시작했다. 바람은 잔잔했고, 공기는 상쾌했다. 나는 강둑에 잠시 멈춰 서서, 아름다운 저녁 풍경을 가만히 바라보았다. 매일 반복되는 일상 속에서 우리는 종종 이런 순간의 아름다움을 잊고 살아간다. 하지만 잠시 멈춰 서서 주변을 둘러보면, 세상은 우리가 생각하는 것보다 훨씬 더 다채롭고 경이로운 모습으로 가득 차 있다는 것을 깨닫게 된다. 저녁노을이 만들어내는 황홀한 빛의 향연, 밤하늘을 수놓는 무수한 별들의 반짝임, 이름 모를 풀꽃의 소박한 아름다움까지. 이런 작은 것들 속에 삶의 진정한 기쁨과 위안이 숨겨져 있는지도 모른다. 중요한 것은 그것을 발견할 수 있는 열린 마음과 세상을 바라보는 따뜻한 시선이다. 어둠이 완전히 내려앉고 도시의 불빛이 더욱 선명해지자, 나는 다시 발걸음을 옮겼다. 짧은 산책이었지만, 내 마음은 어느새 평온함과 감사함으로 가득 차 있었다. 일상의 소중함을 다시 한번 깨닫게 해준 아름다운 저녁이었다." },
        { title: "봉숭아 꽃물", content: "오랜만에 찾은 고향 집 마당에는 할머니가 심어두신 봉숭아 꽃이 곱게 피어 있었다. 어릴 적, 할머니 손을 잡고 봉숭아 꽃잎을 빻아 손톱에 물들이던 기억이 아련하게 떠올랐다. 빨갛게 물든 작은 손톱을 보며 세상을 다 가진 듯 기뻐했던 그 시절. 그때는 모든 것이 단순했고, 작은 것 하나에도 큰 행복을 느낄 수 있었다. 세월이 흘러 어른이 된 지금, 나는 많은 것을 가졌지만 그때만큼 순수하게 행복하다고 말할 수 있을까. 문득 그런 생각이 들었다. 어쩌면 우리는 성장하면서 세상을 너무 복잡하게 바라보고, 진정한 행복의 의미를 잊어버리는 것은 아닐까. 봉숭아 꽃은 예전과 다름없이 여전히 그 자리에서 소박한 아름다움을 뽐내고 있었다. 그것은 나에게 말없이 가르쳐주는 듯했다. 행복은 멀리 있는 것이 아니라, 바로 우리 마음속에, 그리고 우리가 지나쳐온 소중한 추억들 속에 있다는 것을. 나는 마당 한쪽에 쪼그리고 앉아, 바람에 흔들리는 봉숭아 꽃잎을 한참 동안 바라보았다. 그리고 어린 시절의 나에게, 그리고 지금의 나에게 조용히 속삭였다. 괜찮아, 지금 이 순간을 소중히 여기면 돼. 그것이 바로 행복이야." },
        { title: "비 내리는 오후", content: "비 내리는 오후, 나는 창가에 앉아 하염없이 창밖을 바라보았다. 굵은 빗방울들이 유리창을 세차게 두드렸고, 세상은 온통 잿빛 물감으로 덧칠한 듯 흐릿했다. 이런 날이면 괜스레 마음이 차분해지고, 평소에는 떠오르지 않던 생각들이 꼬리에 꼬리를 물고 이어지곤 한다. 빗소리는 마치 세상의 모든 소음을 잠재우고, 오직 내면의 목소리에만 귀 기울이도록 만드는 마법과 같았다. 나는 잊고 지냈던 사람들을 떠올리고, 지나간 시간들을 반추하며, 미래의 불확실함에 대해 조용히 고민했다. 어쩌면 비는, 우리에게 잠시 멈춰 서서 자신을 돌아볼 시간을 선물하는 것일지도 모른다. 빠르게 변화하는 세상 속에서 미처 돌보지 못했던 마음의 상처들을 어루만지고, 잊고 지냈던 소중한 가치들을 다시 한번 되새길 수 있도록 말이다. 빗줄기가 조금씩 가늘어지더니, 이윽고 먹구름 사이로 희미한 햇살 한 줄기가 비쳐들었다. 비 온 뒤의 세상은 이전보다 더욱 깨끗하고 싱그러워 보였다. 내 마음도 한바탕 비를 맞고 난 뒤처럼, 한결 가볍고 맑아진 것을 느꼈다. 비는 모든 것을 쓸어내리고, 또다시 새로운 시작을 준비하게 만드는 자연의 경이로운 순환이었다." },
        { title: "늦가을 오솔길", content: "늦가을, 낙엽이 수북이 쌓인 오솔길을 혼자 걸었다. 발걸음을 옮길 때마다 바스락거리는 낙엽 소리가 정겹게 들려왔고, 코끝에는 쌉싸름하면서도 향긋한 가을 냄새가 스며들었다. 하늘은 더없이 높고 푸르렀으며, 나뭇가지 사이로 부서지는 햇살은 따스했다. 나는 천천히 걸으며, 화려했던 여름을 보내고 이제 겨울을 맞이할 준비를 하는 자연의 모습을 가만히 관찰했다. 울긋불긋 아름다운 색으로 물들었던 단풍잎들은 이제 마지막 빛을 발하며 땅으로 떨어져 내렸고, 앙상한 가지만 남은 나무들은 다가올 추위를 묵묵히 견뎌낼 준비를 하는 듯했다. 그 모습에서 나는 삶의 순환과 자연의 섭리를 느꼈다. 모든 것에는 시작과 끝이 있고, 성장의 시간이 있으면 쇠퇴의 시간도 있으며, 화려한 순간이 있으면 고요한 침묵의 순간도 있다는 것을. 그리고 그 모든 과정은 그 자체로 의미 있고 아름답다는 것을. 낙엽은 끝이 아니라 새로운 시작을 위한 준비였다. 땅으로 돌아가 거름이 되어, 다음 해 봄에 새로운 생명이 움틀 수 있도록 자신을 내어주는 것이다. 나는 깊어가는 가을의 정취 속에서, 삶의 유한함과 그 속에서 우리가 가져야 할 겸손함, 그리고 모든 것을 받아들이고 순응하는 지혜에 대해 생각했다. 낙엽 밟는 소리가 배경음악처럼 깔리는 그 길 위에서, 나는 자연이 주는 깊은 위안과 가르침을 얻었다." },
        { title: "바닷가 등대", content: "바람이 세차게 불던 어느 겨울날, 나는 바닷가 작은 등대를 찾아갔다. 하얀 포말을 일으키며 거칠게 밀려오는 파도와 매서운 바닷바람 속에서도 등대는 조금의 흔들림 없이 굳건히 서 있었다. 그 모습은 마치 세상의 온갖 풍파를 견뎌내며 자신의 자리를 지키는 고독한 수호자 같았다. 어둠이 내리면 등대는 어김없이 밝은 빛을 발하여, 밤바다를 항해하는 배들에게 길을 안내할 것이다. 그 빛은 단순한 불빛이 아니라, 험난한 바다 위에서 길을 잃은 이들에게 희망과 안도를 주는 생명의 빛이리라. 나는 문득 우리 삶에도 저런 등대와 같은 존재가 필요하다는 생각을 했다. 때로는 거친 파도처럼 힘겨운 시련이 몰아치고, 짙은 안개처럼 방향을 잃고 방황할 때, 우리를 올바른 길로 인도해주고 마음의 등불이 되어줄 그런 존재 말이다. 그것은 때로는 현명한 조언을 해주는 스승일 수도 있고, 변함없는 사랑을 주는 가족일 수도 있으며, 혹은 마음속 깊이 간직한 신념이나 가치관일 수도 있다. 중요한 것은 자신만의 등대를 가지고, 그 빛을 따라 꿋꿋이 나아가는 것이다. 세찬 바람 속에서도 묵묵히 빛을 밝히는 등대를 바라보며, 나는 내 삶의 등대는 무엇인지 다시 한번 생각해보았다." },
        { title: "플라타너스 나무", content: "어린 시절, 동네 어귀에는 커다란 플라타너스 나무가 한 그루 서 있었다. 여름이면 무성한 잎으로 시원한 그늘을 만들어주었고, 가을이면 황금빛 낙엽을 아름답게 흩날렸으며, 겨울이면 앙상한 가지에 눈꽃을 피워 장관을 이루었다. 그 나무 아래는 언제나 아이들의 웃음소리가 끊이지 않는 놀이터였고, 동네 어른들의 정겨운 이야기가 오가는 쉼터였다. 나는 그 나무 아래에서 친구들과 술래잡기를 하고, 딱지치기를 하고, 때로는 가만히 앉아 하늘을 바라보며 엉뚱한 상상에 빠지기도 했다. 플라타너스 나무는 나의 유년 시절 모든 기억을 말없이 지켜봐 준 든든한 친구이자 보호자였다. 세월이 흘러 나는 어른이 되었고, 그 동네를 떠나온 지도 오래되었다. 하지만 문득 그 플라타너스 나무가 그리워질 때가 있다. 모든 것이 빠르게 변해가는 이 세상 속에서, 변함없이 그 자리를 지키고 있을 것 같은 그 나무의 존재가 주는 안정감 때문일까. 어쩌면 그 나무는 나에게 단순한 나무 이상의 의미였는지도 모른다. 그것은 돌아갈 수 없는 아름다운 시절에 대한 그리움이자, 순수했던 마음을 다시 찾고 싶은 작은 소망의 상징이었을 것이다. 언젠가 다시 그 나무 아래 서면, 나는 잠시나마 모든 것을 잊고 어린 시절의 나로 돌아갈 수 있을 것만 같다." },
        { title: "오래된 엘피판", content: "나는 가끔 오래된 엘피판을 꺼내 턴테이블 위에 올려놓는다. 지지직거리는 작은 소음과 함께 바늘이 레코드의 검은 골을 따라 천천히 움직이기 시작하면, 곧이어 따뜻하고 풍부한 아날로그 사운드가 공간을 가득 채운다. 디지털 음원에서는 느낄 수 없는 그 특유의 깊이와 온기는 마치 시간 여행을 하는 듯한 묘한 감흥을 불러일으킨다. 엘피판 한 장에는 단순히 음악만 담겨 있는 것이 아니다. 그 음악이 유행했던 시대의 공기, 그 음악을 함께 들었던 사람들과의 추억, 그리고 그 음악을 들으며 느꼈던 나의 젊은 날의 감정들이 고스란히 담겨 있다. 그래서 엘피를 듣는 것은 단순한 음악 감상을 넘어, 지나간 시간과의 조우이자 잊혀진 기억과의 재회이기도 하다. 때로는 빛바랜 앨범 재킷을 어루만지며 그 시절을 추억하고, 때로는 가사를 음미하며 그 의미를 되새기기도 한다. 세상은 점점 더 빠르고 편리한 것을 추구하지만, 나는 가끔 이렇게 느리고 불편한 아날로그의 세계에 머무르는 것을 좋아한다. 그 속에는 디지털이 결코 흉내 낼 수 없는 인간적인 따뜻함과 시간의 깊이가 존재하기 때문이다. 엘피판이 돌아가는 것을 가만히 바라보며, 나는 오늘도 잊혀진 시간 속으로 짧은 여행을 떠난다." },
        { title: "시골 간이역", content: "작은 시골 간이역, 해 질 녘 플랫폼에는 기차를 기다리는 사람들보다 먼저 와 자리를 잡은 저녁노을이 더 짙었다. 나는 낡은 나무 의자에 앉아, 서쪽 하늘을 붉게 물들이며 서서히 스러져가는 노을의 마지막 장관을 바라보았다. 세상의 모든 색을 다 끌어모은 듯한 그 찬란한 빛의 향연 앞에서, 인간의 언어는 한없이 초라하게 느껴졌다. 노을은 낮과 밤의 경계에서 피어나는 짧지만 강렬한 예술과 같았다. 뜨거웠던 하루의 열정을 모두 불태우고, 이제 고요한 휴식의 시간으로 접어들기 위한 마지막 인사처럼. 나는 그 아름다움에 매료되어 한동안 아무 말도 할 수 없었다. 잠시 후, 노을이 완전히 자취를 감추고 어둠이 내려앉자, 하늘에는 하나둘씩 별들이 모습을 드러내기 시작했다. 그것은 마치 화려한 무대가 끝나고 다음 막이 오르기 전의 고요한 설렘과도 같았다. 삶에도 저런 노을과 같은 순간들이 있을 것이다. 모든 것을 쏟아부은 뒤 맞이하는 찬란한 마무리, 그리고 새로운 시작을 예비하는 고요한 성찰의 시간. 우리는 그 순간들을 통해 지나온 길을 돌아보고, 앞으로 나아갈 힘을 얻는다. 나는 깊어가는 밤의 적막 속에서, 오늘 하루 나에게 주어진 시간과 경험들에 감사하며, 내일 또다시 떠오를 새로운 태양을 기다렸다." },
        { title: "만년필 일기", content: "나는 오래된 만년필로 일기를 쓰는 것을 좋아한다. 사각거리는 펜촉이 종이 위를 스치는 소리, 손끝으로 전해져 오는 잉크의 미세한 흐름, 그리고 한 자 한 자 정성스럽게 써 내려가는 글자들이 만들어내는 그 모든 과정이 나에게는 작은 의식과도 같다. 디지털 시대에 손으로 글을 쓴다는 것은 어쩌면 비효율적이고 번거로운 일일지도 모른다. 하지만 나는 그 느림과 불편함 속에서 오히려 더 깊은 사색과 진정한 자기표현의 즐거움을 발견한다. 컴퓨터 자판으로는 미처 담아낼 수 없는 생각의 결들과 감정의 미묘한 떨림들이, 만년필을 통해 종이 위에 고스란히 새겨지는 것을 느낀다. 일기장에는 그날 있었던 소소한 사건들뿐만 아니라, 마음속 깊은 곳에 숨겨두었던 생각들, 누구에게도 말하지 못했던 비밀들, 그리고 미래에 대한 막연한 기대와 불안까지 모든 것이 담긴다. 그것은 오롯이 나 자신과 마주하는 시간이며, 내 삶의 발자취를 기록하는 소중한 작업이다. 훗날 이 일기장을 다시 펼쳐보았을 때, 나는 지금 이 순간의 나를 만나고, 그 시절의 고민과 기쁨을 공유하며, 내가 얼마나 성장했는지를 돌아볼 수 있을 것이다. 만년필의 잉크가 마르듯 시간은 흘러가겠지만, 종이 위에 남겨진 나의 이야기는 영원히 그 자리에 남아 빛날 것이다." },
        { title: "산사의 풍경 소리", content: "어느 늦봄, 나는 이름 모를 작은 산사의 툇마루에 앉아 있었다. 산사는 깊은 산속에 고즈넉이 자리 잡아, 세상의 모든 번뇌와 소음으로부터 벗어난 듯 평화로웠다. 처마 끝에 매달린 풍경은 바람이 불 때마다 맑고 청아한 소리를 냈고, 그 소리는 내 마음속까지 잔잔하게 울려 퍼졌다. 마당에는 수령을 알 수 없는 오래된 매화나무 한 그루가 마지막 꽃잎을 떨구고 있었고, 그 아래에는 작은 새 한 마리가 날아와 지저귀고 있었다. 나는 눈을 감고 가만히 그 모든 소리와 풍경을 마음에 담았다. 자연의 소리는 그 어떤 음악보다 아름다웠고, 산사의 고요함은 그 어떤 명상보다 깊은 평화를 가져다주었다. 복잡했던 머릿속은 어느새 텅 비고, 무거웠던 마음은 한결 가벼워졌다. 우리는 종종 너무 많은 것을 보고 듣고 생각하며 살아간다. 그래서 정작 중요한 내면의 소리에는 귀 기울이지 못하고, 진정한 휴식의 의미를 잊어버리곤 한다. 하지만 이렇게 잠시 모든 것을 내려놓고 자연 속에 머무르다 보면, 비로소 우리가 얼마나 작은 존재인지, 그리고 우리가 진정으로 추구해야 할 가치는 무엇인지 깨닫게 된다. 풍경 소리가 다시 한번 맑게 울리자, 나는 깊은 숨을 내쉬며 자리에서 일어섰다. 짧은 시간이었지만, 산사가 준 깊은 평화와 깨달음은 오랫동안 내 마음속에 남아 있을 것 같았다." },
        { title: "오래된 흑백사진", content: "나는 가끔 오래된 흑백사진을 들여다본다. 빛바랜 사진 속에는 지금은 만날 수 없는 사람들의 미소와 다시 돌아갈 수 없는 풍경들이 담겨 있다. 컬러사진이 현실을 있는 그대로 생생하게 재현한다면, 흑백사진은 현실 너머의 어떤 아련한 감성과 시간의 깊이를 느끼게 해주는 묘한 매력이 있다. 색이 사라진 세상은 오히려 더 많은 것을 상상하게 만들고, 인물의 표정과 배경의 분위기에 더욱 집중하게 만든다. 사진 속 인물들은 어떤 이야기를 간직하고 있을까, 그들은 어떤 꿈을 꾸고 어떤 사랑을 했을까. 나는 그런 상상을 하며 사진 속 시간으로 잠시 여행을 떠나곤 한다. 흑백사진은 단순한 기록이 아니라, 한 시대의 초상이자 누군가의 삶의 증거이다. 그 속에는 기쁨과 슬픔, 만남과 이별, 희망과 절망 등 인간이 겪을 수 있는 모든 감정들이 응축되어 있다. 그래서 흑백사진을 보고 있으면, 때로는 알 수 없는 그리움에 가슴이 아련해지기도 하고, 때로는 삶의 숙연함에 고개가 숙여지기도 한다. 사진 한 장이 건네는 수많은 이야기들. 나는 그 이야기들을 통해 과거와 현재를 잇고, 사라진 시간 속에서 변치 않는 가치를 발견한다. 흑백사진은 나에게 침묵으로 더 많은 것을 말해주는 오래된 친구와 같다." },
        { title: "겨울밤의 눈", content: "한겨울 밤, 창밖에는 하얀 눈이 소리 없이 내리고 있었다. 나는 따뜻한 코코아 한 잔을 들고 창가에 서서, 밤새 세상을 하얗게 뒤덮을 것 같은 눈송이들을 하염없이 바라보았다. 가로등 불빛 아래 춤추듯 흩날리는 눈송이들은 마치 동화 속 한 장면처럼 비현실적으로 아름다웠다. 눈은 세상의 모든 더러움과 소음을 하얗게 덮어버리고, 고요하고 순수한 평화를 가져다주는 것 같았다. 나는 어린아이처럼 창문에 입김을 불어 작은 그림을 그리기도 하고, 손을 내밀어 차가운 눈송이를 직접 만져보기도 했다. 눈이 내리는 풍경은 언제나 나를 설레게 하고, 잊고 지냈던 동심을 일깨워준다. 어쩌면 눈은, 하늘이 우리에게 보내는 하얀 편지일지도 모른다. 잠시 모든 것을 잊고 순수한 기쁨을 느껴보라고, 그리고 새로운 시작을 준비하라고 속삭이는 아름다운 편지. 나는 코코아의 마지막 한 모금을 마시며, 내일 아침 눈부시게 펼쳐질 하얀 세상을 상상했다. 발자국 하나 없는 깨끗한 눈밭 위를 처음으로 걷는 기분은 얼마나 상쾌할까. 눈이 그치고 아침이 오면, 나는 가장 먼저 하얀 세상 속으로 달려 나가, 겨울이 주는 특별한 선물을 만끽할 것이다." },
        { title: "사람 사는 시장", content: "나는 가끔 오래된 시장을 찾는 것을 좋아한다. 대형마트의 깔끔함과 편리함도 좋지만, 시장에는 그곳에서만 느낄 수 있는 특별한 활기와 정겨움이 있다. 좌판 가득 싱싱한 채소와 과일을 진열해놓고 구성진 목소리로 손님을 부르는 상인들, 흥정을 하며 덤을 얻어가는 손님들의 웃음소리, 맛있는 냄새를 풍기며 발길을 유혹하는 길거리 음식들까지. 시장은 살아있는 사람들의 이야기로 가득한 공간이다. 나는 천천히 시장 골목을 걸으며, 다양한 물건들을 구경하고 사람들의 살아가는 모습을 관찰한다. 그 속에서 나는 잊고 지냈던 인간적인 따뜻함과 소박한 삶의 아름다움을 발견한다. 시장 상인들의 거친 손마디에는 정직한 땀의 가치가 담겨 있고, 그들의 구릿빛 얼굴에는 세월의 흔적과 삶의 지혜가 새겨져 있다. 그들은 단순히 물건을 파는 것이 아니라, 자신의 삶을 나누고 사람들과 정을 주고받는다. 그래서 시장에서의 거래는 단순한 매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다." },
    ],
    engLong: [
        { title: "The Old Attic", content: "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper and faint wood, a nostalgic perfume that seemed to whisper tales of bygone eras. Tiny dust motes danced in the invading sunbeams, sparkling like miniature galaxies, and the world outside, viewed through the grimy pane, appeared as a distant, dreamlike watercolor. I had creaked my way up the wooden stairs, settling into the worn comfort of a rocking chair by the window. Below, an ancient oak stood sentinel, its leaves rustling a quiet, timeless song with every breeze, a silent observer of centuries unfolding. In that tranquil tableau, I found myself sifting through childhood memories: a grandmother's gentle voice narrating fairy tales, the vibrant hues of a sunset over a familiar alleyway, the first stirrings of a young heart's joy and sorrow. Time, in its relentless march, may alter all things, yet the warmth embedded in memory, I realized, remains an immutable sanctuary. Perhaps we all carry a small, secret attic within our souls, a place of solace filled with cherished recollections, a haven to retreat to when the world outside grows too loud." },
        { title: "The Night Sky", content: "Under the velvet cloak of a moonless night, countless stars were scattered across the celestial canvas like diamonds on black silk. With a warm cup of herbal tea cradled in my hands, I stood by the window, lost in the profound mystery of the infinite expanse. The deeper the darkness, the more intensely the starlight seemed to pierce through, its serene luminescence seeping into the very core of my being. One distant, unnamed star shone with a particular brilliance, a beacon for a lost traveler, perhaps, or a tiny lantern carrying a whispered wish to the heavens. Gazing at it, I was transported back to the untainted dreams of youth: a daring explorer charting unknown territories, an artist evoking profound emotions, an astronomer unravelling cosmic secrets. Those aspirations, once so vivid but gradually set aside against the unyielding walls of reality, flickered faintly back to life under the starlight. Maybe dreams never truly vanish; perhaps they merely slumber in the night sky of our hearts, awaiting the courage to be pursued once more. As I sipped the last of my tea, I made a quiet promise to those stars, and to myself: to keep writing the unfinished chapters of my own story, guided by their distant, unwavering light." },
        { title: "The Ancient Woods", content: "The scent of pine needles and damp earth filled the air as she walked deeper into the ancient woods. Sunlight struggled to penetrate the thick canopy, casting an ethereal, green-tinged light on the forest floor. Moss grew like velvet on the trunks and branches of old trees, and delicate ferns uncurled their fronds in the damp places where shadows lingered. She paused by a gnarled oak, its bark a tapestry of a thousand storms weathered and a thousand suns embraced. It seemed to whisper secrets of the ages, of creatures seen and unseen, of seasons turning in an endless, graceful dance. Here, away from the clamor of human invention, she felt a profound connection to something primal, something enduring. The forest was not merely a collection of trees, but a living, breathing entity, a sanctuary for the soul seeking quietude and a reminder of the intricate beauty of the natural world. Each fallen leaf crunched underfoot was a note in an ancient song, a testament to the cycle of life, death, and renewal, a humbling perspective in the grand theatre of existence." },
        { title: "The Secret Courtyard", content: "In the heart of the bustling city, there existed a small, almost forgotten courtyard, a tiny oasis of green amidst the towering steel and glass. Ivy climbed the old brick walls, and a single, resilient cherry tree bloomed defiantly each spring, its blossoms a soft pink rebellion against the urban grey. Few knew of this place, tucked away behind a narrow alley, and those who did cherished it as a secret haven. Here, the city's roar subsided to a distant hum, and one could hear the cooing of pigeons or the rustle of leaves in the gentle breeze. It was a place for quiet contemplation, for stolen moments of peace in a world that seldom seemed to pause. Sometimes, an artist would sit on the worn stone bench, sketching the play of light and shadow, or a writer would fill a notebook with fleeting thoughts and observations, inspired by the unexpected tranquility found in such an urban pocket of serenity. This courtyard was a reminder that even in the most concrete of jungles, nature, and a moment's peace, could always find a way to endure." },
        { title: "The Lighthouse", content: "The old lighthouse stood sentinel on the jagged cliff, its stoic form a familiar silhouette against the turbulent, grey sky. For generations, its beam had cut through the darkest storms, a steadfast promise of guidance to sailors navigating the treacherous coastal waters. The keeper, a man with a weather-beaten face and eyes that held the wisdom of the sea, lived a solitary life, his only companions the cry of gulls and the ceaseless rhythm of the waves. He knew every mood of the ocean, from its gentle summer caress to its furious winter rage. His days were marked by routine: tending the great lamp, polishing the massive Fresnel lens, and scanning the horizon for any sign of a vessel in distress. It was a life of responsibility, of quiet dedication to a purpose larger than himself. The lighthouse was more than just a structure of stone and light; it was a symbol of hope, a beacon of resilience against the raw, untamed power of nature, and a testament to the enduring human spirit that sought to illuminate the darkness and bring wanderers safely home, a silent guardian watching over the restless sea." },
        { title: "A Rainy Evening", content: "A gentle rain began to fall as evening descended, a soft, persistent patter against the windowpanes. Inside, the warmth of the hearth cast a flickering, amber glow across the room, a stark contrast to the cool, damp air outside. She sat curled in an old armchair, a half-read book resting in her lap, a pensive expression on her face. The rain was a soothing melody, a lullaby that seemed to wash away the day's accumulated anxieties and quiet the relentless chatter of the mind. It was on nights like these, cocooned in the quiet solitude of her home, that her thoughts roamed free, unburdened by the demands of the world. She pondered the intricate tapestry of human connection, the fragile threads that bound one soul to another, the unexpected joys and inevitable sorrows that colored the human experience. The rhythmic drumming of the rain provided a comforting backdrop to her reflections, a reminder of nature's constant, gentle presence, and the quiet beauty to be found in a simple, rainy evening spent in peaceful contemplation." },
        { title: "The Desert's Beauty", content: "The desert stretched out before him, an endless expanse of undulating dunes under a sky so vast it seemed to swallow the horizon. The sun beat down relentlessly, and the air shimmered with an almost palpable heat. Yet, amidst this harsh and unforgiving landscape, there was a stark, austere beauty that captivated the soul. The way the wind sculpted the sand into ever-changing, sinuous patterns, the resilience of the sparse, thorny vegetation clinging stubbornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding." },
    ],
    jsLong: [
        { title: "API 데이터 가져오기", content: `// Example 1: Fetching and displaying data from an API\nasync function displayUsers() {\n  const userList = document.getElementById('user-list');\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    const users = await response.json();\n    userList.innerHTML = ''; // Clear previous list\n    users.forEach(user => {\n      const li = document.createElement('li');\n      li.textContent = \`\${user.name} (@\${user.username}) - \${user.email}\`;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    userList.innerHTML = '<li>Error loading users.</li>';\n    console.error('Fetching users failed:', error);\n  }\n}` },
        { title: "카운트다운 타이머", content: `// Example 2: Simple class for a countdown timer\nclass CountdownTimer {\n  constructor(duration, displayElement) {\n    this.duration = duration; // in seconds\n    this.display = displayElement;\n    this.timerId = null;\n  }\n\n  start() {\n    let remaining = this.duration;\n    const tick = () => {\n      const minutes = String(Math.floor(remaining / 60)).padStart(2, '0');\n      const seconds = String(remaining % 60).padStart(2, '0');\n      this.display.textContent = \`\${minutes}:\${seconds}\`;\n      if (--remaining < 0) { this.stop(); }\n    };\n    this.stop(); // Clear any existing timer\n    this.timerId = setInterval(tick, 1000);\n  }\n\n  stop() {\n    clearInterval(this.timerId);\n    this.display.textContent = 'Time is up!';\n  }\n}` },
        { title: "배열 필터링 및 매핑", content: `// Example 3: Filtering and mapping an array of objects\nconst products = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200, inStock: true },\n  { id: 2, name: 'T-Shirt', category: 'Apparel', price: 25, inStock: true },\n  { id: 3, name: 'Coffee Maker', category: 'Appliances', price: 80, inStock: false },\n  { id: 4, name: 'Smartphone', category: 'Electronics', price: 800, inStock: true }\n];\n\nconst availableElectronics = products\n  .filter(p => p.category === 'Electronics' && p.inStock)\n  .map(p => {\n    const priceWithTax = p.price * 1.10;\n    return { ...p, priceWithTax: priceWithTax.toFixed(2) };\n  });\n\nconsole.log(availableElectronics);` },
        { title: "Pub/Sub 패턴", content: `// Example 4: Implementing a simple Pub/Sub (Event Emitter) pattern\nconst eventBus = {\n  events: {},\n  subscribe(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    const index = this.events[event].push(listener) - 1;\n    return {\n      unsubscribe: () => {\n        this.events[event].splice(index, 1);\n      }\n    };\n  },\n  publish(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n};\n\nconst subscription = eventBus.subscribe('userLogin', (user) => console.log(\`\${user} logged in.\`));\neventBus.publish('userLogin', 'Alice');\nsubscription.unsubscribe();` },
        { title: "Debounce 함수", content: `// Example 5: Debounce function for performance optimization\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(context, args);\n    }, delay);\n  };\n}\n\nconst handleSearchInput = (query) => {\n  console.log(\`Searching for: \${query}\`);\n  // API call would go here\n};\n\nconst searchInput = document.getElementById('search');\nif (searchInput) {\n    searchInput.addEventListener('keyup', debounce((e) => handleSearchInput(e.target.value), 300));\n}` },
        { title: "모듈 패턴", content: `// Example 6: Module revealing pattern\nconst dataModule = (function() {\n  let privateData = []; // This is private\n\n  function add(item) {\n    privateData.push(item);\n    console.log('Item added.');\n  }\n\n  function get(index) {\n    return privateData[index];\n  }\n\n  // Publicly expose methods\n  return {\n    addItem: add,\n    getItem: get\n  };\n})();\n\ndataModule.addItem('First item');\nconsole.log(dataModule.getItem(0));` }
    ],
    python: [
        `name = "key_therapy"`,
        `score: int = 100`,
        `is_active: bool = True`,
        `user_profile = None`,
        `my_list = [1, 'a', 3.14]`,
        `my_tuple = (1, 'a', 3.14)`,
        `my_dict = {'key': 'value'}`,
        `my_set = {1, 2, 3, 3, 2}`,
        `from decimal import Decimal`,
        `price = Decimal('10.99')`,
        `print(f"Hello, {name}!")`,
        `length = len(my_list)`,
        `user_input = input('Enter your name: ')`,
        `num = int('123')`,
        `is_instance = isinstance(num, int)`,
        `sorted_list = sorted(my_list, reverse=True)`,
        `for i, v in enumerate(my_list):`,
        `zipped = zip(list1, list2)`,
        `abs_value = abs(-10)`,
        `all_true = all([True, True, False])`,
        `if is_active and score > 50:`,
        `if x in my_list:`,
        `elif choice == 'b':`,
        `else:`,
        `for item in my_list:`,
        `for i in range(1, 10, 2):`,
        `while count < 10:`,
        `while True: break`,
        `try: result = 10 / 0`,
        `except ZeroDivisionError as e:`,
        `def greet(name: str) -> str:`,
        `def power(base, exp=2):`,
        `def register(*args, **kwargs):`,
        `global_var = 10`,
        `def my_func(): global global_var`,
        `my_lambda = lambda x, y: x + y`,
        `def my_generator(): yield 1`,
        `return f"Welcome, {name}!"`,
        `from functools import reduce, lru_cache`,
        `product = reduce((lambda x, y: x * y), [1, 2, 3])`,
        `import os`,
        `with open('file.txt', 'w', encoding='utf-8') as f:`,
        "f.write('Hello, world!\\n')",
        `lines = f.readlines()`,
        `current_dir = os.getcwd()`,
        `file_exists = os.path.exists('file.txt')`,
        `import json`,
        `data = json.load(f)`,
        `json.dump(my_dict, f, indent=4)`,
        `import csv`,
        `squares = [x**2 for x in range(10)]`,
        `even_squares = [x**2 for x in range(10) if x % 2 == 0]`,
        `my_dict_comp = {i: i*i for i in range(5)}`,
        `my_set_comp = {s.lower() for s in list_of_strings}`,
        `matrix = [[0 for _ in range(5)] for _ in range(5)]`,
        `flat_list = [item for sublist in matrix for item in sublist]`,
        `names = ['Bruce', 'Clark', 'Peter']`,
        `lengths = {name: len(name) for name in names}`,
        `inverted_dict = {v: k for k, v in my_dict.items()}`,
        `unique_letters = {letter for word in text for letter in word}`,
        `class MyClass:`,
        `    def __init__(self, name):`,
        `        self.name = name`,
        `    def method(self):`,
        `class Child(MyClass):`,
        `    def __init__(self, name, age):`,
        `        super().__init__(name)`,
        `        self.age = age`,
        `instance = MyClass('test')`,
        `@staticmethod`,
        `@classmethod`,
        `from datetime import datetime, timedelta`,
        `now = datetime.now()`,
        `import math`,
        `pi_val = math.pi`,
        `import random`,
        `rand_int = random.randint(1, 100)`,
        `import re`,
        "pattern = re.compile(r'\\d+')",
        `from collections import Counter, deque, defaultdict`,
        `from pathlib import Path`,
        `import numpy as np`,
        `arr = np.array([1, 2, 3])`,
        `import pandas as pd`,
        `df = pd.DataFrame(data)`,
        `import requests`,
        `response = requests.get('https://api.example.com')`,
        `from bs4 import BeautifulSoup`,
        `soup = BeautifulSoup(html_doc, 'html.parser')`,
        `import matplotlib.pyplot as plt`,
        `plt.plot(x, y)`,
        `# This is a single-line comment.`,
        `"""This is a docstring."""`,
        `# TODO: Implement error handling.`,
        `# FIXME: This causes a bug under certain conditions.`,
        `if __name__ == "__main__":`,
        `from typing import List, Dict, Tuple, Optional, Union`,
        `app.config['SECRET_KEY'] = os.urandom(24)`,
        `db.session.add(new_user)`,
        `db.session.commit()`,
        `logging.basicConfig(level=logging.INFO)`,
        `assert sum([1, 2, 3]) == 6, "Should be 6"`,
        `d = {k: v for k, v in data.items()}`,
        `for index, row in df.iterrows():`,
        `yield from generator_function()`,
        `raise ValueError('Invalid argument provided')`,
        `# End of Python short examples.`
    ],
    pythonLong: [
        { title: "웹 스크래핑 예제", content: `# Example 1: Web scraping with requests and BeautifulSoup\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_website_title(url: str) -> str:\n    """Scrapes the title of a given URL."""\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        soup = BeautifulSoup(response.text, 'html.parser')\n        title = soup.find('h1')\n        return title.string.strip() if title else 'No H1 title found.'\n    except requests.exceptions.RequestException as e:\n        print(f"An error occurred: {e}")\n        return "Error: Could not retrieve title."` },
        { title: "CLI 인자 파서", content: `# Example 2: A simple command-line argument parser using argparse\nimport argparse\n\ndef process_file(input_path, output_path, is_verbose):\n    if is_verbose:\n        print(f"Reading from {input_path} and writing to {output_path}.")\n    with open(input_path, 'r') as infile, open(output_path, 'w') as outfile:\n        for line in infile:\n            outfile.write(line.upper()) # Example processing: convert to uppercase\n\ndef main():\n    parser = argparse.ArgumentParser(description="A simple file processing CLI.")\n    parser.add_argument('-i', '--input', required=True, help='Input file path')\n    parser.add_argument('-o', '--output', default='output.txt', help='Output file path')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')\n    args = parser.parse_args()\n    process_file(args.input, args.output, args.verbose)\n\nif __name__ == '__main__':\n    main()` },
        { title: "To-Do 리스트 클래스", content: `# Example 3: Class for managing a simple To-Do list with file persistence\nimport json\n\nclass TodoList:\n    def __init__(self, filename='todolist.json'):\n        self.filename = filename\n        self.tasks = self._load_tasks()\n\n    def _load_tasks(self):\n        try:\n            with open(self.filename, 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return []\n\n    def _save_tasks(self):\n        with open(self.filename, 'w') as f:\n            json.dump(self.tasks, f, indent=4)\n\n    def add_task(self, task: str):\n        self.tasks.append({'task': task, 'done': False})\n        self._save_tasks()` },
        { title: "Pandas 데이터 분석", content: `# Example 4: Data analysis with pandas for more complex data\nimport pandas as pd\n\ndef analyze_sales_data(file_path: str):\n    """Reads sales data and calculates per-category metrics."""\n    try:\n        df = pd.read_csv(file_path)\n        df['Revenue'] = df['Quantity'] * df['Price']\n        category_revenue = df.groupby('Category')['Revenue'].sum().sort_values(ascending=False)\n        print("--- Revenue by Category ---")\n        print(category_revenue)\n\n        avg_price = df.groupby('Category')['Price'].mean()\n        print("\\n--- Average Price by Category ---")\n        print(avg_price)\n    except (FileNotFoundError, KeyError) as e:\n        print(f"An error occurred during analysis: {e}")` },
        { title: "데코레이터 예제", content: `# Example 5: Creating a decorator with arguments\nfrom functools import wraps\n\ndef repeat(num_times):\n    """A decorator that repeats the execution of a function."""\n    def decorator_repeat(func):\n        @wraps(func)\n        def wrapper_repeat(*args, **kwargs):\n            last_value = None\n            for _ in range(num_times):\n                last_value = func(*args, **kwargs)\n            return last_value\n        return wrapper_repeat\n    return decorator_repeat\n\n@repeat(num_times=3)\ndef say_whee():\n    print("Whee!")\n\nsay_whee()` },
        { title: "SQLite 데이터베이스", content: `# Example 6: Working with a simple SQLite database\nimport sqlite3\n\ndef setup_database(db_name: str):\n    # Connect to the database (or create it)\n    conn = sqlite3.connect(db_name)\n    cursor = conn.cursor()\n\n    # Create a table\n    cursor.execute('''\n    CREATE TABLE IF NOT EXISTS users\n    (id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT NOT NULL UNIQUE)\n    ''')\n\n    # Insert a row of data\n    try:\n        cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('John Doe', 'john.doe@email.com'))\n    except sqlite3.IntegrityError:\n        print("User already exists.")\n    \n    # Save (commit) the changes and close\n    conn.commit()\n    conn.close()` }
    ]
};
function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}
function initializeAudioPoolForPack(packKey) {
    if (!soundFiles[packKey] || soundFiles[packKey].length === 0) return;
    audioPool[packKey] = [];
    soundFiles[packKey].forEach(soundSrc => {
        const audio = new Audio(soundSrc);
        audio.preload = 'auto';
        audioPool[packKey].push(audio);
    });
}
function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}
function playTypingSound() {
    clearTimeout(soundTimer);
    soundTimer = setTimeout(() => {
        if (!soundEnabled || !currentSoundPack) return;
        const masterAudioPool = audioPool[currentSoundPack];
        if (!masterAudioPool || masterAudioPool.length === 0) {
            initializeAudioPoolForPack(currentSoundPack);
            return;
        }
        const masterAudio = getRandom(masterAudioPool);
        if (!masterAudio) return;
        const audioToPlay = masterAudio.cloneNode();
        audioToPlay.play().catch(e => {});
    }, 1);
}
function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('no-transition');
  languageSelectEl = document.getElementById('languageSelect');
  languageSelectLabelEl = document.getElementById('languageSelectLabel');
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  toggleLayoutBtn = document.getElementById('toggleLayoutBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');
  helpModal = document.getElementById('helpModal');
  helpModalBody = document.getElementById('helpModalBody');
  helpModalClose = document.querySelector('.help-modal-close');
  freestyleAreaContainerEl = document.getElementById('freestyle-area-container');
  freestyleInputAreaEl = document.getElementById('freestyle-input-area');
  downloadFreestyleBtnEl = document.getElementById('download-freestyle-btn');
  freestyleFilenameInputEl = document.getElementById('freestyle-filename-input');
  freestyleToolbarEl = document.getElementById('freestyle-toolbar');
  insertDateBtn = document.getElementById('insertDateBtn');
  insertTimeBtn = document.getElementById('insertTimeBtn');
  emojiBtn = document.getElementById('emojiBtn');
  emojiPicker = document.getElementById('emoji-picker');
  copyAllBtn = document.getElementById('copyAllBtn');
  clearAllBtn = document.getElementById('clearAllBtn');
  insertHrBtn = document.getElementById('insertHrBtn');
  focusModeBtn = document.getElementById('focusModeBtn');
  charCountEl = document.getElementById('charCount');
  wordCountEl = document.getElementById('wordCount');
  longTextSelectContainerEl = document.getElementById('longTextSelectContainer');
  longTextSelectEl = document.getElementById('longTextSelect');
  practiceTitleDisplayEl = document.getElementById('practice-title-display');
  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');
  const allElements = [languageSelectEl, lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, toggleLayoutBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl, freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl, freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker, copyAllBtn, clearAllBtn, insertHrBtn, focusModeBtn, charCountEl, wordCountEl, helpModal, helpModalBody, helpModalClose, longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl];
  if (!allElements.every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다. 누락된 요소를 확인해주세요.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }
  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;
  soundPackSelectEl.innerHTML = '';
  for (let i = 1; i <= totalSoundPacks; i++) {
    const option = document.createElement('option');
    option.value = String(i);
    option.textContent = String(i);
    soundPackSelectEl.appendChild(option);
  }
  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;
  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';
  initializeAudioPool();
  buildKeyboard();
  if (toggleLayoutBtn) {
    toggleLayoutBtn.addEventListener('click', () => {
        layoutCollapsed = !layoutCollapsed;
        updateLayout();
        localStorage.setItem('layoutCollapsed', layoutCollapsed);
    });
  }
  document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(button => {
    button.addEventListener('click', function() {
      const type = this.dataset.practiceType;
      if (type === 'freestyle') {
          startFreestyleMode();
          return;
      }
      const lang = languageSelectEl.value;
      const isLong = (type === 'long');
      const mode = isLong ? `${lang}Long` : lang;
      startPractice(mode, true);
    });
  });
  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => activateGameMode('rainfall'));
  }
  if (gameAreaContainerEl) {
    gameAreaContainerEl.addEventListener('click', function(e) {
      if (e.target.closest('#gameHelpBtn')) {
        if (currentGameType) {
          showHelpModal(currentGameType);
        }
      }
    });
  }
  const restartPractice = () => {
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (!activePracticeBtn || currentMode === 'freestyle') return;
    const type = activePracticeBtn.dataset.practiceType;
    const lang = languageSelectEl.value;
    const isLong = (type === 'long');
    const mode = isLong ? `${lang}Long` : lang;
    startPractice(mode, true);
  };
  languageSelectEl.addEventListener('change', restartPractice);
  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }
  typingInputField.addEventListener('input', (e) => {
    soundPlayedForThisInput = false;
    handleInputEvent(e);
  });
  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }
  document.body.addEventListener('click', function(e) {
    if (emojiPicker.classList.contains('visible') && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
        emojiPicker.classList.remove('visible');
    }
    if (helpModal.classList.contains('visible') && !e.target.closest('.help-modal-content')) {
        hideHelpModal();
    }
    const isInteractiveElement = e.target.closest('button, a, select, input, textarea, #emoji-picker span, .help-modal-content');
    if (!isInteractiveElement) {
      if (document.body.classList.contains('game-mode-active')) {
        if (gameInputField && !gameInputField.disabled) gameInputField.focus();
      } else if (document.body.classList.contains('freestyle-mode-active')) {
        if (freestyleInputAreaEl) freestyleInputAreaEl.focus();
      } else {
        if (typingInputField && !typingInputField.disabled) typingInputField.focus();
      }
    }
  });
  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });
  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl && linesToPractice[currentDisplayLineIndex] !== undefined) {
        handleHighlightUpdate(currentLineEl, typingInputField.value, linesToPractice[currentDisplayLineIndex]);
    }
  });
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    initializeAudioPoolForPack(currentSoundPack);
  });
  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });
  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });
  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> 자리연습 ON' : '<i class="far fa-keyboard"></i> 자리연습 OFF';
    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }
    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });
  helpModalClose.addEventListener('click', hideHelpModal);
  freestyleInputAreaEl.addEventListener('input', () => {
    soundPlayedForThisInput = false; 
    playTypingSound();
    if (!startTime) {
        startTime = Date.now();
    }
    updateFreestyleStats();
  });
  freestyleInputAreaEl.addEventListener('keydown', (e) => {
    soundPlayedForThisInput = false;
    if (e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
        playTypingSound();
    }
  });
  downloadFreestyleBtnEl.addEventListener('click', handleFreestyleDownload);
  insertDateBtn.addEventListener('click', insertDate);
  insertTimeBtn.addEventListener('click', insertTime);
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('visible');
  });
  emojiPicker.querySelectorAll('span').forEach(emoji => {
    emoji.addEventListener('click', () => {
        insertAtCursor(freestyleInputAreaEl, emoji.textContent);
        emojiPicker.classList.remove('visible');
        freestyleInputAreaEl.focus();
    });
  });
  copyAllBtn.addEventListener('click', copyAllFreestyleText);
  clearAllBtn.addEventListener('click', clearAllFreestyleText);
  insertHrBtn.addEventListener('click', () => insertAtCursor(freestyleInputAreaEl, '\n\n---\n\n'));
  focusModeBtn.addEventListener('click', toggleFocusMode);
  longTextSelectEl.addEventListener('change', () => {
      const lang = languageSelectEl.value;
      const mode = lang + 'Long';
      startPractice(mode, false);
  });
  document.addEventListener('keydown', (e) => {
    const activeElTag = document.activeElement.tagName.toLowerCase();
    
    const isOverlayVisible = gameOverlayEl && gameOverlayEl.classList.contains('visible');
    const isStartMsgVisible = gameStartMessageEl && gameStartMessageEl.style.display !== 'none';

    if ((isOverlayVisible || isStartMsgVisible) && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        const nextBtn = document.getElementById('nextStepBtnOverlay');
        const startBtn = document.getElementById('startGameBtn');
        if (isOverlayVisible && nextBtn) nextBtn.click();
        else if (isStartMsgVisible && startBtn) startBtn.click();
        return;
    }

    if (activeElTag === 'input' || activeElTag === 'textarea') {
      if (e.altKey) {
        if (document.activeElement.id === 'freestyle-filename-input') return;
      } else {
        return;
      }
    }

    if (e.key === 'Escape') {
      if (document.body.classList.contains('focus-mode-active')) {
          toggleFocusMode();
      }
      if (helpModal.classList.contains('visible')) {
          hideHelpModal();
      }
    }

    if (e.altKey) {
        e.preventDefault();

        switch (e.key) {
            case 'ArrowDown':
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) {
                        handleGameEnd(false, 'level_change');
                    }
                } else if (currentMode !== 'freestyle') {
                    restartCurrentPractice();
                }
                break;
            
            case 'ArrowRight': // 오른쪽 화살표
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) changeGameLevel(1);
                } else if (currentMode.endsWith('Long')) { // 장문 모드일 때
                    changeLongText(1);
                } else if (currentMode !== 'freestyle') { // 단문 모드일 때
                    startPractice(currentMode, false);
                }
                break;

            case 'ArrowLeft': // 왼쪽 화살표
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) changeGameLevel(-1);
                } else if (currentMode.endsWith('Long')) { // 장문 모드일 때
                    changeLongText(-1);
                } else if (currentMode !== 'freestyle') { // 단문 모드일 때
                    startPractice(currentMode, false);
                }
                break;
        }
    }
  });

  const savedLayoutState = localStorage.getItem('layoutCollapsed') === 'true';
  if (savedLayoutState) {
      layoutCollapsed = true;
      updateLayout();
  }
  startPractice('kor', true);
  setTimeout(() => {
    document.body.classList.remove('no-transition');
  }, 100);
});
function cleanupActiveModes() {
    document.body.classList.remove('game-mode-active', 'freestyle-mode-active', 'focus-mode-active');
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    freestyleStatsInterval = null;
    startTime = null;
    if(typingInputField) typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    if(gameInputField) gameInputField.removeEventListener('keydown', handleKeyDownEvent);
    enablePracticeControls();
}
function disableFreestyleControls() {
    toggleHighlightBtn.classList.add('disabled');
    toggleKeyboardGuideBtn.classList.add('disabled');
    languageSelectEl.closest('.language-settings').classList.add('disabled');
}
function enablePracticeControls() {
    toggleHighlightBtn.classList.remove('disabled');
    toggleKeyboardGuideBtn.classList.remove('disabled');
    languageSelectEl.closest('.language-settings').classList.remove('disabled');
}
function populateLongTextDropdown(lang) {
    const source = sentencePool[lang + 'Long'];
    if (!longTextSelectEl || !source) return;

    longTextSelectEl.innerHTML = '';

    const randomOption = document.createElement('option');
    randomOption.value = "-1";
    randomOption.textContent = "랜덤";
    longTextSelectEl.appendChild(randomOption);

    source.forEach((item, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = item.title;
        longTextSelectEl.appendChild(option);
    });
}
function startPractice(mode, resetSessionStats = false) {
    cleanupActiveModes();
    currentMode = mode;
    currentGameType = '';

    const isLongMode = mode.endsWith('Long');
    const lang = mode.replace('Long', '');

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        const type = btn.dataset.practiceType;
        btn.classList.toggle('active', (isLongMode && type === 'long') || (!isLongMode && type === 'short'));
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    if (longTextSelectContainerEl) {
        longTextSelectContainerEl.classList.toggle('hidden', !isLongMode);
    }
    
    if(resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';
    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }
    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }
    currentLineStartTime = null;
    currentArticleCorrectChars = 0;
    currentDisplayLineIndex = 0;
    
    const source = sentencePool[mode];
    let textToPractice = "";
    let titleToDisplay = "";

    if (!source || source.length === 0) {
        linesToPractice = ["선택한 언어 또는 모드에 대한 예문이 없습니다."];
    } else {
        if (isLongMode) {
            // [수정된 부분] 세션이 리셋될 때만 드롭다운을 새로 채웁니다.
            if (resetSessionStats) {
                populateLongTextDropdown(lang);
            }
            
            let selectedIndex = parseInt(longTextSelectEl.value, 10);
            
            // 세션 리셋(언어변경 등) 시 또는 '랜덤' 선택 시 랜덤 로직 실행
            if (resetSessionStats || selectedIndex === -1 || isNaN(selectedIndex)) {
                const randomIndex = Math.floor(Math.random() * source.length);
                textToPractice = source[randomIndex].content;
                titleToDisplay = source[randomIndex].title;
                longTextSelectEl.value = randomIndex;
            } else { // 특정 글을 선택한 경우
                textToPractice = source[selectedIndex].content;
                titleToDisplay = source[selectedIndex].title;
            }
        } else { // 단문 연습일 경우
            textToPractice = getRandom(source);
        }
        linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    }

    if (practiceTitleDisplayEl) {
        practiceTitleDisplayEl.textContent = titleToDisplay;
    }
    
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    
    if (progressBarContainerEl) {
        progressBarContainerEl.style.display = isLongMode && linesToPractice.length > 1 ? 'block' : 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();
    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}
function startFreestyleMode() {
    cleanupActiveModes();
    document.body.classList.add('freestyle-mode-active');
    currentMode = 'freestyle';
    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === 'freestyle');
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');
    disableFreestyleControls();
    if (statsVisible) {
        statsVisible = false;
        toggleStatsBtn.classList.remove('active');
        toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
        statsEl.classList.add('hidden');
    }
    if (toggleHighlightBtn.classList.contains('active')) toggleHighlightBtn.classList.remove('active');
    if (toggleKeyboardGuideBtn.classList.contains('active')) toggleKeyboardGuideBtn.classList.remove('active');
    highlightEnabled = false;
    keyboardGuideEnabled = false;
    if (keyboardGuideEl) keyboardGuideEl.classList.remove('visible');
    if (resultEl) resultEl.textContent = '자유롭게 글을 작성하고 타건을 즐겨보세요.';
    startTime = null;
    overallMaxSpeed = 0;
    overallAvgSpeedLog = [];
    sessionTotalValidChars = 0;
    sessionTotalCorrectChars = 0;
    sessionTotalMistypedChars = 0;
    lastArticleSpeed = 0;
    updateStatsDisplay(true);
    if (document.getElementById('accuracyStat')) document.getElementById('accuracyStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('avgSpeedStat')) document.getElementById('avgSpeedStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('maxSpeedStat')) document.getElementById('maxSpeedStat').innerHTML = '<span class="value">—</span>';
    freestyleInputAreaEl.value = '';
    freestyleInputAreaEl.focus();
    updateFreestyleStats();
    if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    freestyleStatsInterval = setInterval(updateFreestyleStats, 500);
}
function updateFreestyleStats() {
    if (currentMode !== 'freestyle') {
        if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
        return;
    };
    const text = freestyleInputAreaEl.value;
    const charLength = text.length;
    const wordLength = text.trim().split(/\s+/).filter(Boolean).length;
    charCountEl.textContent = `${charLength}자`;
    wordCountEl.textContent = `${wordLength}단어`;
    if (startTime) {
        const elapsedMinutes = (Date.now() - startTime) / 60000;
        if (elapsedMinutes > 0) {
            const speed = Math.round((charLength / elapsedMinutes) * KOR_SPEED_FACTOR);
            if (statsVisible && document.getElementById('speedStat')) {
                document.getElementById('speedStat').textContent = `${speed} 타/분`;
            }
        }
    }
}
function handleFreestyleDownload() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        alert('저장할 내용이 없습니다.');
        return;
    }
    let filename = freestyleFilenameInputEl.value.trim();
    if (filename === '') {
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        filename = `keytherapy_${timestamp}`;
    }
    if (!filename.toLowerCase().endsWith('.txt')) {
        filename += '.txt';
    }
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function insertAtCursor(myField, myValue) {
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length;
        myField.selectionEnd = startPos + myValue.length;
    } else {
        myField.value += myValue;
    }
    updateFreestyleStats();
    myField.focus();
}
function copyAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        showSharePopup("복사할 내용이 없습니다.");
        return;
    }
    navigator.clipboard.writeText(text).then(() => {
        showSharePopup("클립보드에 복사되었습니다.");
    }).catch(err => {
        console.error('클립보드 복사 실패:', err);
        showSharePopup("복사에 실패했습니다.");
    });
    freestyleInputAreaEl.focus();
}
function clearAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') return;
    if (confirm("정말 모든 내용을 삭제하시겠습니까?")) {
        freestyleInputAreaEl.value = '';
        updateFreestyleStats();
        freestyleInputAreaEl.focus();
    }
}
function insertDate() {
    const now = new Date();
    const dateString = `${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일`;
    insertAtCursor(freestyleInputAreaEl, dateString + " ");
}
function insertTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const formattedHours = (hours % 12) || 12;
    const timeString = `${ampm} ${formattedHours}:${minutes}`;
    insertAtCursor(freestyleInputAreaEl, timeString + " ");
}
function toggleFocusMode() {
    document.body.classList.toggle('focus-mode-active');
    const icon = focusModeBtn.querySelector('i');
    if (document.body.classList.contains('focus-mode-active')) {
        icon.classList.remove('fa-expand');
        icon.classList.add('fa-compress');
    } else {
        icon.classList.remove('fa-compress');
        icon.classList.add('fa-expand');
    }
    freestyleInputAreaEl.focus();
}
function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function splitTextIntoLines(text, mode, screenWidth) {
    if (mode.startsWith('js') || mode.startsWith('python')) {
        return text.split('\n');
    }
    let maxLength;
    if (mode.endsWith('Long')) {
        if (screenWidth <= 480) maxLength = mode.startsWith('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.startsWith('eng') ? 55 : 35;
        else maxLength = mode.startsWith('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }
    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.endsWith('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}
function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';
    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();
    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.innerHTML = formatCodeLineForDisplay(passedLineText);
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);
    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');
    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        handleHighlightUpdate(currentEl, "", currentLineText);
    } else {
        currentEl.textContent = ' ';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);
    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        const upcomingEl = document.createElement('div');
        upcomingEl.classList.add('typing-line', 'upcoming');
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            upcomingEl.innerHTML = formatCodeLineForDisplay(upcomingLineText);
        } else {
            upcomingEl.textContent = ' ';
            upcomingEl.style.visibility = 'hidden';
        }
        fragmentUpcoming.appendChild(upcomingEl);
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
}
function handleInputEvent(e) {
    playTypingSound();
    if (currentMode !== 'game' && currentMode !== 'freestyle' && e.target === typingInputField) {
        const typedValue = typingInputField.value;
        const currentLineEl = document.getElementById('current-typing-line');
        if (!currentLineEl) return;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";
        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }
        handleHighlightUpdate(currentLineEl, typedValue, originalLine);
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight();
    }
}
function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;
    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">타자 연습 시작...</span><span id="cursor"></span>`;
        return;
    }
    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span id="cursor"></span>`;
    } else {
        fakeInputField.innerHTML = `${typedValue}<span id="cursor"></span>`;
    }
}
function handleHighlightUpdate(targetElement, typedValue, originalLine) {
    if (!targetElement || typeof originalLine !== 'string') {
        if(targetElement) targetElement.textContent = ' ';
        return;
    }
    let builtHTML = "";
    let originalIdx = 0;
    let typedIdx = 0;
    while (originalIdx < originalLine.length) {
        const originalChar = originalLine[originalIdx];
        const displayChar = originalChar;
        if (typedIdx < typedValue.length) {
            const typedChar = typedValue[typedIdx];
            if (originalChar === typedChar) {
                builtHTML += `<strong>${displayChar}</strong>`;
                originalIdx++;
                typedIdx++;
            } else {
                let lookahead = false;
                if (originalIdx + 1 < originalLine.length && typedChar === originalLine[originalIdx + 1]) {
                    builtHTML += `<span class="highlight">${displayChar}</span>`;
                    originalIdx++;
                    lookahead = true;
                } 
                else if (typedIdx + 1 < typedValue.length && typedValue[typedIdx + 1] === originalChar) {
                    builtHTML += `<span class="highlight">${typedChar}</span>`;
                    typedIdx++;
                    lookahead = true;
                }
                if (!lookahead) {
                    builtHTML += `<span class="highlight">${displayChar}</span>`;
                    originalIdx++;
                    typedIdx++;
                }
            }
        } else {
            builtHTML += `<span class="untyped-char">${displayChar}</span>`;
            originalIdx++;
        }
    }
    targetElement.innerHTML = builtHTML || ' ';
}
function formatCodeLineForDisplay(line) {
    if (!line) return '';
    const isCodeMode = currentMode.startsWith('js') || currentMode.startsWith('python');
    if (isCodeMode) {
        const match = line.match(/^( +)/);
        if (match) {
            const spaces = match[1];
            const restOfLine = line.substring(spaces.length);
            const visibleSpaces = `<span class="whitespace-char">${'·'.repeat(spaces.length)}</span>`;
            const escapedRest = restOfLine.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return visibleSpaces + escapedRest;
        }
    }
    return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function handleKeyDownEvent(e) {
    if (e.isComposing) return;
    playTypingSound();
    const targetInput = e.target;
    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }
   if (currentMode !== 'game' && currentMode !== 'freestyle' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;
        if (e.key === 'Enter') {
            e.preventDefault();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            processCurrentLineCompletion();
        }
    }
}
function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }
    let lineCorrectCharsThisLine = 0;
    let lineMistypedCharsOnThisLine = 0;
    for (let i = 0; i < originalLine.length; i++) {
        if (i < typedValue.length) {
            if (typedValue[i] === originalLine[i]) {
                lineCorrectCharsThisLine++;
            } else {
                lineMistypedCharsOnThisLine++;
            }
        } else {
            lineMistypedCharsOnThisLine++;
        }
    }
    if (typedValue.length > originalLine.length) {
        lineMistypedCharsOnThisLine += (typedValue.length - originalLine.length);
    }
    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;
    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * speedFactor);
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * speedFactor);
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }
    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;
    if (!currentMode.endsWith('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
        }
    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.endsWith('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if (currentMode.endsWith('Long')) {
            const finalAccuracy = sessionTotalValidChars > 0 ? Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100) : 0;
            const avgSpeed = overallAvgSpeedLog.length > 0 ? Math.round(overallAvgSpeedLog.reduce((a, b) => a + b, 0) / overallAvgSpeedLog.length) : 0;
            
            showResultOverlay({
                type: 'practice',
                title: '연습 완료!',
                stats: {
                    "평균 속도": `${avgSpeed} 타/분`,
                    "최고 속도": `${overallMaxSpeed} 타/분`,
                    "정확도": `${finalAccuracy}%`
                },
                nextAction: () => startPractice(currentMode, false),
                nextActionText: "다시하기 (Enter)"
            });
            currentArticleCorrectChars = 0;
            startTime = null;
        } else {
            if(resultEl) resultEl.textContent = '연습 완료! 새로운 문제 준비 중...';
            setTimeout(() => startPractice(currentMode, false), 200);
        }
    }
}
function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;
  let currentSpeedToShow = 0;
  if (isSessionReset) {
      currentSpeedToShow = 0;
  } else if (startTime === null && !currentMode.endsWith('Long')) {
      currentSpeedToShow = lastArticleSpeed;
  } else if (currentMode.endsWith('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * speedFactor);
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;
  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;
  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;
  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} 타/분`;
}
function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.endsWith('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}
function activateGameMode(gameType) {
    cleanupActiveModes();
    document.body.classList.add('game-mode-active');
    currentMode = 'game';
    currentGameType = gameType;
    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;
    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;
    gameStartMessageEl = gameAreaContainerEl.querySelector('#game-start-message');
    gameCanvas = gameAreaContainerEl.querySelector('#game-canvas');
    if (gameCanvas) {
        gameCtx = gameCanvas.getContext('2d');
    } else {
        console.error("activateGameMode: game-canvas 요소를 찾을 수 없습니다.");
        return;
    }
    gameInputField = gameAreaContainerEl.querySelector('#game-input-field');
    gameOverlayEl = gameAreaContainerEl.querySelector('#gameOverlay');
    itemEffectPopupEl = gameAreaContainerEl.querySelector('#item-effect-popup');
    lbbTimerBarContainerEl = gameAreaContainerEl.querySelector('#lbb-timer-bar-container');
    lbbTimerBarEl = gameAreaContainerEl.querySelector('#lbb-timer-bar');
    lbbTimerTextEl = gameAreaContainerEl.querySelector('#lbb-timer-text');
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }
    const gameTypeRow = gameAreaContainerEl.querySelector('#gameTypeSelectionRow');
    const settingsRow1 = gameAreaContainerEl.querySelector('#gameSettingsRow1');
    const settingsRow2 = gameAreaContainerEl.querySelector('#gameSettingsRow2');
    if (!gameTypeRow || !settingsRow1 || !settingsRow2) {
        console.error("게임 컨트롤 바 요소를 찾을 수 없습니다. HTML 구조를 확인하세요.");
        return;
    }
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => activateGameMode('rainfall'));
    gameTypeRow.appendChild(sonagiBtn);
    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => activateGameMode('letterBlockBattle'));
    gameTypeRow.appendChild(letterBlockBtn);
    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> 타이핑 배틀';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => activateGameMode('giantBattle'));
    gameTypeRow.appendChild(typingBattleBtn);
    settingsRow1.innerHTML = ''; 
    settingsRow2.innerHTML = '';
    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);
    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);
    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);
    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';
    let maxLevelForSelect;
    let currentLevelForSelect;
    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }
    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
     gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        let isCountingDown = !!countdownTimerId;

        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }

        if (isActive || isCountingDown) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);
    settingsRow2.appendChild(levelControlItem);
    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);
    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);
    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }

    const startGameButtonHTML = `<button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작 (Enter)</button>`;
    
    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 생명)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3초 멈춤)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (화면 정리)</div>
             </div>
             ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>상하좌우 블록의 단어를 입력하여 이동하고, 적과 빈 칸으로 연결되면 승리합니다!<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> 타이핑 배틀</h2>
            <p>쏟아지는 단어들을 정확히 입력하여 적의 공격을 막아내고,<br>당신의 공격 단어로 적을 격파하세요! 2분 안에 승리하세요!</p>
            <p>레벨을 선택하고 게임 시작 버튼을 누르세요.</p>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
    document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.classList.add('active');
    }
}
function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}
function showSharePopup(message) {
    const popup = document.getElementById('result-share-popup');
    popup.textContent = message;
    popup.style.opacity = '1';
    popup.style.transform = 'translateX(-50%) translateY(0)';
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(20px)';
    }, 2000);
}
// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);

    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}
function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }

        drawRainfallGame();

        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }

        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}
function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }

    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) {
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}
function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }

    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`점수: ${rainfall_gameScore}`, 15 + 40, 30);

    gameCtx.textAlign = 'center';
    gameCtx.fillText(`레벨: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);

    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`생명: ${'❤️'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;

        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;

        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}
function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    function generateWord() {
        if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;

        let newWordText;
        let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
        let itemDetails = null;

        if (isItem) {
            const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
            itemDetails = getRandom(itemTypes);
            newWordText = itemDetails.text;
        } else {
            const wordPool = gameWordsKor.filter(w => w.length <= 4);
            const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
            newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
            if (!newWordText) newWordText = '단어';
        }

        rainfall_usedWordsInLevel.add(newWordText);
        if (rainfall_usedWordsInLevel.size > 100) {
            const oldestWord = rainfall_usedWordsInLevel.values().next().value;
            rainfall_usedWordsInLevel.delete(oldestWord);
        }

        const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

        rainfall_wordsOnScreen.push({
            text: newWordText,
            x: Math.random() * (gameCanvas.width - 100) + 50,
            y: -20,
            speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
            isFast: isFast,
            itemType: isItem ? itemDetails.type : null,
            color: isItem ? itemDetails.color : null,
            duration: isItem ? itemDetails.duration : 0
        });
    }

    generateWord();
    rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
}
function handleRainfallGameInputSubmit() {
    if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
    const typedWord = gameInputField.value.trim();
    if (typedWord === "") return;

    let wordFound = false;
    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        const wordToMatch = word.text;

        if (typedWord === wordToMatch) {
            if (word.itemType) {
                activateRainfallItemEffect(word.itemType, word.duration);
            } else {
                rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
            }

            rainfall_wordsOnScreen.splice(i, 1);
            wordFound = true;
            break;
        }
    }

    if (!wordFound) {
        if(gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    gameInputField.value = "";
}
function activateRainfallItemEffect(itemType, duration) {
    let popupText = "";
    const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
    if (!itemInfo) return;

    switch(itemType) {
        case 'extraLife':
            if (rainfall_gameLives < 10) rainfall_gameLives++;
            popupText = `생명 +1 ${itemInfo.icon}`;
            break;
        case 'timeStop':
            rainfall_isTimeStopped = true;
            popupText = `시간 정지! ${itemInfo.icon}`;
            if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
            window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
            break;
        case 'clearScreen':
            popupText = `화면 정리! ${itemInfo.icon}`;
            for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                if (!rainfall_wordsOnScreen[j].itemType) {
                    rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                    rainfall_wordsOnScreen.splice(j, 1);
                }
            }
            break;
    }
    if (popupText) showGamePopup(popupText, 1500);
}
function triggerRainfallLifeLostEffect() {
    if (gameCanvas) {
        gameCanvas.classList.add('flash-effect');
        setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
    }
}
// --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
    if(level) lbb_gameLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    lbb_playerNoPlayableBlocksTimerId = null;
    if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    lbb_relocationCountdownIntervalId = null;

    lbb_isGameActive = true;
    lbb_gamePausedForOverlay = false;
    lbb_gamePausedForEffect = false;
    lbb_isRelocating = false;

    lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];

    lbb_playerScore = 0;
    lbb_enemyScore = 0;

    generateLBBGameBoard();
    lbb_playerPos = { r: 0, c: 0 };
    lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
    lbb_enemyOriginalStartPos = { ...lbb_enemyPos };

    if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
        lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
    }
    if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
        lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
    }

    if (gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    lbb_gameStartTime = Date.now();
    lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
    startLBBGameLoop();
}

function startLBBGameLoop() {
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    function loop() {
        if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
            cancelAnimationFrame(lbb_gameLoopId);
            lbb_gameLoopId = null;
            return;
        }
        drawLetterBlockBattleGame();
        if(lbb_isGameActive && !lbb_gamePausedForOverlay){
            updateLBBGameLogic();
        }
        lbb_gameLoopId = requestAnimationFrame(loop);
    }
    lbb_gameLoopId = requestAnimationFrame(loop);
}

function updateLBBGameLogic() {
    if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

    if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
        return;
    }

    if (lbb_swapEffect.active) {
        updateLBBSwapAnimation();
    } else if (lbb_finalBattleAnimation.isActive) {
        updateLBBFinalBattleAnimation();
    } else {
        if (!lbb_isRelocating) {
             checkAndTriggerPlayerLBBRelocation();
        }
    }

    lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
    lbb_blockBreakParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.alpha -= 0.02;
    });
}

function drawLetterBlockBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
    const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
    const boardX = (gameCanvas.width - boardWidth) / 2;
    const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

    const bodyClasses = document.body.classList;
    let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
        inputBgColor = '#fefcf9';
        brokenColor = '#f9f5f0';
        playerBlockBg = '#fffacd';
        playerColor = '#4A90E2';
        enemyColor = '#D0021B';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
        inputBgColor = '#fffafa';
        brokenColor = '#fff5f8';
        playerBlockBg = '#ffe8f0';
        playerColor = '#E91E63';
        enemyColor = '#7B1FA2';
    } else {
        textColor = '#e8e0d8';
        inputBgColor = '#33302e';
        brokenColor = '#262422';
        playerBlockBg = 'rgba(212, 175, 122, 0.08)';
        playerColor = 'dodgerblue';
        enemyColor = 'tomato';
    }

    const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
            if (!block) continue;

            const x = boardX + c * LBB_BLOCK_SIZE;
            const y = boardY + r * LBB_BLOCK_SIZE;

            gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

            if (!block.broken) {
                const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                if (isPlayerAdjacent) {
                    gameCtx.fillStyle = playerBlockBg;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }

                gameCtx.font = lbb_blockTextFont;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillStyle = block.effect.color || textColor;
                gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                if (block.effect.icon) {
                    gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                    gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                }
            }
            gameCtx.strokeStyle = borderColor;
            gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
        }
    }

    lbb_blockBreakParticles.forEach(p => {
        gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
        gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
    });

    function drawCharacter(pos, color, isPlayer) {
        const x = boardX + pos.c * LBB_BLOCK_SIZE;
        const y = boardY + pos.r * LBB_BLOCK_SIZE;
        gameCtx.fillStyle = color;
        gameCtx.beginPath();
        gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
        gameCtx.fill();
        if (isPlayer) {
            gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.lineWidth = 1;
        }
    }

    if (lbb_swapEffect.active) {
        drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
        drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
    } else if (lbb_finalBattleAnimation.isActive) {
        drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
        drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
    } else {
        drawCharacter(lbb_playerPos, playerColor, true);
        drawCharacter(lbb_enemyPos, enemyColor, false);
    }

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.textAlign = 'left';
    gameCtx.fillStyle = playerColor;
    gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 15 + 40, 30);
    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = enemyColor;
    gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
    gameCtx.textAlign = 'center';
    gameCtx.fillStyle = textColor;
    gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);

    if (lbb_relocationCountdown > 0) {
        gameCtx.font = "bold 16px 'Poppins', sans-serif";
        gameCtx.fillStyle = 'orange';
        gameCtx.textAlign = 'center';
        gameCtx.fillText(`길을 찾는 중... ${lbb_relocationCountdown}초`, gameCanvas.width / 2, gameCanvas.height - 20);
    }

    gameCtx.shadowBlur = 0;

    if (lbbTimerBarContainerEl && lbb_isGameActive) {
        const elapsedTime = Date.now() - lbb_gameStartTime;
        const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
        if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
        const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function generateLBBGameBoard() {
    lbb_gameBoard = [];
    const wordPoolSource = gameWordsKor;
    const wordPool = wordPoolSource.filter(word => word.length >= 2 && word.length <= 3);

    for (let r = 0; r < LBB_BOARD_ROWS; r++) {
        lbb_gameBoard[r] = [];
        for (let c = 0; c < LBB_BOARD_COLS; c++) {
            const effectRoll = Math.random();
            let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
            if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                const itemRoll = Math.random();
                if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
            }
            lbb_gameBoard[r][c] = {
                word: getRandom(wordPool.length > 0 ? wordPool : wordPoolSource),
                broken: false,
                effect: effectType
            };
        }
    }
}

function getSurroundingLBBBlocks(pos, checkBroken = true) {
    const blocks = [];
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    for (const [dr, dc] of directions) {
        const r = pos.r + dr;
        const c = pos.c + dc;

        if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
            const block = lbb_gameBoard[r][c];
            if (!checkBroken || (block && !block.broken)) {
                blocks.push({ ...block, r, c });
            }
        }
    }
    return blocks;
}

function handleLetterBlockBattleInputSubmit() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
    const typedWord = gameInputField.value.trim();
    if (!typedWord) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);

    const matchedBlock = surroundingBlocks.find(block => {
        if (!block) return false;
        return block.word === typedWord;
    });

    if (matchedBlock) {
        lbb_playerMoveAndBreak(matchedBlock);
        checkLBBBattleCondition();
    } else {
        if (gameInputField) gameInputField.classList.add('shake-effect');
        setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
    }
    if (gameInputField) gameInputField.value = '';
}

function lbb_playerMoveAndBreak(targetBlock) {
    lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
    const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
    block.broken = true;

    lbb_playerScore += block.effect.score;
    lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
    if (block.effect.effect) {
        lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
    }
}

function lbb_enemyAIAction() {
    if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;

    const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
    if (surroundingBlocks.length > 0) {
        if (lbb_enemyNoPlayableBlocksTimerId) {
            clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
            lbb_enemyNoPlayableBlocksTimerId = null;
        }
        const targetBlock = getRandom(surroundingBlocks);
        lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
        const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
        block.broken = true;
        lbb_enemyScore += block.effect.score;
        lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
        if (block.effect.effect) {
             lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
        }
        checkLBBBattleCondition();
    } else {
        if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
            lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(false);
                lbb_enemyNoPlayableBlocksTimerId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
        }
    }
}

function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
    lbb_gamePausedForEffect = true;
    let popupText = '';

    switch (effect) {
        case 'freezeEnemy':
            if (isPlayer) {
                lbb_isEnemyFrozen = true;
                popupText = `적 정지! ${icon}`;
                if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
            }
            break;
        case 'swapPositions':
            lbb_swapEffect.active = true;
            lbb_swapEffect.step = 0;
            lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
            lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
            lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
            lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
            popupText = `위치 변경! ${icon}`;
            break;
    }

    if (popupText) {
        showGamePopup(popupText, 1500);
    }

    setTimeout(() => {
        if(effect !== 'swapPositions') lbb_gamePausedForEffect = false;
    }, 500);
}

function updateLBBSwapAnimation() {
    if (!lbb_swapEffect.active) return;
    lbb_swapEffect.step++;
    const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

    const playerTarget = lbb_swapEffect.enemyOld;
    const enemyTarget = lbb_swapEffect.playerOld;

    lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
    lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;

    lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
    lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;

    if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
        lbb_swapEffect.active = false;
        lbb_playerPos = { ...playerTarget };
        lbb_enemyPos = { ...enemyTarget };
        lbb_gamePausedForEffect = false;
    }
}
function lbb_triggerBlockBreakEffect(r, c, colorHex) {
    const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
    for (let i = 0; i < 15; i++) {
        lbb_blockBreakParticles.push({
            x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            ...colorRgb,
            alpha: 1
        });
    }
}

function checkLBBBattleCondition() {
    const path = findPath(lbb_playerPos, lbb_enemyPos);
    if (path) {
        lbb_triggerFinalBattleAnimation(path);
    }
}

function findPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([`${start.r},${start.c}`]);

    while (queue.length > 0) {
        const [current, path] = queue.shift();

        if (current.r === end.r && current.c === end.c) {
            return path;
        }

        const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);

        for (const neighbor of neighbors) {
            const posKey = `${neighbor.r},${neighbor.c}`;
            if (!visited.has(posKey)) {
                visited.add(posKey);
                const newPath = [...path, neighbor];
                queue.push([neighbor, newPath]);
            }
        }
    }
    return null;
}

function lbb_triggerFinalBattleAnimation(pathToMeet) {
    if (lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.isActive = true;
    lbb_finalBattleAnimation.step = 0;
    lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
    lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
    lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
}

function updateLBBFinalBattleAnimation() {
    if (!lbb_finalBattleAnimation.isActive) return;

    lbb_finalBattleAnimation.step++;
    const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;

    const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
    const meetingC = lbb_finalBattleAnimation.meetingPoint.c;

    lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
    lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
    lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;

    if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
        lbb_finalBattleAnimation.isActive = false;
        handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
    }
}

function checkAndTriggerPlayerLBBRelocation() {
    if(lbb_isRelocating) return;
    const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
    if(surroundingBlocks.length === 0){
        if(!lbb_playerNoPlayableBlocksTimerId) {
            lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
            lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                lbb_initiateRelocation(true);
                lbb_playerNoPlayableBlocksTimerId = null;
                clearInterval(lbb_relocationCountdownIntervalId);
                lbb_relocationCountdownIntervalId = null;
            }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

            lbb_relocationCountdownIntervalId = setInterval(() => {
                lbb_relocationCountdown--;
                if(lbb_relocationCountdown <= 0) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
            }, 1000);
        }
    } else {
        if (lbb_playerNoPlayableBlocksTimerId) {
            clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
        }
        if(lbb_relocationCountdownIntervalId) {
            clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;
        }
        lbb_relocationCountdown = 0;
    }
}

function lbb_initiateRelocation(isPlayerRelocation) {
    if (isPlayerRelocation) {
        lbb_isRelocating = true;
        showGamePopup("길이 막혔습니다! 재배치합니다...", 2000);
        setTimeout(() => lbb_performRelocation(true), 1000);
    } else {
        lbb_performRelocation(false);
    }
}

function lbb_performRelocation(isPlayerRelocation) {
    const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
    const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);

    if(newPos) {
        if(isPlayerRelocation) {
            lbb_playerPos = newPos;
        } else {
            lbb_enemyPos = newPos;
        }
        lbb_gameBoard[newPos.r][newPos.c].broken = true;
    } else {
        handleGameEnd(false, "stuck");
    }
    if (isPlayerRelocation) {
       lbb_isRelocating = false;
    }
}

function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
    const allSpots = [];
    for(let r=0; r<boardRows; r++){
        for(let c=0; c<boardCols; c++){
            if(!lbb_gameBoard[r][c].broken){
                 const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                 if(dist >= minDistanceFromOpponent){
                    allSpots.push({r, c});
                 }
            }
        }
    }
    return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
}


// === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
    if (level) gb_currentLevel = level;
    if(fromStartButtonOrNextLevel) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
    }

    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId); 

    gb_isGameActive = true;
    gb_gamePausedForOverlay = false;
    gb_playerHealth = GB_MAX_PLAYER_HEALTH;
    gb_enemyAttacks = [];
    gb_gameStartTime = Date.now();
    gb_enemyHitEffectTimer = 0;

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    gb_enemyHealth = currentLevelConfig.enemyHealth;

    gb_spawnPlayerAttackWord();

    if(gameInputField) {
      gameInputField.disabled = false;
      gameInputField.value = '';
      gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
      setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }
    
    let lastAttackTime = 0;
    function enemyAttackLoop(timestamp) {
        if (!gb_isGameActive) {
            if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
            return;
        };
        if (!lastAttackTime) lastAttackTime = timestamp;
        const elapsed = timestamp - lastAttackTime;
        const interval = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))].attackInterval;
        if(elapsed > interval) {
            gb_spawnEnemyAttack();
            lastAttackTime = timestamp;
        }
        gb_enemyAttackIntervalId = requestAnimationFrame(enemyAttackLoop);
    }
    requestAnimationFrame(enemyAttackLoop);

    startGiantBattleGameLoop();
}
function startGiantBattleGameLoop() {
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    function loop() {
        if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
             cancelAnimationFrame(gb_gameLoopId);
             gb_gameLoopId = null;
             return;
        }
        drawGiantBattleGame();
        if (gb_isGameActive && !gb_gamePausedForOverlay) {
            updateGiantBattleGameLogic();
        }
        gb_gameLoopId = requestAnimationFrame(loop);
    }
    gb_gameLoopId = requestAnimationFrame(loop);
}
function updateGiantBattleGameLogic() {
    if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

    if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
        handleGameEnd(gb_playerHealth > 0, "timeUp");
        return;
    }

    if (gb_enemyHitEffectTimer > 0) {
        gb_enemyHitEffectTimer -= 1000 / 60;
        if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
    }

    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
        const attack = gb_enemyAttacks[i];
        attack.y += currentLevelConfig.attackSpeed;

        const attackObjectHeight = 40;
        const playerHpBarY = gameCanvas.height - 35 - 18;
        const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;

        if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
            gb_enemyAttacks.splice(i, 1);
            gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
            const damageText = attack.isSpecial ? `특별 공격 피격! 🔥` : `피격! 🤕`;
            showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
            if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

            if (gb_playerHealth <= 0) {
                gb_playerHealth = 0;
                handleGameEnd(false, "hp");
                return;
            }
        } else if (attack.y > gameCanvas.height + attackObjectHeight) {
             gb_enemyAttacks.splice(i, 1);
        }
    }

    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
        return;
    }
}
function drawGiantBattleGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let mainTextColor, accentColor, specialAttackColor;
    if (bodyClasses.contains('light-theme')) {
        mainTextColor = '#524a42';
        accentColor = '#b89a6c';
        specialAttackColor = '#b89a6c';
    } else if (bodyClasses.contains('pink-theme')) {
        mainTextColor = '#4F333D';
        accentColor = '#E85D75';
        specialAttackColor = '#E85D75';
    } else {
        mainTextColor = '#e8e0d8';
        accentColor = '#d4af7a';
        specialAttackColor = '#d4af7a';
    }

    function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
        const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();

        gameCtx.fillStyle = bgColor;
        gameCtx.fillRect(x, y, width, height);

        const healthPercentage = Math.max(0, currentHealth) / maxHealth;
        const currentHealthWidth = width * healthPercentage;

        const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, healthColor);
        gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
        gameCtx.fillStyle = gradient;
        gameCtx.fillRect(x, y, currentHealthWidth, height);

        gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
        gameCtx.fillRect(x, y, currentHealthWidth, height / 2);

        if (label) {
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 12px 'Poppins', sans-serif";
            gameCtx.textAlign = textAlign;
            gameCtx.textBaseline = "bottom";
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
            gameCtx.shadowBlur = 0;
        }
    }

    function hexToDarker(hex, percent) {
      let { r, g, b } = hexToRgb(hex);
      r = parseInt(r * (1 - percent));
      g = parseInt(g * (1 - percent));
      b = parseInt(b * (1 - percent));
      return `rgb(${r}, ${g}, ${b})`;
    }
    const topUiY = 30;
    const uiMargin = 15;
    const healthBarHeight = 18;

    const enemyHealthBarWidth = gameCanvas.width * 0.3;
    drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "적 HP", 'right');

    const playerAreaBottomMargin = 50;
    const playerHpBarWidth = gameCanvas.width * 0.3;
    const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
    const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
    drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "플레이어 HP", 'right');

    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = mainTextColor;
    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(`레벨: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

    if (gb_gameStartTime) {
        const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
        const minutes = Math.floor(remainingTime / 60000);
        const seconds = Math.floor((remainingTime % 60000) / 1000);
        gameCtx.font = "bold 14px 'Poppins', sans-serif";
        gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
    }

    const attackWordBoxHeight = 40;
    const attackWordBoxWidth = gameCanvas.width * 0.3;
    const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
    const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20;

    gameCtx.strokeStyle = accentColor;
    gameCtx.lineWidth = 2;
    gameCtx.beginPath();
    gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
    gameCtx.stroke();
    gameCtx.lineWidth = 1;

    gameCtx.font = "bold 18px 'Poppins', sans-serif";
    gameCtx.fillStyle = accentColor;
    gameCtx.textAlign = "center";
    gameCtx.textBaseline = "middle";
    gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
    gameCtx.shadowBlur = 2;
    gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);

    gameCtx.font = "bold 24px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
    gameCtx.shadowBlur = 5;
    gameCtx.shadowOffsetX = 1;
    gameCtx.shadowOffsetY = 1;

    for (const attack of gb_enemyAttacks) {
        gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
        if (attack.isSpecial) {
            gameCtx.shadowColor = accentColor;
            gameCtx.shadowBlur = 10;
        } else {
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
        }
        gameCtx.fillText(attack.word, attack.x, attack.y);
    }
    gameCtx.shadowBlur = 0;
    gameCtx.shadowOffsetX = 0;
    gameCtx.shadowOffsetY = 0;
}
function gb_spawnPlayerAttackWord() {
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "공격";
}
function gb_spawnDefenseWord(currentLevelConfig) {
    const wordPool = gameWordsKor;
    const minLen = Math.max(3, currentLevelConfig.wordMinLen);
    const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
    return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "수비";
}
function gb_spawnEnemyAttack() {
    if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
    const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
    const wordPool = gameWordsKor;

    let word = "";
    let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
    let originalWordForSpecial = "";
    const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);

    if (isSpecialAttack) {
        const specialMinLen = 4;
        const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
        word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || "강타";
        originalWordForSpecial = word;
    } else {
        const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
        word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || "돌격";
    }

    const startY = -20;

    gb_enemyAttacks.push({
        word: word,
        originalWord: isSpecialAttack ? originalWordForSpecial : word,
        x: Math.random() * (gameCanvas.width - 100) + 50,
        y: startY,
        speed: currentLevelConfig.attackSpeed,
        element: 'rock',
        isSpecial: isSpecialAttack
    });
}
function handleGiantBattleInputSubmit() {
    if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
    const typedWordFull = gameInputField.value.trim();
    if (typedWordFull === "") return;

    const typedWord = typedWordFull;

    const playerAttackWordToMatch = gb_playerAttackWord;
    if (typedWord === playerAttackWordToMatch) {
        gb_playerAttack();
        if(gameInputField) gameInputField.value = "";
        return;
    }

    const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
    for (let i = 0; i < sortedEnemyAttacks.length; i++) {
        const enemyAttack = sortedEnemyAttacks[i];
        const enemyWordToMatch = enemyAttack.word;

        if (typedWord === enemyWordToMatch) {
            if (enemyAttack.isSpecial) {
                enemyAttack.isSpecial = false;
                const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                showGamePopup("특수 공격 무력화! 🛡️", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
            } else {
                gb_playerDefend(enemyAttack);
            }
            if(gameInputField) gameInputField.value = "";
            return;
        }
    }

    if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
    setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
    if(gameInputField) gameInputField.value = "";
}
function gb_playerAttack() {
    gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
    gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
    showGamePopup(`명중! 💥`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
    gb_spawnPlayerAttackWord();
    if (gb_enemyHealth <= 0) {
        gb_enemyHealth = 0;
        handleGameEnd(true, "hp");
    }
}
function gb_playerDefend(rock) {
    const index = gb_enemyAttacks.indexOf(rock);
    if (index > -1) {
        gb_enemyAttacks.splice(index, 1);
        showGamePopup("방어! 🛡️", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
    }
}

// ---------------------------------------------------
// ▼▼▼▼▼ 단축키 헬퍼 함수 ▼▼▼▼▼
// ---------------------------------------------------
function restartCurrentPractice() {
    if (currentMode === 'freestyle' || currentMode === 'game') return;

    typingInputField.value = '';
    currentDisplayLineIndex = 0;
    currentLineStartTime = null;
    disassembledLine = Hangul.disassemble(linesToPractice[0] || '');

    if (currentMode.endsWith('Long')) {
        startTime = null;
        currentArticleCorrectChars = 0;
    }
    
    renderTypingLayout();
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardHighlight();
    if(resultEl) resultEl.textContent = '다시 시작!';
    setTimeout(() => typingInputField.focus(), 50);
}

function changeGameLevel(direction) { // direction: 1 for next, -1 for previous
    if (currentMode !== 'game' || !currentGameType) return;
    
    const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');
    if (!gameLevelSelectEl) return;

    let maxLevel = 1;
    if (currentGameType === 'rainfall') maxLevel = rainfall_gameMainLevelsConfig.length;
    else if (currentGameType === 'letterBlockBattle') maxLevel = LBB_MAX_LEVEL;
    else if (currentGameType === 'giantBattle') maxLevel = GB_MAX_LEVEL;

    let currentLevel = parseInt(gameLevelSelectEl.value);
    let newLevel = currentLevel + direction;

    newLevel = Math.max(1, Math.min(newLevel, maxLevel));

    if (newLevel !== currentLevel) {
        const levelVarName = {
            rainfall: 'rainfall_gameLevel',
            letterBlockBattle: 'lbb_gameLevel',
            giantBattle: 'gb_currentLevel'
        }[currentGameType];

        window[levelVarName] = newLevel;
        updateDropdown(newLevel);
        
        handleGameEnd(false, 'level_change'); 
    }
}
function changeLongText(direction) { // direction: 1 for next, -1 for previous
    if (!currentMode.endsWith('Long') || !longTextSelectEl) return;

    const options = Array.from(longTextSelectEl.options);
    let currentIndex = longTextSelectEl.selectedIndex;

    // '랜덤'(-1)이 선택되어 있다면, 실제 글의 인덱스로 변환
    if (currentIndex <= 0) {
        currentIndex = 1; // 0번 인덱스는 '랜덤'이므로 1부터 시작
    }

    let nextIndex = currentIndex + direction;

    // 옵션 개수 내에서 순환하도록 처리 (0번 '랜덤' 제외)
    if (nextIndex >= options.length) {
        nextIndex = 1; // 마지막에서 다음으로 가면 처음으로
    } else if (nextIndex < 1) {
        nextIndex = options.length - 1; // 처음에서 이전으로 가면 마지막으로
    }

    longTextSelectEl.value = options[nextIndex].value;
    startPractice(currentMode, false);
}
// ---------------------------------------------------
// ▼▼▼▼▼ 게임 종료 처리 함수 ▼▼▼▼▼
// ---------------------------------------------------
function handleGameEnd(playerWins, reason) {
    let isActive;
    switch (currentGameType) {
        case 'rainfall': isActive = rainfall_isGameActive; rainfall_isGameActive = false; break;
        case 'letterBlockBattle': isActive = lbb_isGameActive; lbb_isGameActive = false; break;
        case 'giantBattle': isActive = gb_isGameActive; gb_isGameActive = false; break;
        default: return;
    }
    if (!isActive && reason !== 'level_change') return;

    if (currentGameType === 'rainfall') {
        if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        rainfall_gameLoopId = null;
        rainfall_wordGenerationIntervalId = null;
    } else if (currentGameType === 'letterBlockBattle') {
        if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
        if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
        lbb_gameLoopId = null;
        lbb_enemyActionIntervalId = null;
    } else if (currentGameType === 'giantBattle') {
        if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
        if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
        gb_gameLoopId = null;
        gb_enemyAttackIntervalId = null;
    }

    if(gameInputField) gameInputField.disabled = true;

    let gameConfig, currentLevel, resultData;
    window.gameResultData = null;
    const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

    if (currentGameType === 'rainfall') {
        gameConfig = { name: '소나기', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
        currentLevel = rainfall_gameLevel;
        resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 클리어!` : '게임 오버', gameName: '소나기', stats: { '레벨': currentLevel, '점수': rainfall_gameScore } };
    } else if (currentGameType === 'letterBlockBattle') {
        gameConfig = { name: '블록 배틀', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
        currentLevel = lbb_gameLevel;
        resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '블록 배틀', stats: { '레벨': currentLevel, '내 점수': lbb_playerScore, '적 점수': lbb_enemyScore } };
    } else if (currentGameType === 'giantBattle') {
        gameConfig = { name: '타이핑 배틀', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
        currentLevel = gb_currentLevel;
        resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '타이핑 배틀', stats: { '레벨': currentLevel, '남은 HP': Math.round(gb_playerHealth) } };
    } else {
        return;
    }

    const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;

    if (reason === 'level_change') {
        showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
        return;
    }
    
    let nextActionText = '';
    if (playerWins && currentLevel < gameConfig.maxLevel) {
        nextActionText = `다음 레벨 (${currentLevel + 1}) (Enter)`;
        resultData.nextAction = () => {
            const nextLevel = currentLevel + 1;
            window[gameConfig.levelVarName] = nextLevel;
            updateDropdown(nextLevel);
            showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
        };
    } else if (playerWins) {
        resultData.title = `🏆 모든 레벨 클리어!`;
        nextActionText = "처음부터 다시하기 (Enter)";
        resultData.nextAction = () => {
             window[gameConfig.levelVarName] = 1;
             updateDropdown(1);
             showCountdownThenStart(gameConfig.initFunc, [true, 1]);
        };
    } else {
        if(reason === 'timeUp' && ((currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > 0))) {
             resultData.title = `시간 종료 (판정승)`;
        }
        nextActionText = "다시 도전 (Enter)";
        resultData.nextAction = () => {
            const levelToRetry = selectedLevelInDropdown;
            window[gameConfig.levelVarName] = levelToRetry;
            updateDropdown(levelToRetry);
            showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
        };
    }
    resultData.nextActionText = nextActionText;
    
    window.gameResultData = resultData;
    showResultOverlay(resultData);
}
function showCountdownThenStart(startGameFunction, args = [true, 1]) {
    if (countdownTimerId) {
        clearTimeout(countdownTimerId);
        countdownTimerId = null;
    }

    if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
    if(gameOverlayEl) gameOverlayEl.classList.remove('visible');

    let count = 3;
    const countdown = () => {
        const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];
        if (drawFunc) drawFunc(); 
        
        if (count > 0) {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 80px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            count--;
            countdownTimerId = setTimeout(countdown, 1000);
        } else {
            gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.font = "bold 70px 'Poppins', sans-serif";
            gameCtx.fillStyle = 'white';
            gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
            gameCtx.shadowBlur = 0;
            countdownTimerId = setTimeout(() => {
                countdownTimerId = null;
                startGameFunction(...args);
            }, 500);
        }
    };
    countdown();
}
function returnToPracticeMode(resetSessionStats = true) {
    cleanupActiveModes();
    const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
    if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
        if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
             originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
        }
        if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
            originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
        }
    }
    if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
        gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
        gameToggleSoundBtn = null;
    }
    if (!statsVisible) {
        statsVisible = true;
        toggleStatsBtn.classList.add('active');
        toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
        statsEl.classList.remove('hidden');
    }
    let lastPracticeMode = 'kor';
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (activePracticeBtn && languageSelectEl) {
        const type = activePracticeBtn.dataset.practiceType;
        const lang = languageSelectEl.value;
        if(type !== 'freestyle' && type !== 'game'){
            lastPracticeMode = (type === 'long') ? `${lang}Long` : lang;
        }
    }
    updateKeyboardDisplay();
    updateKeyboardHighlight();
    startPractice(lastPracticeMode, resetSessionStats);
}
const charToKeyMap = {
    'ㅂ': 'q', 'ㅈ': 'w', 'ㄷ': 'e', 'ㄱ': 'r', 'ㅅ': 't', 'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅔ': 'p',
    'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l',
    'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
    'ㅃ': 'q', 'ㅉ': 'w', 'ㄸ': 'e', 'ㄲ': 'r', 'ㅆ': 't', 'ㅒ': 'o', 'ㅖ': 'p',
    '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
    '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/',
    '`': 'backquote', '~': 'backquote', '!': '1', '@': '2', '#': '3', '$': '4', '%': '5',
    '^': '6', '&': '7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '='
};

const Hangul = (() => {
    const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
    const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
    const HANGUL_OFFSET = 0xAC00;

    const disassemble = (str) => {
        return str.split('').map(char => {
            const code = char.charCodeAt(0);
            if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                const uniValue = code - HANGUL_OFFSET;
                const jong = uniValue % 28;
                const jung = Math.floor((uniValue - jong) / 28) % 21;
                const cho = Math.floor(uniValue / (21 * 28));
                
                const result = [CHO[cho]];
                const jungJamo = JUNG[jung];
                switch(jungJamo) {
                    case 'ㅘ': result.push('ㅗ', 'ㅏ'); break;
                    case 'ㅙ': result.push('ㅗ', 'ㅐ'); break;
                    case 'ㅚ': result.push('ㅗ', 'ㅣ'); break;
                    case 'ㅝ': result.push('ㅜ', 'ㅓ'); break;
                    case 'ㅞ': result.push('ㅜ', 'ㅔ'); break;
                    case 'ㅟ': result.push('ㅜ', 'ㅣ'); break;
                    case 'ㅢ': result.push('ㅡ', 'ㅣ'); break;
                    default: result.push(jungJamo); break;
                }
                
                if (jong > 0) {
                    const jongJamo = JONG[jong];
                    switch(jongJamo) {
                        case 'ㄳ': result.push('ㄱ', 'ㅅ'); break;
                        case 'ㄵ': result.push('ㄴ', 'ㅈ'); break;
                        case 'ㄶ': result.push('ㄴ', 'ㅎ'); break;
                        case 'ㄺ': result.push('ㄹ', 'ㄱ'); break;
                        case 'ㄻ': result.push('ㄹ', 'ㅁ'); break;
                        case 'ㄼ': result.push('ㄹ', 'ㅂ'); break;
                        case 'ㄽ': result.push('ㄹ', 'ㅅ'); break;
                        case 'ㄾ': result.push('ㄹ', 'ㅌ'); break;
                        case 'ㄿ': result.push('ㄹ', 'ㅍ'); break;
                        case 'ㅀ': result.push('ㄹ', 'ㅎ'); break;
                        case 'ㅄ': result.push('ㅂ', 'ㅅ'); break;
                        default: result.push(jongJamo); break;
                    }
                }
                return result;
            }
            return [char];
        }).flat();
    };
    return { disassemble };
})();

function buildKeyboard() {
    if (!keyboardGuideEl) return;
    keyboardGuideEl.innerHTML = '';
    
    const layout = [
        ['`','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
        ['Tab','q','w','e','r','t','y','u','i','o','p','[',']','\\'],
        ['CapsLock','a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
        ['ShiftLeft','z','x','c','v','b','n','m',',','.','/','ShiftRight'],
        ['ControlLeft', 'AltLeft', 'Space', 'AltRight', 'ControlRight']
    ];

    const keyInfo = {
        '`': { base: '`', shift: '~' }, '1': { base: '1', shift: '!' },
        '2': { base: '2', shift: '@' }, '3': { base: '3', shift: '#' },
        '4': { base: '4', shift: '$' }, '5': { base: '5', shift: '%' },
        '6': { base: '6', shift: '^' }, '7': { base: '7', shift: '&' },
        '8': { base: '8', shift: '*' }, '9': { base: '9', shift: '(' },
        '0': { base: '0', shift: ')' }, '-': { base: '-', shift: '_' },
        '=': { base: '=', shift: '+' },

        'q': { eng: 'Q', kor: 'ㅂ', shiftKor: 'ㅃ' }, 'w': { eng: 'W', kor: 'ㅈ', shiftKor: 'ㅉ' },
        'e': { eng: 'E', kor: 'ㄷ', shiftKor: 'ㄸ' }, 'r': { eng: 'R', kor: 'ㄱ', shiftKor: 'ㄲ' },
        't': { eng: 'T', kor: 'ㅅ', shiftKor: 'ㅆ' }, 'y': { eng: 'Y', kor: 'ㅛ' }, 'u': { eng: 'U', kor: 'ㅕ' },
        'i': { eng: 'I', kor: 'ㅑ' }, 'o': { eng: 'O', kor: 'ㅐ', shiftKor: 'ㅒ' }, 'p': { eng: 'P', kor: 'ㅔ', shiftKor: 'ㅖ' },
        '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, '\\': { base: '\\', shift: '|' },
        
        'a': { eng: 'A', kor: 'ㅁ' }, 's': { eng: 'S', kor: 'ㄴ' }, 'd': { eng: 'D', kor: 'ㅇ' },
        'f': { eng: 'F', kor: 'ㄹ' }, 'g': { eng: 'G', kor: 'ㅎ' }, 'h': { eng: 'H', kor: 'ㅗ' },
        'j': { eng: 'J', kor: 'ㅓ' }, 'k': { eng: 'K', kor: 'ㅏ' }, 'l': { eng: 'L', kor: 'ㅣ' },
        ';': { base: ';', shift: ':' }, "'": { base: "'", shift: '"' },

        'z': { eng: 'Z', kor: 'ㅋ' }, 'x': { eng: 'X', kor: 'ㅌ' }, 'c': { eng: 'C', kor: 'ㅊ' },
        'v': { eng: 'V', kor: 'ㅍ' }, 'b': { eng: 'B', kor: 'ㅠ' }, 'n': { eng: 'N', kor: 'ㅜ' }, 'm': { eng: 'M', kor: 'ㅡ' },
        ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' }, '/': { base: '/', shift: '?' }
    };

    layout.forEach((row, index) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = `keyboard-row row-${index + 1}`;
        
        const keysWrapper = document.createElement('div');
        keysWrapper.className = 'keys-wrapper';

        row.forEach(keyId => {
            const keyDiv = document.createElement('div');
            let dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
            if(dataKey === '`') dataKey = 'backquote';
            keyDiv.dataset.key = dataKey;
            keyDiv.classList.add('keyboard-key');

            const data = keyInfo[keyId.toLowerCase()];
            if (data) {
                const mainChar = data.eng ? data.eng.toLowerCase() : data.base;
                const shiftChar = data.eng ? data.eng.toUpperCase() : data.shift;
                const korMain = data.kor || data.base || '';
                const korShift = data.shiftKor || data.shift || '';
                
                keyDiv.innerHTML = `
                    <div class="key-eng">
                        <span class="key-shift-char">${shiftChar}</span>
                        <span class="key-main-char">${mainChar}</span>
                    </div>
                    <div class="key-kor">
                        <span class="key-shift-char">${korShift}</span>
                        <span class="key-main-char">${korMain}</span>
                    </div>
                `;
            } else {
                 keyDiv.classList.add('special-key');
                 keyDiv.textContent = keyId.replace(/Left|Right/, '');
            }

            if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId.toLowerCase())) {
                keyDiv.classList.add('home-row-base');
            }

            const keyWidths = {
                backspace: '2x', tab: '1.5x', capslock: '1.75x', enter: '2.25x',
                shiftleft: '2.5x', shiftright: '2.5x', space: 'space'
            };
            if(keyWidths[keyId.toLowerCase()]) {
                keyDiv.classList.add(`key-width-${keyWidths[keyId.toLowerCase()]}`);
            }

            keysWrapper.appendChild(keyDiv);
        });
        rowDiv.appendChild(keysWrapper);
        keyboardGuideEl.appendChild(rowDiv);
    });
}

function updateKeyboardDisplay() {
    if (!keyboardGuideEl) return;
    
    const lang = currentMode.replace('Long', '');
    
    keyboardGuideEl.className = 'keyboard-guide';
    if (keyboardGuideEnabled) {
        keyboardGuideEl.classList.add('visible');
    }
    keyboardGuideEl.classList.add(`lang-${lang}`);
}

function clearKeyboardHighlight() {
    if (!keyboardGuideEl) return;
    const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
    highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
}

function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game' || currentMode === 'freestyle') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();
    
    const isKorMode = currentMode.startsWith('kor');
    let nextCharToPress;

    if (isKorMode) {
        const disassembledTyped = Hangul.disassemble(typingInputField.value);
        if (disassembledTyped.length < disassembledLine.length) {
            nextCharToPress = disassembledLine[disassembledTyped.length];
        }
    } else {
        const originalLine = linesToPractice[currentDisplayLineIndex];
        if (!originalLine) return;
        const typedValue = typingInputField.value;
        if (typedValue.length < originalLine.length) {
            nextCharToPress = originalLine[typedValue.length];
        }
    }
    
    if (!nextCharToPress) return;

    const shiftKeyMap = {
        '~':'`', '!':'1', '@':'2', '#':'3', '$':'4', '%':'5', '^':'6', '&':'7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '=',
        '{': '[', '}': ']', '|': '\\', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/'
    };
    
    let keyId;
    let isShiftNeeded = false;

    if (nextCharToPress >= 'A' && nextCharToPress <= 'Z') {
        isShiftNeeded = true;
        keyId = nextCharToPress.toLowerCase();
    } else if (shiftKeyMap[nextCharToPress]) {
        isShiftNeeded = true;
        keyId = shiftKeyMap[nextCharToPress];
    } else if (isKorMode && 'ㅃㅉㄸㄲㅆㅒㅖ'.includes(nextCharToPress)) {
        isShiftNeeded = true;
        keyId = charToKeyMap[nextCharToPress];
    } else {
        keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    }
    
    if(keyId === '`') keyId = 'backquote';

    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}

// === HELP MODAL FUNCTIONS ===
function getHelpContent(gameType) {
    const contents = {
        rainfall: {
            title: '<i class="fas fa-cloud-showers-heavy"></i> 소나기 게임 방법',
            body: `<p>하늘에서 떨어지는 단어들을 사라지기 전에 입력하여 점수를 획득하는 게임입니다.</p>
                   <p>단어가 바닥에 닿으면 생명이 1 감소하며, 생명을 모두 잃으면 게임이 종료됩니다.</p>
                   <div class="item-info">
                        <div><strong>아이템 종류:</strong></div>
                        <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text}: 생명이 1 증가합니다.</div>
                        <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text}: 3초 동안 모든 단어의 움직임이 멈춥니다.</div>
                        <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text}: 화면의 모든 일반 단어를 제거하고 점수를 얻습니다.</div>
                   </div>`
        },
        letterBlockBattle: {
            title: '<i class="fas fa-th-large"></i> 블록 배틀 게임 방법',
            body: `<p>상하좌우에 인접한 블록의 단어를 입력하여 이동하고 점수를 얻습니다. 블록을 부숴 적과 나의 캐릭터가 빈 칸으로 연결되면 전투가 일어나며, 점수가 높은 쪽이 승리합니다.</p>
                   <p>2분 안에 승부가 나지 않으면 점수가 더 높은 쪽이 판정승합니다.</p>
                   <div class="item-info">
                        <div><strong>특수 블록:</strong></div>
                        <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: 2점</div>
                        <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: 3점</div>
                        <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: 적을 2초간 얼립니다.</div>
                        <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 적과 나의 위치를 바꿉니다.</div>
                   </div>`
        },
        giantBattle: {
            title: '<i class="fas fa-fist-raised"></i> 타이핑 배틀 게임 방법',
            body: `<p>화면 하단의 공격 단어를 입력하여 적을 공격하고, 위에서 내려오는 적의 공격 단어를 입력하여 방어하세요.</p>
                   <p>2분 내에 적의 HP를 0으로 만들거나, 시간이 종료됐을 때 나의 HP가 더 많으면 승리합니다.</p>`
        }
    };
    return contents[gameType] || { title: '도움말', body: '게임 정보를 찾을 수 없습니다.' };
}

function showHelpModal(gameType) {
    const content = getHelpContent(gameType);
    if (helpModalBody) helpModalBody.innerHTML = `<h2>${content.title}</h2>${content.body}`;
    if (helpModal) helpModal.classList.add('visible');
    
    if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = true;
    else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = true;
    else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = true;
}

function hideHelpModal() {
    if (helpModal) helpModal.classList.remove('visible');

    if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = false;
    else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = false;
    else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = false;
}
async function shareResult() {
    if (!window.gameResultData) {
        showSharePopup('공유할 결과 데이터가 없습니다.');
        return;
    }

    const resultData = window.gameResultData;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    const width = 500;
    const height = 280;
    const padding = 30;
    const borderRadius = 12;

    canvas.width = width;
    canvas.height = height;

    const theme = document.body.classList.contains('light-theme') ? 'light' : (document.body.classList.contains('pink-theme') ? 'pink' : 'dark');
    
    const colors = {
        dark: { bg: '#2a2826', text: '#e8e0d8', accent: '#d4af7a', secondary: '#b2aca2' },
        light: { bg: '#fff', text: '#524a42', accent: '#b89a6c', secondary: '#756A5F' },
        pink: { bg: '#ffffff', text: '#4F333D', accent: '#E85D75', secondary: '#735A64' }
    };
    const currentTheme = colors[theme];
    
    ctx.fillStyle = currentTheme.bg;
    ctx.beginPath();
    ctx.moveTo(borderRadius, 0);
    ctx.lineTo(width - borderRadius, 0);
    ctx.quadraticCurveTo(width, 0, width, borderRadius);
    ctx.lineTo(width, height - borderRadius);
    ctx.quadraticCurveTo(width, height, width - borderRadius, height);
    ctx.lineTo(borderRadius, height);
    ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
    ctx.lineTo(0, borderRadius);
    ctx.quadraticCurveTo(0, 0, borderRadius, 0);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = currentTheme.accent;
    ctx.font = "bold 36px 'Playfair Display', serif";
    ctx.textAlign = 'center';
    ctx.fillText(resultData.title, width / 2, padding + 40);
    
    ctx.font = "500 18px 'Poppins', sans-serif";
    const stats = Object.entries(resultData.stats);
    const statY = 130;
    const statXMargin = width / (stats.length + 1);

    stats.forEach(([key, value], index) => {
        const x = statXMargin * (index + 1);
        ctx.fillStyle = currentTheme.secondary;
        ctx.fillText(key + ':', x, statY);
        ctx.fillStyle = currentTheme.text;
        ctx.fillText(value, x, statY + 28);
    });

    canvas.toBlob(async (blob) => {
        if (!blob) return;
        
        const file = new File([blob], 'keytherapy-result.png', { type: 'image/png' });
        const shareTitle = 'Key Therapy 게임 결과';
        const shareText = `🎉 ${resultData.title} 🎉\n\n지금 바로 Key Therapy에서 타자 실력을 확인해보세요!`;
        const shareUrl = 'https://keytherapy.vercel.app';

        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    files: [file],
                    title: shareTitle,
                    text: shareText,
                    url: shareUrl,
                });
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Web Share API 공유 실패:', error);
                    showSharePopup('결과 공유에 실패했습니다.');
                }
            }
        } else {
            try {
                const clipboardItem = new ClipboardItem({
                    'image/png': blob,
                    'text/plain': new Blob([`${shareTitle}\n${shareText}\n${shareUrl}`], { type: 'text/plain' })
                });
                await navigator.clipboard.write([clipboardItem]);
                showSharePopup('결과 이미지와 링크가 복사되었습니다!');
            } catch (error) {
                console.error('클립보드 복사 실패:', error);
                showSharePopup('결과 공유에 실패했습니다.');
            }
        }
    }, 'image/png');
}

function showResultOverlay(resultData) {
    if (!gameOverlayEl) return;

    let statsHtml = '';
    for (const [key, value] of Object.entries(resultData.stats)) {
        statsHtml += `<div class="stat-item"><span class="label">${key}:</span><span class="value">${value}</span></div>`;
    }

    const shareButtonHtml = `<button id="shareResultBtn" class="game-button secondary"><i class="fas fa-share-alt"></i> 결과 공유하기</button>`;

    gameOverlayEl.innerHTML = `
        <div class="result-card">
            <h2>${resultData.title}</h2>
            <div class="result-card-stats">${statsHtml}</div>
            <div class="result-buttons">
                <button id="nextStepBtnOverlay" class="game-button">${resultData.nextActionText}</button>
                ${shareButtonHtml}
            </div>
        </div>`;

    setTimeout(() => {
        gameOverlayEl.classList.add('visible');
    }, 100);

    const nextBtn = document.getElementById('nextStepBtnOverlay');
    const shareBtn = document.getElementById('shareResultBtn');
    
    if (nextBtn) {
        nextBtn.addEventListener('click', () => {
            gameOverlayEl.classList.remove('visible');
            resultData.nextAction();
        });
    }

    if (shareBtn) {
        shareBtn.addEventListener('click', shareResult);
    }
}
function updateLayout() {
    if (!toggleLayoutBtn) return;

    document.body.classList.toggle('layout-collapsed', layoutCollapsed);
    if (layoutCollapsed) {
        toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-down"></i> 메뉴 펼치기';
    } else {
        toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-up"></i> 메뉴 숨기기';
    }
}

function applyTheme(theme) {
    document.body.classList.remove('light-theme', 'pink-theme');
    if (theme === 'light') document.body.classList.add('light-theme');
    else if (theme === 'pink') document.body.classList.add('pink-theme');

    if (gameCanvas && currentGameType) {
        requestAnimationFrame(() => {
            if (currentGameType === 'rainfall') drawRainfallGame();
            else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
            else if (currentGameType === 'giantBattle') drawGiantBattleGame();
        });
    }
}
</script>
</body>
</html>
