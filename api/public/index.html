<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="naver-site-verification" content="a8106e0cbefd36468e543556b1a32d52aa11f6a6" />
  <title>Key Therapy - 온라인 타자연습 & 게임</title>
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bagel+Fat+One&family=Cute+Font&family=Do+Hyeon&family=Dokdo&family=East+Sea+Dokdo&family=Gaegu:wght@300;400;700&family=Gamja+Flower&family=Gowun+Dodum&family=Hi+Melody&family=IBM+Plex+Sans+KR:wght@300;400;500&family=Kirang+Haerang&family=Nanum+Brush+Script&family=Nanum+Myeongjo:wght@400;700&family=Nanum+Pen+Script&family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:wght@600;700&family=Poppins:wght@400;500;600;700&family=Single+Day&family=Song+Myung&family=Source+Code+Pro:wght@400;500&family=Stylish&family=Yeon+Sung&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* 기존 CSS 스타일은 변경 없이 그대로 유지됩니다. */
.no-transition * {
  transition: none !important;
}
.shake-effect {
  animation: shake 0.2s;
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.flash-effect {
  animation: flash 0.3s ease-out;
}
@keyframes flash {
  0%, 100% { box-shadow: none; border-color: var(--input-border); }
  50% {
    box-shadow: 0 0 15px 5px rgba(255, 82, 82, 0.7);
    border-color: rgba(255, 82, 82, 0.9);
  }
}
#game-canvas.enemy-hit {
    animation: enemyHitFlash 0.15s ease-out;
}
@keyframes enemyHitFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.5) saturate(1.5); }
}
#item-effect-popup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 20px;
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    font-size: 1.3em;
    font-weight: 600;
    border-radius: var(--border-radius-small);
    z-index: 100;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    pointer-events: none;
    box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    text-align: center;
}
#item-effect-popup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}
.light-theme #item-effect-popup {
    background-color: var(--accent-darker);
    color: #fff;
}
.pink-theme #item-effect-popup {
    background-color: var(--accent-active);
    color: #fff;
}
    :root {
      --bg-main: #201e1c;
      --bg-container: #2a2826;
      --bg-typing-area: #262422;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #44403d;
      --text-primary: #e8e0d8;
      --text-secondary: #b2aca2;
      --accent-primary: #d4af7a;
      --accent-secondary: #c8a273;
      --accent-active: #b89263;
      --accent-darker: #aa8a5a;
      --highlight-error: #f48fb1;
      --highlight-error-bg: rgba(244, 143, 177, 0.1);
      --input-bg: #33302e;
      --input-text: #f5f0eb;
      --input-border: #4a4643;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.45);
      --button-text: #2f2c2a;
      --button-text-on-accent: #332e2a;
      --current-line-bg: rgba(var(--accent-rgb), 0.08);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.35);
      --current-line-shadow: 0 2px 12px rgba(var(--accent-rgb),0.12);
      --font-body: 'Gowun Dodum', sans-serif;
      --font-heading: 'Playfair Display', serif;
      --font-typing: 'Gowun Dodum', sans-serif;
      --font-ui: 'Poppins', sans-serif;
      --line-height-typing: 1.8;
      --accent-rgb: 212, 175, 122;
      --accent-primary-rgb: 212, 175, 122;
      --hero-image-url: url('https://images.unsplash.com/photo-1505322265381-3138d62ab20a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGtleWJvYXJkJTIwYWVzdGhldGljfGVufDB8fDB8fHww&auto=format&fit=crop&w=1000&q=80');
      --border-radius-main: 12px;
      --border-radius-small: 8px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.4);
      --shadow-inset: inset 0 2px 5px rgba(0,0,0,0.25);
      --shadow-button: 0 5px 12px rgba(0,0,0,0.28);
      --shadow-button-hover: 0 7px 15px rgba(0,0,0,0.32);
      
      --font-size-base: 1.25rem;
      --font-size-base-mobile: 1.15rem;
      --font-scale-multiplier: 1.0;
      --font-size-typing: calc(var(--font-size-base) * var(--font-scale-multiplier));
      --font-size-typing-mobile: calc(var(--font-size-base-mobile) * var(--font-scale-multiplier));
      
      --typing-letter-spacing: 0px;
      --typing-word-spacing: 0px;
      --typing-letter-spacing-mobile: 0px;
      --typing-word-spacing-mobile: 0px;
      --lbb-player-color-dark: dodgerblue;
      --lbb-enemy-color-dark: tomato;
      --current-lbb-player-color: var(--lbb-player-color-dark);
      --current-lbb-enemy-color: var(--lbb-enemy-color-dark);
      --lbb-player-color-light: #4A90E2;
      --lbb-enemy-color-light: #D0021B;
      --lbb-player-color-pink: #E91E63;
      --lbb-enemy-color-pink: #7B1FA2;
      --lbb-score-color: #FFFFFF;
      --lbb-player-highlight-border-dark: yellow;
      --lbb-player-highlight-border-light: #FFC107;
      --lbb-player-highlight-border-pink: #FF80AB;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-dark);
      --lbb-player-block-bg-dark: #42403c;
      --lbb-player-block-bg-light: #fffacd;
      --lbb-player-block-bg-pink: #ffe8f0;
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-dark);
      --gb-player-health-color: #4CAF50;
      --gb-enemy-health-color: #F44336;
      --gb-health-bar-bg-color: #777;
    }
        .light-theme {
      /* 전체 배경: 살짝 어두운 크림색으로 차분함 부여 */
      --bg-main: #f8f5f0;
      /* 컨테이너 배경: 깨끗한 아이보리색 */
      --bg-container: #ffffff;
      /* 타이핑 영역 배경: 컨테이너와 미세한 톤 차이 */
      --bg-typing-area: #fbf9f6;
      --bg-progress-bar: #a98b61;
      --bg-progress-bar-track: #e8e2d9;
      
      /* 기본 텍스트: 가독성을 위해 더 진한 세피아 톤으로 */
      --text-primary: #3d3934;
      /* 보조 텍스트: 기본 텍스트와 명확히 구분되는 부드러운 회갈색 */
      --text-secondary: #8a8177;

      /* 강조색: 깊이 있는 올드 골드 색상으로 변경 */
      --accent-primary: #a98b61;
      --accent-secondary: #c5b29a;
      --accent-active: #9a7c55;
      --accent-darker: #896d4a;
      --accent-rgb: 169, 139, 97;
      --accent-primary-rgb: 169, 139, 97;
      
      /* 입력창 관련 색상 조정 */
      --input-bg: #fefdfb;
      --input-text: #3d3934;
      --input-border: #e0d9d0;
      --input-focus-shadow: 0 0 8px rgba(var(--accent-rgb), 0.3);
      
      /* 버튼 텍스트 색상 */
      --button-text: #3d3934;
      --button-text-on-accent: #ffffff;

      /* 현재 타이핑 라인 스타일 */
      --current-line-bg: rgba(var(--accent-rgb), 0.07);
      --current-line-text: var(--text-primary);
      --current-line-typed-text: var(--accent-active);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 3px 10px rgba(var(--accent-rgb),0.12);
      
      /* 오류 하이라이트: 부드러운 톤으로 변경 */
      --highlight-error: #e57373;
      --highlight-error-bg: rgba(229, 115, 115, 0.1);

      /* 그림자: 새로운 색상 톤에 맞게 조정 */
      --shadow-soft: 0 8px 25px rgba(180, 160, 140, 0.12);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.03);
      --shadow-button: 0 4px 10px rgba(180, 160, 140, 0.1);
      --shadow-button-hover: 0 6px 13px rgba(180, 160, 140, 0.15);
      
      /* 게임 관련 색상은 유지 또는 필요시 조정 */
      --current-lbb-player-color: var(--lbb-player-color-light);
      --current-lbb-enemy-color: var(--lbb-enemy-color-light);
      --lbb-score-color: var(--text-primary);
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-light);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-light);
      --gb-player-health-color: #66BB6A;
      --gb-enemy-health-color: #EF5350;
      --gb-health-bar-bg-color: #BDBDBD;
    }
    .pink-theme {
      --bg-main: #fff0f5;
      --bg-container: #ffffff;
      --bg-typing-area: #fff5f8;
      --bg-progress-bar: var(--accent-secondary);
      --bg-progress-bar-track: #ffe0e9;
      --text-primary: #4F333D;
      --text-secondary: #735A64;
      --accent-primary: #E85D75;
      --accent-secondary: #F080A0;
      --accent-active: #D94F6A;
      --accent-darker: #C9405A;
      --highlight-error: #FF6347;
      --highlight-error-bg: rgba(255, 99, 71, 0.1);
      --input-bg: #fffafa;
      --input-text: #4F333D;
      --input-border: #f8d0da;
      --input-focus-shadow: 0 0 10px rgba(var(--accent-rgb), 0.35);
      --button-text: #4F333D;
      --button-text-on-accent: #ffffff;
      --current-line-bg: rgba(var(--accent-rgb), 0.1);
      --current-line-text: #4F333D;
      --current-line-typed-text: var(--accent-primary);
      --current-line-border: rgba(var(--accent-rgb), 0.3);
      --current-line-shadow: 0 2px 10px rgba(var(--accent-rgb),0.15);
      --accent-rgb: 232, 93, 117;
      --accent-primary-rgb: 232, 93, 117;
      --shadow-soft: 0 8px 25px rgba(200, 130, 150, 0.2);
      --shadow-inset: inset 0 1px 3px rgba(0,0,0,0.05);
      --shadow-button: 0 4px 10px rgba(200, 130, 150, 0.18);
      --shadow-button-hover: 0 6px 13px rgba(200, 130, 150, 0.22);
      --border-radius-main: 14px;
      --border-radius-small: 10px;
      --current-lbb-player-color: var(--lbb-player-color-pink);
      --current-lbb-enemy-color: var(--lbb-enemy-color-pink);
      --lbb-score-color: #FFFFFF;
      --current-lbb-player-highlight-border: var(--lbb-player-highlight-border-pink);
      --current-lbb-player-block-bg: var(--lbb-player-block-bg-pink);
      --gb-player-health-color: #EC407A;
      --gb-enemy-health-color: #F06292;
      --gb-health-bar-bg-color: #F8BBD0;
    }
    ::selection {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      text-shadow: none;
    }
    .light-theme ::selection {
      background-color: var(--accent-active);
      color: var(--button-text-on-accent);
    }
    .pink-theme ::selection {
      background-color: var(--accent-active);
      color: #fff;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-main); font-family: var(--font-body); font-weight: 300;
      margin: 0; padding: 0; color: var(--text-primary); display: flex;
      flex-direction: column; min-height: 100vh; opacity: 0;
      animation: fadeInPage 0.8s 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-tap-highlight-color: transparent;
      line-height: 1.65;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    @keyframes fadeInPage { to { opacity: 1; } }
    ::-webkit-scrollbar { width: 9px; }
    ::-webkit-scrollbar-track { background: var(--bg-typing-area); }
    ::-webkit-scrollbar-thumb { background: var(--accent-secondary); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    .main-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        padding: 25px 15px;
        width: 100%; box-sizing: border-box;
        transition: padding-top 0.4s ease-out;
    }
    body.layout-collapsed .main-content-wrapper {
        padding-top: 23vh;
    }
    body.layout-collapsed.freestyle-mode-active .main-content-wrapper {
    padding-top: 25px;
    }
    body.game-mode-active .main-content-wrapper {
        align-items: center;
        padding-top: 3vh;
    }
    body.focus-mode-active {
        overflow: hidden;
    }
    body.focus-mode-active .main-content-wrapper {
        padding: 0;
        align-items: stretch;
        justify-content: stretch;
    }
    body.focus-mode-active .main-content {
        max-width: 100%;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    body.focus-mode-active .layout-toggle-container,
    body.focus-mode-active .hero-section,
    body.focus-mode-active .controls-and-stats-wrapper,
    body.focus-mode-active .footer {
        display: none !important;
    }
    body.focus-mode-active #freestyle-area-container {
        height: 100%;
        border-radius: 0;
    }
    .layout-toggle-container {
        width: 100%;
        max-width: 1200px;
        position: relative;
        z-index: 10;
        height: 0;
    }
    #toggleLayoutBtn {
      position: absolute;
      left: 0; 
      transform: translateX(0);
      top: 0;
      padding: 6px 15px;
      font-size: 0.85em;
      border-radius: 0 0 var(--border-radius-small) var(--border-radius-small);
      cursor: pointer;
      font-family: var(--font-ui);
      font-weight: 500;
      border: 1.5px solid transparent;
      border-top: none;
      background: transparent;
      color: var(--text-secondary);
      transition: all 0.2s ease-in-out;
      box-shadow: none;
      opacity: 0.6;
    }
    #toggleLayoutBtn:hover {
        background: var(--bg-container);
        color: var(--accent-primary);
        border-color: var(--input-border);
        opacity: 1;
    }
    #toggleLayoutBtn i {
        margin-right: 7px;
    }
    #result,
    #toggleLayoutBtn {
        transition: opacity 0.4s ease-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }
   .main-content {
  max-width: 1200px;
  width: 100%; background-color: var(--bg-container);
  border-radius: var(--border-radius-main); box-shadow: var(--shadow-soft);
  display: flex; flex-direction: column;
  border: 1px solid rgba(var(--accent-primary-rgb), 0.1);
  transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease, max-width 0.4s ease-in-out, flex-grow 0.4s ease-out;
}
    .light-theme .main-content { border-color: rgba(var(--accent-rgb), 0.18); }
    .pink-theme .main-content { border-color: rgba(var(--accent-rgb), 0.25); }
    .hidden { display: none !important; }
    body.game-mode-active .layout-toggle-container,
    body.game-mode-active .hero-section,
    body.game-mode-active .controls-and-stats-wrapper,
    body.game-mode-active .progress-bar-container,
    body.game-mode-active .typing-area-container,
    body.game-mode-active #freestyle-area-container,
    body.game-mode-active #result,
    body.game-mode-active .footer {
        display: none !important;
    }
    body.freestyle-mode-active .typing-area-container,
    body.freestyle-mode-active .progress-bar-container,
    body.freestyle-mode-active #game-area-container,
    body.freestyle-mode-active #keyboard-guide.visible {
        display: none !important;
    }
    #freestyle-area-container { display: none; }
    body.freestyle-mode-active #freestyle-area-container { display: flex; }
    body.game-mode-active .main-content { max-width: 1200px; min-height: auto; }
    body.game-mode-active #game-area-container {
        display: flex !important;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        flex-grow: 1;
        width: 100%;
        padding: 0;
        box-sizing: border-box;
        position: relative;
    }
    .hero-section {
      width: 100%; padding: 10px 25px;
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 42, 40, 38), 0.2) 0%, rgba(var(--bg-container-rgb, 42, 40, 38), 0.9) 100%),
        var(--hero-image-url);
      background-size: cover; background-position: center 25%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; position: relative; border-radius: var(--border-radius-main) var(--border-radius-main) 0 0;
      box-sizing: border-box; border-bottom: 1px solid rgba(var(--accent-primary-rgb), 0.15);
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s 0.1s, border-width 0.4s, border-radius 0.3s ease, visibility 0.4s;
    }
    .light-theme .hero-section {
        background-image:
            linear-gradient(to bottom, rgba(var(--accent-rgb),0.02) 0%, rgba(var(--bg-container-rgb, 255,255,255), 0.92) 100%),
            var(--hero-image-url);
        border-bottom-color: rgba(var(--accent-rgb), 0.2);
    }
    .pink-theme .hero-section {
      background-image:
        linear-gradient(to bottom, rgba(var(--bg-container-rgb, 255,240,245),0.1) 0%, rgba(var(--bg-container-rgb, 255,245,248), 0.95) 100%),
        var(--hero-image-url);
      border-bottom-color: rgba(var(--accent-rgb), 0.25);
    }
    .hero-title {
      font-family: var(--font-heading); font-size: 2.6em;  font-weight: 700;
      color: var(--accent-primary); margin: 0 0 6px 0;
      text-shadow: 0 0 15px rgba(var(--accent-primary-rgb), 0.35), 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .hero-tagline {
      font-family: var(--font-body); font-size: 0.95em; font-weight: 400;
      color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.25);
      max-width: 80%; margin-left: auto; margin-right: auto;
    }
    .light-theme .hero-title, .pink-theme .hero-title { color: var(--accent-darker); }
    .light-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.2), 0 1px 2px rgba(0,0,0,0.1); }
    .pink-theme .hero-title { text-shadow: 0 0 12px rgba(var(--accent-rgb),0.25), 0 1px 2px rgba(100,50,60,0.15); }
    .light-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(0,0,0,0.08); }
    .pink-theme .hero-tagline { color: var(--text-secondary); text-shadow: 0 1px 2px rgba(100,50,60,0.1); }
    .controls-and-stats-wrapper {
        padding: 25px 25px 15px;
        max-height: 500px;
        overflow: hidden;
        transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out, opacity 0.3s, visibility 0.4s;
    }
   body.layout-collapsed .hero-section {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
        visibility: hidden;
    }

    /* 
     * [핵심 변경] 
     * .controls-and-stats-wrapper 전체를 숨기는 대신,
     * 그 안의 .settings-container(각종 설정 버튼들)만 숨기도록 변경합니다.
    */
    body.layout-collapsed .settings-container {
        max-height: 0;
        opacity: 0;
        visibility: hidden;
        margin-bottom: 0; /* 설정 영역이 사라지면서 불필요한 여백도 제거합니다. */
        overflow: hidden; /* max-height 애니메이션을 위해 필요합니다. */
    }

    /* 
     * 메뉴가 숨겨졌을 때 wrapper의 상하 패딩을 줄여
     * 통계창이 너무 아래에 위치하지 않도록 조정합니다.
    */
    body.layout-collapsed .controls-and-stats-wrapper {
        padding-top: 15px;
        padding-bottom: 0;
    }
    .settings-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 18px; }
    .main-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    .control-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    .control-button-group button {
      padding: 10px 15px; font-size: 0.9em; border-radius: var(--border-radius-small);
      cursor: pointer; transition: all 0.2s ease-in-out;
      font-family: var(--font-ui); font-weight: 500; letter-spacing: 0.25px;
      outline: none; flex-grow: 1; display: inline-flex; align-items: center; justify-content: center;
      border: 1.5px solid var(--accent-secondary); background: transparent;
      color: var(--accent-secondary); text-shadow: none; box-shadow: none;
    }
    .control-button-group button:hover {
      background: var(--accent-secondary); color: var(--button-text-on-accent);
      border-color: var(--accent-secondary); transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(var(--accent-rgb),0.15);
    }
    .control-button-group button.active {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary); font-weight: 600;
      box-shadow: 0 1px 4px rgba(var(--accent-rgb),0.2), inset 0 1px 1px rgba(0,0,0,0.05);
      transform: translateY(0);
    }
    .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button i { margin-right: 7px; opacity: 0.75; font-size: 0.95em; line-height: 1; }
    .control-button-group button.active i { opacity: 1; }
    .light-theme .control-button-group button, .pink-theme .control-button-group button { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    .light-theme .control-button-group button:hover, .pink-theme .control-button-group button:hover {
        background: var(--accent-secondary); color: var(--button-text-on-accent);
        border-color: var(--accent-secondary); box-shadow: var(--shadow-button-hover);
    }
    .light-theme .control-button-group button.active, .pink-theme .control-button-group button.active {
        background: var(--accent-primary); color: var(--button-text-on-accent);
        border-color: var(--accent-primary); box-shadow: var(--shadow-button), inset 0 1px 1px rgba(0,0,0,0.03);
    }
    .light-theme .control-button-group button.active:hover, .pink-theme .control-button-group button.active:hover { background: var(--accent-active); border-color: var(--accent-active); }
    .control-button-group button.disabled,
    .selection-controls .disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
        background: transparent !important;
        color: var(--text-secondary) !important;
        border-color: var(--input-border) !important;
        box-shadow: none !important;
        transform: none !important;
    }
    .practice-mode-controls,
    .feature-toggles {
        width: 100%;
        justify-content: center;
    }
    .practice-mode-controls button { min-width: 90px; }
    .feature-toggles button { border-radius: 20px; min-width: 120px; }
    .selection-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        width: 100%;
    }
    .language-settings, .sound-settings, .theme-settings, .long-text-settings, .font-family-settings {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .select-label { font-size: 0.9em; color: var(--text-secondary); font-weight: 400; }
    #languageSelect, #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect,
    #gameInternalControlsBar .game-control-select {
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border); border-radius: var(--border-radius-small);
        padding: 9px 12px; font-family: var(--font-ui); font-size: 0.9em;
        outline: none; min-width: 110px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
    }
    #languageSelect:focus, #soundPackSelect:focus, #themeSelect:focus, #longTextSelect:focus, #fontFamilySelect:focus,
    #gameInternalControlsBar .game-control-select:focus {
         border-color: var(--accent-active); box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px; margin-bottom: 18px; padding: 10px 18px;
      background-color: rgba(var(--accent-rgb), 0.03);
      border-radius: var(--border-radius-small); font-size: 0.92em; color: var(--text-secondary);
      border: 1px solid rgba(var(--accent-rgb), 0.1); box-shadow: var(--shadow-inset);
      transition: opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease, padding 0.4s ease, visibility 0.4s ease, border-width 0.4s ease, border-radius 0.3s ease;
      max-height: 200px; overflow: hidden;
    }
    #stats.hidden {
        opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0;
        margin-bottom: 0; border-width: 0; visibility: hidden;
    }
    .light-theme #stats { background-color: rgba(var(--accent-rgb), 0.05); border-color: rgba(var(--accent-rgb), 0.12); }
    .pink-theme #stats { background-color: rgba(var(--accent-rgb), 0.06); border-color: rgba(var(--accent-rgb), 0.15); }
    #stats span { text-align: center; padding: 5px 5px; }
    #stats .label {
        color: var(--text-secondary); font-weight: 500; display: block;
        margin-bottom: 6px; font-size: 0.88em; text-transform: uppercase; letter-spacing: 0.5px;
    }
    #stats .value { color: var(--accent-primary); font-weight: 600; font-size: 1.2em; font-family: var(--font-ui); line-height: 1.1; }
    .light-theme #stats .value, .pink-theme #stats .value { color: var(--accent-darker); }
    .progress-bar-container {
        width: 100%; max-width: 700px; height: 5px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 2.5px; margin: 8px auto 12px;
        overflow: hidden; display: none;
    }
    .progress-bar {
        height: 100%; width: 0%;
        background-color: var(--bg-progress-bar);
        border-radius: 2.5px; transition: width 0.25s ease-out;
    }
     #lbb-timer-bar-container {
        width: 80%; max-width: 500px; height: 10px;
        background-color: var(--bg-progress-bar-track);
        border-radius: 5px; margin: 15px auto 10px;
        overflow: hidden;
        position: relative;
    }
    #lbb-timer-bar {
        height: 100%; width: 100%;
        background-color: var(--accent-primary);
        border-radius: 5px;
        transition: width 0.1s linear;
    }
    #lbb-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        color: var(--button-text-on-accent);
        font-weight: bold;
        text-shadow: 0 0 2px rgba(0,0,0,0.5);
        pointer-events: none;
    }
    .light-theme #lbb-timer-bar { background-color: var(--accent-darker); }
    .light-theme #lbb-timer-text { color: var(--button-text-on-accent); }
    .pink-theme #lbb-timer-bar { background-color: var(--accent-active); }
    .pink-theme #lbb-timer-text { color: #fff; }
    .typing-area-container {
        padding: 20px 25px 28px; background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        flex-grow: 1; display: flex; flex-direction: column; font-family: var(--font-typing);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main); min-height: 330px;
        transition: background-color 0.3s ease, border-color 0.3s ease, border-radius 0.3s ease;
    }
    .light-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme .typing-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    #practice-title-display {
    font-family: var(--font-typing);
    font-size: 1.3em;  /* <<< 글씨 크기를 1.1em에서 1.3em으로 키웠습니다. */
    font-weight: 600;  /* <<< 굵기를 조금 더 주어 제목 느낌을 강조했습니다. */
    color: var(--accent-secondary);
    text-align: center;
    margin-top: 0;
    margin-bottom: 12px; /* <<< 제목과 본문 사이의 간격을 조금 더 확보했습니다. */
    padding: 2px 10px;
    min-height: 1.2em;
}
    #line-display-area {
        display: flex; flex-direction: column; align-items: center;
        margin-bottom: 0px; width: 100%;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 8px) * 2);
    }
        .typing-line {
        width: 100%; max-width: 800px;
        padding-left: 16px;
        padding-right: 16px;
        margin: 1px auto;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing); 
        font-weight: 400;
        line-height: var(--line-height-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        box-sizing: border-box;
        border-radius: var(--border-radius-small);
        border: 1px solid transparent;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        padding-top: 12px;
        padding-bottom: 12px;
        transition: opacity 0.3s ease, font-size 0.2s ease, color 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease, border-radius 0.3s ease;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        background-color: transparent;
        white-space: pre-wrap;
        text-align: center;
        /* display: flex 와 하위 속성 제거 */
    }
    .typing-line > span {
        display: inline-block; /* text-align: center의 영향을 받도록 */
        text-align: left;
    }
    .whitespace-char {
        color: var(--text-secondary);
        opacity: 0.6;
        user-select: none;
        font-weight: bold;
    }
    .typing-line strong,
    .typing-line .untyped-char,
    .typing-line .highlight {
       font-family: inherit;
       font-size: inherit;
       line-height: inherit;
       font-weight: 400;
       vertical-align: baseline;
       letter-spacing: inherit;
       word-spacing: inherit;
    }
    .typing-line strong {
        color: var(--current-line-typed-text);
    }
    .typing-line .untyped-char {
        opacity: 0.7;
        color: var(--text-secondary);
    }
    .typing-line.passed, #upcoming-lines-area .typing-line {
        color: var(--text-secondary); opacity: 0.55; 
        font-size: calc(var(--font-size-typing) * 0.92);
        background-color: transparent !important; border: none !important; box-shadow: none !important;
    }
    .light-theme .typing-line.passed, .light-theme #upcoming-lines-area .typing-line,
    .pink-theme .typing-line.passed, .pink-theme #upcoming-lines-area .typing-line { color: var(--text-secondary); opacity: 0.7; }
    .typing-line.current-to-type {
        color: var(--current-line-text); background-color: var(--current-line-bg);
        border: 1px solid var(--current-line-border);
        margin-bottom: 6px;
        box-shadow: var(--current-line-shadow); transform: scale(1.0);
    }
    .light-theme .typing-line.current-to-type strong, .pink-theme .typing-line.current-to-type strong { color: var(--accent-darker); }
    .light-theme .typing-line.current-to-type .untyped-char, .pink-theme .typing-line.current-to-type .untyped-char { color: var(--text-secondary); opacity: 0.85; }
    #typing-input-field-container {
        width: 100%;
        max-width: 800px;
        margin: 2px auto 0 auto;
        position: relative;
    }
    #typing-input-field {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        margin: 0;
        background: transparent;
    }
    .fake-input-field {
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        padding: 12px 16px;
        min-height: calc(var(--font-size-typing) * var(--line-height-typing) + 24px + 2px);
        height: auto;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-radius 0.3s ease;
        box-shadow: var(--shadow-inset);
        cursor: text;
        white-space: pre-wrap;
        box-sizing: border-box;
        font-family: var(--font-typing);
        font-size: var(--font-size-typing);
        letter-spacing: var(--typing-letter-spacing);
        word-spacing: var(--typing-word-spacing);
        line-height: var(--line-height-typing);
        font-weight: 400;
        font-synthesis: none;
        font-kerning: normal;
        text-rendering: optimizeLegibility;
        width: 100%;
        text-align: left;
        /* display: flex 와 하위 속성 제거 */
    }
    .fake-input-field > span {
        text-align: left;
        white-space: pre-wrap;
    }
    #typing-input-field:focus + .fake-input-field {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.25);
        background-color: var(--input-bg); outline: none;
    }
    .light-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.15); }
    .pink-theme #typing-input-field:focus + .fake-input-field { box-shadow: var(--input-focus-shadow), var(--shadow-inset), 0 0 0 2px rgba(var(--accent-rgb), 0.2); }
    .fake-input-field .placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
    }
    #cursor {
        display: inline-block;
        width: 1px;
        height: calc(var(--font-size-typing) * 1.2);
        background-color: var(--accent-primary);
        animation: blink 1s step-end infinite;
        vertical-align: text-bottom;
        margin-left: -1px;
    }
    @keyframes blink {
      from, to { background-color: transparent; }
      50% { background-color: var(--accent-primary); }
    }
    .highlight {
        font-weight: 400 !important;
        color: var(--highlight-error) !important;
        background-color: var(--highlight-error-bg);
        border-radius: 3px; padding: 0.5px 0; margin: -0.5px 0;
    }
    .light-theme .highlight { box-shadow: 0 0 4px rgba(211, 84, 109, 0.15); }
    .pink-theme .highlight { box-shadow: 0 0 4px rgba(255, 99, 71, 0.2); }
    #result {
        padding: 15px 20px; text-align: center; color: var(--accent-primary);
        font-size: 1.05em; min-height: 1.4em; font-weight: 500;
    }
    .light-theme #result, .pink-theme #result { color: var(--accent-darker); }
    .footer {
        text-align: center; padding: 25px 15px; color: var(--text-secondary);
        font-size: 0.9em; margin-top: auto; border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    }
    .light-theme .footer { border-top-color: rgba(var(--accent-rgb),0.15); }
        .pink-theme .footer { border-top-color: rgba(var(--accent-rgb),0.2); }
    .footer a { color: var(--accent-secondary); text-decoration: none; font-weight: 400; }
    .footer a:hover { color: var(--accent-primary); text-decoration: underline; }
    .footer .contact-info { margin-top: 10px; }
    #copyEmailBtn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.9em;
      padding: 2px 6px;
      vertical-align: middle;
      transition: color 0.2s ease-in-out;
    }
    #copyEmailBtn:hover {
      color: var(--accent-primary);
    }
    #game-area-container {
        display: none;
        background-color: var(--bg-typing-area);
        border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
        border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
        flex-grow: 1; text-align: center;
        flex-direction: column; align-items: center;
        transition: border-radius 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        width: 100%; box-sizing: border-box;
        position: relative;
    }
    .light-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.15); }
    .pink-theme #game-area-container { border-top-color: rgba(var(--accent-rgb),0.2); }
    .game-ui-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0 15px 5px;
        box-sizing: border-box;
        position: relative;
        flex-grow: 1;
    }
     #game-start-message {
        position: absolute;
        top: calc(50% + 10px);
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.92);
        padding: 25px;
        border-radius: var(--border-radius-main);
        text-align: center;
        z-index: 5;
        color: var(--text-primary);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90%;
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
    }
    .light-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.96); border-color: rgba(var(--accent-rgb), 0.25); }
    .pink-theme #game-start-message { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.98); border-color: rgba(var(--accent-rgb), 0.3); }
    #game-start-message h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 1.8em; margin-bottom: 12px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #game-start-message p {
        font-size: 1em; color: var(--text-secondary);
        line-height: 1.6;
        max-width: 420px;
        margin-bottom: 18px;
    }
    .light-theme #game-start-message h2, .pink-theme #game-start-message h2 { color: var(--accent-darker); }
    #game-start-message .item-info { font-size: 0.88em; margin-top: 12px; line-height: 1.8; text-align: left; width: fit-content; }
    #game-start-message .item-info div { margin-bottom: 4px; }
    #game-start-message .item-info span { display: inline-block; width: 12px; height: 12px; margin-right: 6px; border-radius: 3px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.2); }
    #game-start-message .item-info .item-icon { font-size: 1em; vertical-align: middle; margin-right: 4px; display: inline-block; width: 12px; text-align: center;}
    #game-canvas {
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small);
        margin-bottom: 8px;
        width: 100%;
        transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        touch-action: none;
        -ms-touch-action: none;
    }
    #game-input-field {
        width: 80%; max-width: 500px; padding: 12px 15px;
        font-family: var(--font-ui); font-size: 1.1rem;
        background-color: var(--input-bg); color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: var(--border-radius-small); box-shadow: var(--shadow-inset);
        text-align: center; outline: none;
        margin-bottom: 8px;
    }
    #game-input-field:focus {
        border-color: var(--accent-active);
        box-shadow: var(--input-focus-shadow), var(--shadow-inset);
    }
    #gameInternalControlsBar {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 10px 0;
        width: 100%;
        max-width: 600px;
    }
    .game-control-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    .game-control-row .game-control-item,
    .game-control-row .sound-settings,
    .game-control-row .theme-settings,
    #gameToggleSoundBtn,
    #returnToPracticeBtnGame {
        display: flex;
        align-items: center;
        gap: 5px;
        flex: 1 1 calc(33.333% - 10px);
        justify-content: center;
        min-width: 120px;
        box-sizing: border-box;
    }
    .game-control-item .select-label { margin-right: 5px; white-space: nowrap;}
    .game-control-item .game-control-select,
    #gameToggleSoundBtn { flex-grow: 1; }
    #returnToPracticeBtnGame {
      padding: 12px 24px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 600;
      font-size: 0.95em;
      color: var(--accent-primary);
      border: 2px solid rgba(var(--accent-rgb), 0.4);
      background-color: transparent;
      transition: all 0.25s ease;
      box-shadow: 0 0 0 2px rgba(var(--accent-rgb), 0.1);
    }
    #returnToPracticeBtnGame:hover {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-active);
      box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.25);
    }
    .game-type-button {
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: var(--border-radius-small);
        cursor: pointer;
        font-family: var(--font-ui);
        border: 1.5px solid var(--accent-secondary);
        background: transparent;
        color: var(--accent-secondary);
        flex: 1;
        text-align: center;
        transition: all 0.2s ease-in-out;
    }
    .game-type-button:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        transform: translateY(-1px);
    }
    .game-type-button.active {
        background: var(--accent-primary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-primary);
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(var(--accent-rgb),0.15);
    }
    .game-type-button.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .game-type-button.disabled:hover {
        background: transparent;
        color: var(--accent-secondary);
        transform: translateY(0);
    }
    .game-type-button i {
        margin-right: 6px;
    }
    #gameToggleSoundBtn {
      padding: 10px 16px;
      border-radius: 999px;
      font-family: var(--font-ui);
      font-weight: 500;
      font-size: 0.9em;
      border: 1.5px solid var(--accent-secondary);
      background-color: transparent;
      color: var(--accent-secondary);
      transition: all 0.25s ease;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: var(--shadow-button);
    }
    #gameToggleSoundBtn.active {
      background-color: var(--accent-primary);
      color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
      font-weight: 600;
    }
    #gameToggleSoundBtn i { margin-right: 5px;}
    .game-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(var(--bg-container-rgb, 42, 40, 38), 0.88);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        padding: 25px;
        box-sizing: border-box;
        border-radius: var(--border-radius-main);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
    }
    .light-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 255, 255), 0.92); }
    .pink-theme .game-overlay { background-color: rgba(var(--bg-container-rgb, 255, 245, 248), 0.95); }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        .game-overlay {
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
    }
    .game-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .result-card {
        background-color: var(--bg-container);
        padding: 25px 35px;
        border-radius: var(--border-radius-main);
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        max-width: 500px;
        width: 90%;
    }
    .result-card h2 {
        font-family: var(--font-heading); color: var(--accent-primary);
        font-size: 2.2em; margin: 0 0 15px;
        text-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    .result-card-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 25px;
        text-align: left;
    }
    .result-card-stats .stat-item {
        font-size: 1.1em;
    }
    .result-card-stats .stat-item .label {
        color: var(--text-secondary);
        font-size: 0.9em;
        margin-right: 8px;
    }
     .result-card-stats .stat-item .value {
        color: var(--text-primary);
        font-weight: 600;
        font-family: var(--font-ui);
    }
    .result-card .result-buttons {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }
    .light-theme .result-card h2, .pink-theme .result-card h2 { color: var(--accent-darker); }
    .game-button {
        padding: 12px 25px; font-size: 1em;
        border-radius: var(--border-radius-small); cursor: pointer;
        transition: all 0.2s ease-in-out; font-family: var(--font-ui);
        font-weight: 600; letter-spacing: 0.5px; outline: none;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1.5px solid var(--accent-primary);
        background: var(--accent-primary); color: var(--button-text-on-accent);
        text-shadow: none; box-shadow: var(--shadow-button); margin: 0;
    }
    .game-button:hover {
        background: var(--accent-active); border-color: var(--accent-active);
        transform: translateY(-2px); box-shadow: var(--shadow-button-hover);
    }
    .game-button.secondary {
        background: transparent;
        color: var(--accent-secondary);
        border-color: var(--accent-secondary);
    }
    .game-button.secondary:hover {
        background: var(--accent-secondary);
        color: var(--button-text-on-accent);
        border-color: var(--accent-secondary);
    }
    .game-button i { margin-right: 8px; }
    .light-theme .game-button, .pink-theme .game-button {
      background: var(--accent-primary); color: var(--button-text-on-accent);
      border-color: var(--accent-primary);
    }
    .light-theme .game-button:hover, .pink-theme .game-button:hover {
      background: var(--accent-active); border-color: var(--accent-active);
    }
    #gameHelpBtn {
        position: absolute;
        top: 15px;
        left: 15px;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background-color: rgba(var(--bg-main-rgb, 32, 30, 28), 0.7);
        color: var(--text-secondary);
        border: 1px solid var(--input-border);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.1em;
        z-index: 20;
        transition: all 0.2s ease;
    }
    #gameHelpBtn:hover {
        background-color: var(--accent-primary);
        color: var(--button-text-on-accent);
    }
    .light-theme #gameHelpBtn {
        background-color: rgba(var(--bg-main-rgb, 253, 250, 246), 0.8);
    }
    #helpModal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s, visibility 0s 0.3s;
    }
    @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {
        #helpModal {
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
    }
    #helpModal.visible {
        opacity: 1; visibility: visible;
        transition: opacity 0.3s, visibility 0s 0s;
    }
    .help-modal-content {
        background-color: var(--bg-container);
        padding: 30px;
        border-radius: var(--border-radius-main);
        max-width: 500px;
        width: 90%;
        box-shadow: var(--shadow-soft);
        border: 1px solid rgba(var(--accent-primary-rgb), 0.2);
        position: relative;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    #helpModal.visible .help-modal-content {
        transform: scale(1);
    }
    .help-modal-close {
        position: absolute;
        top: 15px; right: 15px;
        font-size: 1.5em;
        color: var(--text-secondary);
        cursor: pointer;
        transition: color 0.2s;
    }
    .help-modal-close:hover {
        color: var(--accent-primary);
    }
    .help-modal-content h2 {
        font-family: var(--font-heading);
        color: var(--accent-primary);
        margin-top: 0;
        margin-bottom: 15px;
    }
    .help-modal-content p, .help-modal-content div {
        color: var(--text-secondary);
        line-height: 1.7;
    }
     .help-modal-content .item-info {
        font-size: 0.9em; margin-top: 15px;
    }
    .help-modal-content .item-info div { margin-bottom: 5px; }
    
    @media (max-width: 768px) {
      .hero-title { font-size: 2.2em; }
      .hero-tagline { font-size: 0.9em; max-width: 90%;}
      body:not(.game-mode-active) .practice-mode-controls,
      body:not(.game-mode-active) .feature-toggles,
      body:not(.game-mode-active) .language-settings,
      body:not(.game-mode-active) .sound-settings,
      body:not(.game-mode-active) .theme-settings,
      body:not(.game-mode-active) .long-text-settings,
      body:not(.game-mode-active) .font-family-settings { width: 100%; justify-content: center; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect { min-width: 0; width: auto; flex-grow: 1; max-width: 180px; }
      .controls-and-stats-wrapper { padding: 20px 15px 10px; }
      .typing-area-container { padding: 15px 15px 20px; min-height: 280px; }
      .typing-line,
      .fake-input-field,
      #freestyle-input-area {
          font-size: var(--font-size-typing-mobile);
          letter-spacing: var(--typing-letter-spacing-mobile);
          word-spacing: var(--typing-word-spacing-mobile);
      }
      #cursor { height: calc(var(--font-size-typing-mobile) * 1.2); }
      #stats { grid-template-columns: repeat(2, 1fr); font-size: 0.88em; }
      #stats .value { font-size: 1.1em; }
      .game-ui-wrapper { padding: 10px 10px 5px; }
      #game-start-message { top: 50%; padding: 20px; }
      #game-start-message h2 { font-size: 1.5em; }
      #game-start-message p { font-size: 0.9em; }
      .result-card h2 { font-size: 1.6em; }
      .result-card-stats { font-size: 1em; }
      #game-input-field { font-size: 1rem; padding: 10px; margin-bottom: 5px; }
      .game-button { font-size: 0.9em; padding: 10px 20px; }
      #gameInternalControlsBar { gap: 8px; }
      .game-control-row { flex-wrap: wrap; justify-content: space-evenly; }
      .game-control-item, #gameToggleSoundBtn { flex-basis: auto; min-width: 150px; margin-bottom: 5px;}
      #gameToggleSoundBtn { flex-basis: auto; min-width: 130px; }
      .language-settings, .sound-settings, .theme-settings, .long-text-settings, .font-family-settings { flex-grow: 0; }
      #returnToPracticeBtnGame { flex-basis: 100%; margin-top: 10px; }
      #game-canvas { height: Math.max(window.innerHeight * 0.48, 300px); margin-bottom: 5px;}
       #lbb-timer-bar-container { height: 8px; margin: 5px auto 8px; }
    }
     @media (max-width: 480px) {
      .hero-title { font-size: 1.9em; }
      .hero-tagline { font-size: 0.85em; }
      .control-button-group button { font-size: 0.85em; padding: 8px 12px; }
      .select-label { font-size: 0.85em; }
      #languageSelect,
      #gameInternalControlsBar .game-control-select,
      #soundPackSelect, #themeSelect, #longTextSelect, #fontFamilySelect { font-size: 0.85em; padding: 8px 10px; }
      .typing-line,
      .fake-input-field,
      #freestyle-input-area {
          font-size: var(--font-size-typing-mobile);
      }
      #stats { padding: 10px 12px; }
      #stats span { padding: 6px 4px;}
      #stats .label { font-size: 0.8em; margin-bottom: 4px; }
      #stats .value { font-size: 1em; }
      #game-start-message { padding: 15px; }
      #game-start-message h2 { font-size: 1.3em; }
      #game-start-message p { font-size: 0.85em; }
      #game-start-message .item-info { font-size: 0.8em; }
      .result-card h2 { font-size: 1.4em; }
      .result-card-stats { font-size: 0.9em; }
      .game-button { font-size: 0.85em; padding: 8px 15px; }
      .game-control-row { flex-direction: column; align-items: stretch; }
      .game-control-item, #gameToggleSoundBtn { width: 100%; justify-content: flex-start; }
      #gameToggleSoundBtn { justify-content: center; }
      #returnToPracticeBtnGame { width: 100%; max-width: none; }
      #game-canvas { height: Math.max(window.innerHeight * 0.45, 280px); }
      #lbb-timer-bar-container { height: 6px; margin: 3px auto 5px; }
      #lbb-timer-text {font-size: 0.6em;}
     }
.hero-section a {
  display: inline-block;
  transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
  text-decoration: none;
  border-radius: var(--border-radius-small);
  padding: 18px;
}
.hero-section a:hover {
  transform: scale(1.03);
}
.hero-section a:hover .hero-title {
  color: var(--accent-active);
  text-shadow: 0 0 18px rgba(var(--accent-primary-rgb), 0.45), 0 2px 5px rgba(0,0,0,0.6);
}
.hero-section a:hover .hero-tagline {
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
}
.light-theme .hero-section a:hover .hero-title,
.pink-theme .hero-section a:hover .hero-title {
  color: var(--accent-primary);
  text-shadow: 0 0 15px rgba(var(--accent-rgb),0.3), 0 1px 3px rgba(0,0,0,0.15);
}
.light-theme .hero-section a:hover .hero-tagline,
.pink-theme .hero-section a:hover .hero-tagline {
  color: var(--text-secondary);
  text-shadow: 0 1px 3px rgba(100,50,60,0.12);
}
#keyboard-guide {
    display: none;
    margin-bottom: 25px;
    padding: 15px;
    background-color: var(--bg-main);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-inset);
    user-select: none;
    transition: background-color 0.3s ease;
    width: 100%;
    max-width: 900px;
    box-sizing: border-box;
    align-self: center;
}
#keyboard-guide.visible {
    display: block;
}
.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}
.keyboard-row:last-child {
    margin-bottom: 0;
}
.keys-wrapper {
    display: flex;
    width: fit-content;
}
.row-1 .keys-wrapper, .row-2 .keys-wrapper, .row-3 .keys-wrapper, .row-4 .keys-wrapper {
    transform: translateX(0);
}
.keyboard-key {
    font-family: var(--font-ui);
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--bg-typing-area);
    border: 1px solid var(--input-border);
    border-bottom-width: 3px;
    border-radius: 5px;
    padding: 5px;
    margin: 0 4px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    text-align: center;
    line-height: 1.2;
    font-size: 0.95em;
    box-sizing: border-box;
    transition: all 0.1s ease;
    flex-shrink: 0;
    min-width: 50px;
}
.keyboard-key .key-main-char {
    font-weight: 500;
    font-size: 1.1em;
    color: var(--text-primary);
    margin-top: auto;
    margin-bottom: auto;
}
.keyboard-key .key-shift-char {
    font-size: 0.8em;
    opacity: 0.7;
    color: var(--text-secondary);
    align-self: flex-start;
    padding-left: 2px;
}
#keyboard-guide.lang-kor .key-eng,
#keyboard-guide.lang-eng .key-kor,
#keyboard-guide.lang-js .key-kor,
#keyboard-guide.lang-python .key-kor {
    display: none;
}
#keyboard-guide.lang-kor .key-kor .key-main-char { font-size: 1.2em; }
#keyboard-guide.lang-eng .key-eng .key-main-char,
#keyboard-guide.lang-js .key-eng .key-main-char,
#keyboard-guide.lang-python .key-eng .key-main-char { 
    font-size: 1.2em; 
}
.keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.18);
}
.light-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.15);
}
.pink-theme .keyboard-key.home-row-base {
    background-color: rgba(var(--accent-rgb), 0.12);
}
.keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 8px rgba(var(--accent-rgb), 0.2);
}
.keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
    font-weight: 700;
    opacity: 1;
}
.light-theme .keyboard-key.highlight-key,
.pink-theme .keyboard-key.highlight-key {
    background-color: var(--accent-primary);
    color: var(--button-text-on-accent);
    border-color: var(--accent-active);
}
.light-theme .keyboard-key.highlight-key *,
.pink-theme .keyboard-key.highlight-key * {
    color: var(--button-text-on-accent);
}
.keyboard-key.special-key {
    font-size: 0.8em;
    font-weight: 400;
    text-align: center;
    line-height: 50px;
}
.key-width-1-5x { min-width: 80px; }
.key-width-1-75x { min-width: 95px; }
.key-width-2x { min-width: 110px; }
.key-width-2-25x { min-width: 125px; }
.key-width-2-5x { min-width: 135px; }
.key-width-space { min-width: 332px; flex-grow: 1; }
#freestyle-area-container {
    padding: 20px 25px 28px;
    background-color: var(--bg-typing-area);
    border-top: 1px solid rgba(var(--accent-primary-rgb), 0.1);
    flex-grow: 1;
    display: none;
    flex-direction: column;
    border-radius: 0 0 var(--border-radius-main) var(--border-radius-main);
    min-height: 400px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
}

body.layout-collapsed.freestyle-mode-active #freestyle-area-container {
    margin-top: 40px;
}

body.layout-collapsed.freestyle-mode-active .main-content {
    flex-grow: 1;
}

#freestyle-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    position: relative;
    align-items: center;
}
.freestyle-tool-group {
    display: flex;
    gap: 8px;
    align-items: center;
}
.toolbar-divider {
    width: 1px;
    height: 20px;
    background-color: var(--input-border);
    margin: 0 4px;
}
.freestyle-tool-btn {
    background-color: var(--input-bg);
    color: var(--text-secondary);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 8px 12px;
    font-family: var(--font-ui);
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.freestyle-tool-btn:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
    border-color: var(--accent-secondary);
}
.freestyle-tool-btn i {
    margin-right: 6px;
    width: 14px;
    text-align: center;
}
#focusModeBtn { margin-left: auto; }
#emoji-picker {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    transform: translateY(5px);
    background-color: var(--bg-container);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    padding: 10px;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    z-index: 10;
}
#emoji-picker.visible {
    display: grid;
}
#emoji-picker span {
    font-size: 1.4em;
    cursor: pointer;
    text-align: center;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
#emoji-picker span:hover {
    background-color: var(--bg-main);
}
#freestyle-input-area {
    width: 100%;
    flex-grow: 1;
    min-height: 300px;
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 15px;
    font-family: var(--font-typing);
    font-size: var(--font-size-typing);
    line-height: var(--line-height-typing);
    letter-spacing: var(--typing-letter-spacing);
    word-spacing: var(--typing-word-spacing);
    font-synthesis: none;
    font-kerning: normal;
    text-rendering: optimizeLegibility;
    resize: both;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    box-sizing: border-box;
}
#freestyle-input-area:focus {
    outline: none;
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#freestyle-input-area::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
    transition: opacity 0.3s;
}
#freestyle-input-area:focus::placeholder {
    opacity: 0.3;
}
#freestyle-stats-bar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 15px;
    padding: 8px 5px;
    font-size: 0.85em;
    color: var(--text-secondary);
    font-family: var(--font-ui);
}
.freestyle-download-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin-top: 15px;
}
#freestyle-filename-input {
    background-color: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-small);
    padding: 10px 12px;
    font-family: var(--font-ui);
    font-size: 0.9em;
    outline: none;
    box-shadow: var(--shadow-inset);
    transition: all 0.2s ease;
    width: 200px;
}
#freestyle-filename-input:focus {
    border-color: var(--accent-active);
    box-shadow: var(--input-focus-shadow), var(--shadow-inset);
}
#download-freestyle-btn {
    padding: 10px 20px;
    font-size: 0.9em;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    border: 1.5px solid var(--accent-primary);
    background: var(--accent-primary);
    color: var(--button-text-on-accent);
    box-shadow: var(--shadow-button);
    transition: all 0.2s ease;
}
#download-freestyle-btn:hover {
    background: var(--accent-active);
    border-color: var(--accent-active);
    transform: translateY(-1px);
    box-shadow: var(--shadow-button-hover);
}
#download-freestyle-btn i {
    margin-right: 8px;
}
#shortcut-help-container {
    position: fixed;
    bottom: 25px;
    right: 25px;
    z-index: 1000;
    font-size: 1.6em;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s ease;
}
#shortcut-help-container:hover {
    color: var(--accent-primary);
}
#shortcut-help-container:hover .shortcut-tooltip {
    opacity: 1;
    visibility: visible;
    transform: translate(-5px, -5px);
}
.shortcut-tooltip {
    position: absolute;
    bottom: 110%;
    right: 110%;
    background-color: var(--bg-container);
    color: var(--text-secondary);
    padding: 15px 20px;
    border-radius: var(--border-radius-small);
    box-shadow: var(--shadow-soft);
    font-size: 0.55em;
    line-height: 1.7;
    width: 210px;
    opacity: 0;
    visibility: hidden;
    transform: translate(0, 0);
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
    border: 1px solid var(--input-border);
}
.shortcut-tooltip.show-temporarily {
    opacity: 1;
    visibility: visible;
    transform: translate(-5px, -5px);
}
.shortcut-tooltip strong {
    color: var(--accent-primary);
    font-size: 1.15em;
    font-weight: 600;
    display: block;
    margin-bottom: 10px;
    text-align: center;
}
.shortcut-tooltip p {
    margin: 0 0 8px 0;
}
.shortcut-tooltip p:last-child {
    margin-bottom: 0;
}
.shortcut-tooltip b {
    color: var(--text-primary);
    background-color: var(--bg-main);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--input-border);
    margin-right: 8px;
    font-family: var(--font-typing);
}
@media (max-width: 920px) {
    #keyboard-guide { max-width: 100%; }
    .keyboard-key { min-width: 42px; margin: 0 3px;}
    .key-width-1-5x { min-width: 68px; }
    .key-width-1-75x { min-width: 78px; }
    .key-width-2x { min-width: 88px; }
    .key-width-2-25x { min-width: 108px; }
    .key-width-2-5x { min-width: 118px; }
    .key-width-space { min-width: 278px; }
}
@media (max-width: 480px) {
    #freestyle-download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    #freestyle-filename-input, #download-freestyle-btn {
        width: 100%;
        box-sizing: border-box;
    }
    #freestyle-toolbar {
        flex-direction: column;
        align-items: stretch;
    }
    .freestyle-tool-group {
        justify-content: space-around;
    }
    #focusModeBtn { margin-left: 0; }
}

</style>
</head>
<body class="">
  <div class="main-content-wrapper">
    <div class="layout-toggle-container">
        <button id="toggleLayoutBtn"><i class="fas fa-chevron-up"></i> 메뉴 숨기기</button>
    </div>
    <div class="main-content">
      <div class="hero-section">
          <a href="https://www.youtube.com/@KeyTherapy" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: inline-block;">
              <h1 class="hero-title">Key Therapy</h1>
              <p class="hero-tagline">깊은 수면과 집중을 위한<br>🎧키보드 타건 ASMR🎧</p>
          </a>
      </div>
      <div class="controls-and-stats-wrapper">
        <div class="settings-container">
            <div class="main-controls">
                <div class="practice-mode-controls control-button-group">
                    <button data-practice-type="short"><i class="fas fa-language"></i> 단문 연습</button>
                    <button data-practice-type="long"><i class="fas fa-align-left"></i> 장문 연습</button>
                    <button data-practice-type="freestyle"><i class="fas fa-pencil-alt"></i> 글쓰기</button>
                    <button id="gameModeBtn"><i class="fas fa-gamepad"></i> 게임하기</button>
                </div>
                <div class="feature-toggles control-button-group">
                    <button id="toggleSoundBtn"><i class="fas fa-volume-mute"></i> 타건음 OFF</button>
                    <button id="toggleHighlightBtn" class="active"><i class="fas fa-highlighter"></i> 오타체크 ON</button>
                    <!-- ==================== ▼▼▼ 1. HTML 버튼 추가 ▼▼▼ ==================== -->
                    <button id="toggleAutoCompleteBtn"><i class="fas fa-magic"></i> 특수기호 자동완성 OFF</button>
                    <!-- ==================== ▲▲▲ 1. HTML 버튼 추가 ▲▲▲ ==================== -->
                    <button id="toggleStatsBtn" class="active"><i class="fas fa-chart-line"></i> 측정 ON</button>
                    <button id="toggleKeyboardGuideBtn"><i class="far fa-keyboard"></i> 자리연습 OFF</button>
                </div>
                <div class="selection-controls">
                    <div class="language-settings">
                        <label for="languageSelect" class="select-label" id="languageSelectLabel">언어:</label>
                        <select id="languageSelect">
                            <option value="kor">한글</option>
                            <option value="eng">영어</option>
                            <option value="js">JavaScript</option>
                            <option value="python">Python</option>
                        </select>
                    </div>
                    <div class="long-text-settings hidden" id="longTextSelectContainer">
                        <label for="longTextSelect" class="select-label">글 선택:</label>
                        <select id="longTextSelect"></select>
                    </div>
                    <div class="sound-settings" id="soundSettingsElement">
                        <label for="soundPackSelect" class="select-label" id="soundPackLabel">타건음:</label>
                        <select id="soundPackSelect"></select>
                    </div>
                    <div class="theme-settings" id="themeSettingsElement">
                        <label for="themeSelect" class="select-label" id="themeSelectLabel">테마:</label>
                        <select id="themeSelect">
                            <option value="dark">다크</option>
                            <option value="light">아이보리</option>
                            <option value="pink">핑크</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div id="stats">
            <span><span class="label">속도:</span> <span id="speedStat" class="value">0 타/분</span></span>
            <span><span class="label">정확도:</span> <span id="accuracyStat" class="value">0%</span></span>
            <span><span class="label">평균:</span> <span id="avgSpeedStat" class="value">0 타/분</span></span>
            <span><span class="label">최고:</span> <span id="maxSpeedStat" class="value">0 타/분</span></span>
        </div>
      </div>
      <div class="progress-bar-container">
          <div class="progress-bar"></div>
      </div>
      <div class="typing-area-container">
          <div id="keyboard-guide"></div>
          <h3 id="practice-title-display"></h3>
          <div id="line-display-area"> </div>
          <div id="typing-input-field-container">
              <input type="text" id="typing-input-field" autocomplete="off" autocapitalize="off" spellcheck="false" >
              <div class="fake-input-field" id="fake-input-field" aria-hidden="true"></div>
          </div>
          <div id="upcoming-lines-area"> </div>
      </div>
      <div id="freestyle-area-container">
          <div id="freestyle-toolbar">
              <div class="freestyle-tool-group">
                  <button id="insertDateBtn" class="freestyle-tool-btn" title="오늘 날짜 삽입"><i class="fas fa-calendar-alt"></i></button>
                  <button id="insertTimeBtn" class="freestyle-tool-btn" title="현재 시간 삽입"><i class="fas fa-clock"></i></button>
                  <button id="emojiBtn" class="freestyle-tool-btn" title="이모티콘"><i class="far fa-smile"></i></button>
                   <div id="emoji-picker">
                      <span>😊</span><span>😂</span><span>😍</span><span>🤔</span><span>👍</span><span>❤️</span>
                      <span>🎉</span><span>✨</span><span>🔥</span><span>😭</span><span>🙏</span><span>⭐</span>
                  </div>
              </div>
              <div class="toolbar-divider"></div>
              <div class="freestyle-tool-group">
                  <button id="copyAllBtn" class="freestyle-tool-btn" title="전체 내용 복사"><i class="far fa-copy"></i></button>
                  <button id="clearAllBtn" class="freestyle-tool-btn" title="전체 삭제"><i class="fas fa-trash-alt"></i></button>
                  <button id="insertHrBtn" class="freestyle-tool-btn" title="구분선 삽입"><i class="fas fa-minus"></i></button>
              </div>
          </div>
          <textarea id="freestyle-input-area" placeholder="오늘 하루는 어땠나요? 당신의 이야기를 자유롭게 기록해보세요..."></textarea>
          <div id="freestyle-stats-bar">
              <span id="charCount">0자</span>
              <span id="wordCount">0단어</span>
          </div>
          <div class="freestyle-download-controls">
              <input type="text" id="freestyle-filename-input" placeholder="파일 이름 (선택사항)">
              <button id="download-freestyle-btn"><i class="fas fa-download"></i> 텍스트 파일로 저장</button>
          </div>
      </div>
      <div id="game-area-container">
      </div>
      <div id="result"></div>
    </div>
  </div>
  <div class="footer"> 
    <p>© 2024 Key Therapy. All rights reserved. <br> Designed for focused typing practice and relaxation.</p> 
    <p class="contact-info">
      문의: <a href="mailto:keytherapy@naver.com">keytherapy@naver.com</a>
      <button id="copyEmailBtn" title="이메일 주소 복사"><i class="far fa-copy"></i></button>
    </p>
  </div>

  <div id="helpModal">
    <div class="help-modal-content">
      <span class="help-modal-close">×</span>
      <div id="helpModalBody"></div>
    </div>
  </div>

  <div id="result-share-popup" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--accent-active); color: var(--button-text-on-accent); padding: 12px 20px; border-radius: var(--border-radius-small); z-index: 1001; box-shadow: var(--shadow-soft); opacity: 0; transition: opacity 0.3s, transform 0.3s; pointer-events: none;">
      결과가 클립보드에 복사되었습니다!
  </div>

  <div id="shortcut-help-container">
    <div class="shortcut-tooltip">
        <strong>단축키 안내</strong><br>
        <p><b>Esc</b> : 메뉴 숨기기/펼치기</p>
        <p><b>Alt + ↓</b> : 다시 시작</p>
        <p><b>Alt + →</b> : 다음 글</p>
        <p><b>Alt + ←</b> : 이전 글</p>
        <p><b>Alt + M</b> : 타건음 ON/OFF</p>
        <p><b>Alt + '</b> : 다음 타건음</p>
        <p><b>Alt + ;</b> : 이전 타건음</p>
        <p><b>Alt + ,</b> : 오타체크 ON/OFF</p>
        <p><b>Alt + .</b> : 측정 ON/OFF</p>
        <p><b>Alt + /</b> : 자리연습 ON/OFF</p>
    </div>
    <i class="fas fa-question-circle"></i>
  </div>

<script>
let currentMode = '';
let currentGameType = '';
let linesToPractice = [];
let currentDisplayLineIndex = 0;
let disassembledLine = [];

const MAX_VISIBLE_UPCOMING_LINES = 5;

let startTime = null;
let currentLineStartTime = null;
let currentArticleCorrectChars = 0;
let lastArticleSpeed = 0;

let sessionTotalValidChars = 0;
let sessionTotalCorrectChars = 0;
let sessionTotalMistypedChars = 0;
let overallAvgSpeedLog = [];
let overallMaxSpeed = 0;

const KOR_SPEED_FACTOR = 2.1;
let soundEnabled = false;
let highlightEnabled = true;
let statsVisible = true;
let keyboardGuideEnabled = false;
let layoutCollapsed = false;
let autoCompleteEnabled = false; 
let isProgrammaticallyChangingInput = false;
let isComposingNow = false;
let freestyleStatsInterval = null;
let freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl;
let freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker;
let copyAllBtn, clearAllBtn, insertHrBtn;
let charCountEl, wordCountEl;
let longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl;

let languageSelectEl, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, toggleLayoutBtn;
// ==================== ▼▼▼ 2. JS 전역 변수 추가 ▼▼▼ ====================
let toggleAutoCompleteBtn;
// ==================== ▲▲▲ 2. JS 전역 변수 추가 ▲▲▲ ====================
let languageSelectLabelEl;
let progressBarContainerEl, progressBarEl;
let gameAreaContainerEl, gameCanvas, gameCtx, gameInputField, gameStartMessageEl, itemEffectPopupEl;
let gameHelpBtn, helpModal, helpModalBody, helpModalClose;
let gameToggleSoundBtn;
let lbbTimerBarContainerEl, lbbTimerBarEl, lbbTimerTextEl;
let toggleKeyboardGuideBtn, keyboardGuideEl;

const fontConfig = {
    "'Noto Sans KR', sans-serif": { scale: 1.0 },
    "'Gowun Dodum', sans-serif": { scale: 1.05 },
    "'IBM Plex Sans KR', sans-serif": { scale: 1.0 },
    "'Do Hyeon', sans-serif": { scale: 1.0 },
    "'Stylish', sans-serif": { scale: 1.1 },
    "'Nanum Myeongjo', serif": { scale: 1.0 },
    "'Song Myung', serif": { scale: 1.0 },
    "'Yeon Sung', cursive": { scale: 1.0 },
    "'Gaegu', cursive": { scale: 1.2 },
    "'Nanum Pen Script', cursive": { scale: 1.3 },
    "'Hi Melody', cursive": { scale: 1.15 },
    "'Gamja Flower', cursive": { scale: 1.2 },
    "'Cute Font', cursive": { scale: 1.15 },
    "'Single Day', cursive": { scale: 1.1 },
    "'Nanum Brush Script', cursive": { scale: 1.1 },
    "'East Sea Dokdo', cursive": { scale: 1.3 },
    "'Dokdo', cursive": { scale: 1.3 },
    "'Source Code Pro', monospace": { scale: 1.1 },
    "'Courier New', monospace": { scale: 1.1 }
};

let soundSettingsEl, themeSettingsEl;
let originalSoundParent, originalSoundNextSibling;
let originalThemeParent, originalThemeNextSibling;
let mainControlsEl;
let toggleHighlightBtn, lineDisplayArea, typingInputField, resultEl, upcomingLinesArea, statsEl, fakeInputField;
let gameOverlayEl;

function showShortcutTooltipTemporarily() {
    const tooltip = document.querySelector('.shortcut-tooltip');
    if (!tooltip) return;

    tooltip.classList.add('show-temporarily');
    setTimeout(() => {
        tooltip.classList.remove('show-temporarily');
    }, 2000);
}

let soundPlayedForThisInput = false;
let currentSoundPack = '1';
const soundFiles = {};
const totalSoundPacks = 13;
const filesPerPack = 10;

for (let i = 1; i <= totalSoundPacks; i++) {
    const packKey = String(i);
    soundFiles[packKey] = [];
    for (let j = 1; j <= filesPerPack; j++) {
        soundFiles[packKey].push(`soundFiles/${i}/${i} (${j}).wav`);
    }
}

let audioPool = {};
let soundTimer = null;

let rainfall_isGameActive = false;
let rainfall_gameLevel = 1;
let rainfall_currentSubLevelIndex = 0;
let rainfall_gameScore = 0;
let rainfall_gameLives = 0;
let rainfall_wordsOnScreen = [];
let rainfall_usedWordsInLevel = new Set();
let rainfall_gameLoopId = null;
let rainfall_wordGenerationIntervalId = null;
const RAINFALL_INITIAL_LIVES = 5;
const RAINFALL_GAME_FONT = "24px 'Noto Sans KR', sans-serif";
let rainfall_gamePausedForOverlay = false;
let rainfall_levelStartTime = null;
const RAINFALL_LEVEL_DURATION_MS = 120 * 1000;
const RAINFALL_SUB_LEVEL_DURATION_MS = RAINFALL_LEVEL_DURATION_MS / 3;
let rainfall_isTimeStopped = false;
const RAINFALL_ITEM_SPAWN_PROBABILITY = 0.05;

const RAINFALL_ITEM_COLORS = {
    TIME_STOP: '#00BFFF',
    CLEAR_SCREEN: '#C71585',
    EXTRA_LIFE: '#32CD32'
};

const RAINFALL_ITEM_TYPES = {
    TIME_STOP: { type: 'timeStop', color: RAINFALL_ITEM_COLORS.TIME_STOP, duration: 3000, text: '시간', icon: '⏱️' },
    CLEAR_SCREEN: { type: 'clearScreen', color: RAINFALL_ITEM_COLORS.CLEAR_SCREEN, text: '소멸', icon: '💨' },
    EXTRA_LIFE: { type: 'extraLife', color: RAINFALL_ITEM_COLORS.EXTRA_LIFE, text: '생명', icon: '❤️' }
};
const rainfall_gameMainLevelsConfig = [
    { subLevels: [ { fallSpeed: 0.20, genRate: 7000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.01, fastWordMultiplier: 1.3 }, { fallSpeed: 0.22, genRate: 6500, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.2 }, { fallSpeed: 0.26, genRate: 6000, wordMinLen: 2, wordMaxLen: 3, fastWordChance: 0.02, fastWordMultiplier: 1.3 } ] },
    { subLevels: [ { fallSpeed: 0.30, genRate: 5500, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.03, fastWordMultiplier: 1.5 }, { fallSpeed: 0.35, genRate: 5200, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.04, fastWordMultiplier: 1.4 }, { fallSpeed: 0.40, genRate: 4900, wordMinLen: 2, wordMaxLen: 4, fastWordChance: 0.05, fastWordMultiplier: 1.5 } ] },
    { subLevels: [ { fallSpeed: 0.45, genRate: 4600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.06, fastWordMultiplier: 1.6 }, { fallSpeed: 0.50, genRate: 4300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.07, fastWordMultiplier: 1.6 }, { fallSpeed: 0.55, genRate: 4000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.08, fastWordMultiplier: 1.7 } ] },
    { subLevels: [ { fallSpeed: 0.60, genRate: 3800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.09, fastWordMultiplier: 1.8 }, { fallSpeed: 0.66, genRate: 3500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.10, fastWordMultiplier: 1.8 }, { fallSpeed: 0.72, genRate: 3200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.11, fastWordMultiplier: 1.9 } ] },
    { subLevels: [ { fallSpeed: 0.75, genRate: 3000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.12, fastWordMultiplier: 2.0 }, { fallSpeed: 0.85, genRate: 2800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.14, fastWordMultiplier: 2.1 }, { fallSpeed: 0.92, genRate: 2600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.15, fastWordMultiplier: 2.2 } ] },
    { subLevels: [ { fallSpeed: 1.0, genRate: 2400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.16, fastWordMultiplier: 2.4 }, { fallSpeed: 1.08, genRate: 2250, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.18, fastWordMultiplier: 2.5 }, { fallSpeed: 1.16, genRate: 2100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.6 } ] },
    { subLevels: [ { fallSpeed: 1.25, genRate: 2000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.20, fastWordMultiplier: 2.7 }, { fallSpeed: 1.35, genRate: 1850, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.21, fastWordMultiplier: 2.8 }, { fallSpeed: 1.45, genRate: 1700, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.23, fastWordMultiplier: 2.9 } ] },
    { subLevels: [ { fallSpeed: 1.55, genRate: 1600, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.24, fastWordMultiplier: 3.0 }, { fallSpeed: 1.65, genRate: 1500, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.25, fastWordMultiplier: 3.1 }, { fallSpeed: 1.75, genRate: 1400, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.27, fastWordMultiplier: 3.2 } ] },
    { subLevels: [ { fallSpeed: 1.85, genRate: 1300, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.28, fastWordMultiplier: 3.3 }, { fallSpeed: 1.95, genRate: 1200, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.29, fastWordMultiplier: 3.4 }, { fallSpeed: 2.05, genRate: 1100, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.31, fastWordMultiplier: 3.5 } ] },
    { subLevels: [ { fallSpeed: 2.20, genRate: 1000, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.32, fastWordMultiplier: 3.6 }, { fallSpeed: 2.35, genRate: 900, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.34, fastWordMultiplier: 3.7 }, { fallSpeed: 2.50, genRate: 800, wordMinLen: 3, wordMaxLen: 4, fastWordChance: 0.36, fastWordMultiplier: 3.8 } ] }
];
let lbb_isGameActive = false;
let lbb_gameLevel = 1;
const LBB_MAX_LEVEL = 10;
let lbb_playerPos = { r: 0, c: 0 };
let lbb_enemyPos = { r: 0, c: 0 };
let lbb_playerScore = 0;
let lbb_enemyScore = 0;
let lbb_gameBoard = [];
let lbb_blockBreakParticles = [];
const LBB_BOARD_ROWS = 10;
const LBB_BOARD_COLS = 15;
let LBB_BLOCK_SIZE = 30;
let lbb_blockTextFont = "bold 14px 'Noto Sans KR', sans-serif";
let lbb_enemyActionIntervalId = null;
const lbb_levelDelays = [3000, 2700, 2400, 2100, 1800, 1500, 1200, 900, 650, 450];
let lbb_enemyMoveDelay = lbb_levelDelays[0];
let lbb_gamePausedForOverlay = false;
let lbb_gamePausedForEffect = false;
let lbb_isRelocating = false;
let lbb_swapEffect = { active: false, step: 0, totalSteps: 40, playerOld: null, enemyOld: null, animPlayerPos: null, animEnemyPos: null, effectDuration: 800 };
let lbb_gameLoopId = null;
let lbb_finalBattleAnimation = { isActive: false, step: 0, totalSteps: 50, playerStartPos: null, enemyStartPos: null, meetingPoint: null, playerAnimPos: null, enemyAnimPos: null };
let lbb_gameStartTime = null;
const LBB_GAME_DURATION_MS = 120000;
const LBB_BLOCK_BORDER_COLOR_VAR = '--input-border';
const LBB_BROKEN_BLOCK_COLOR_VAR = '--bg-typing-area';
let lbb_playerNoPlayableBlocksTimerId = null;
let lbb_enemyNoPlayableBlocksTimerId = null;
const LBB_NO_PLAYABLE_RELOCATE_DELAY = 5000;
let lbb_relocationCountdown = 0;
let lbb_relocationCountdownIntervalId = null;
const LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT = 5;
const LBB_BLOCK_EFFECT_TYPES = {
    YELLOW: { type: 'yellow', color: 'gold', score: 2, effect: null, icon: '⭐' },
    RED: { type: 'red', color: 'tomato', score: 3, effect: null, icon: '🔥' },
    BLUE: { type: 'blue', color: 'deepskyblue', score: 1, effect: 'freezeEnemy', freezeDuration: 2000, icon: '❄️' },
    GREEN: { type: 'green', color: 'limegreen', score: 1, effect: 'swapPositions', icon: '↔️' },
    NORMAL: { type: 'normal', color: null, score: 1, effect: null, icon: null }
};
const LBB_ITEM_SPAWN_PROBABILITY = 0.20;
let lbb_isEnemyFrozen = false;
let lbb_enemyFreezeTimeoutId = null;
let lbb_enemyOriginalStartPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1};
let gb_isGameActive = false;
let countdownTimerId = null;
let gb_gameLoopId = null;
let gb_currentLevel = 1;
const GB_MAX_LEVEL = 10;
let gb_playerHealth = 100;
let gb_enemyHealth = 100;
const GB_MAX_PLAYER_HEALTH = 100;
let gb_playerAttackWord = '';
let gb_enemyAttacks = [];
let gb_enemyAttackIntervalId = null;
const GB_PLAYER_ATTACK_DAMAGE = 18;
const GB_ENEMY_ATTACK_DAMAGE = 12;
let gb_gamePausedForOverlay = false;
const GB_SPECIAL_ATTACK_CHANCE = 0.18;
let gb_gameStartTime = null;
const GB_GAME_DURATION_MS = 120000; // 2분
let gb_enemyHitEffectTimer = 0;
const GB_ENEMY_HIT_EFFECT_DURATION = 200;
const gb_levelConfigs = [
    { level: 1,  enemyHealth: 50,  attackInterval: 5500, attackSpeed: 0.7, wordMinLen: 2, wordMaxLen: 3 },
    { level: 2,  enemyHealth: 70,  attackInterval: 5000, attackSpeed: 0.8, wordMinLen: 2, wordMaxLen: 3 },
    { level: 3,  enemyHealth: 90,  attackInterval: 4500, attackSpeed: 0.9, wordMinLen: 3, wordMaxLen: 4 },
    { level: 4,  enemyHealth: 120, attackInterval: 4000, attackSpeed: 1.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 5,  enemyHealth: 150, attackInterval: 3500, attackSpeed: 1.2, wordMinLen: 3, wordMaxLen: 4 },
    { level: 6,  enemyHealth: 190, attackInterval: 3000, attackSpeed: 1.4, wordMinLen: 3, wordMaxLen: 4 },
    { level: 7,  enemyHealth: 240, attackInterval: 2500, attackSpeed: 1.6, wordMinLen: 3, wordMaxLen: 4 },
    { level: 8,  enemyHealth: 300, attackInterval: 2200, attackSpeed: 1.8, wordMinLen: 3, wordMaxLen: 4 },
    { level: 9,  enemyHealth: 360, attackInterval: 2000, attackSpeed: 2.0, wordMinLen: 3, wordMaxLen: 4 },
    { level: 10, enemyHealth: 420, attackInterval: 1800, attackSpeed: 2.3, wordMinLen: 3, wordMaxLen: 4 }
];
const gameWordsKor = [
    "안녕", "하늘", "바다", "구름", "사랑", "행복", "미소", "바람", "햇살", "나무", "꽃잎", "별빛", "마음", "시간", "친구", "소망", "기억", "이유", "결심", "순간", "여름", "가을", "겨울", "봄날",
    "이야기", "노래", "꿈속", "추억", "선물", "감사", "희망", "용기", "믿음", "약속", "미래", "현실", "세계", "우주", "자연", "동물", "식물", "인형", "장난감", "그림",
    "과자", "사탕", "우유", "학교", "공부", "도전", "성공", "실패", "과정", "결과", "노력", "결실", "인생", "여정", "목표", "방향", "지도", "나침반", "등대", "열쇠",
    "게임", "놀이", "책상", "의자", "컴퓨터", "키보드", "마우스", "모니터", "프린터", "스피커", "헤드폰", "마이크", "카메라", "휴대폰", "태블릿", "충전기", "배터리",
    "음악", "영화", "여행", "사진", "조각", "건축", "디자인", "패션", "요리", "운동", "취미", "독서", "글쓰기", "토론", "발표", "강연", "세미나", "회의", "수업",
    "강아지", "고양이", "햄스터", "토끼", "새", "물고기", "거북이", "도마뱀", "사자", "호랑이", "코끼리", "기린", "하마", "악어", "판다", "펭귄", "고래",
    "계절", "날씨", "온도", "습도", "태풍", "장마", "눈보라", "폭염", "한파", "황사", "일기", "예보", "천둥", "번개", "소나기", "안개", "이슬",
    "딸기", "포도", "수박", "사과", "바나나", "오렌지", "귤", "레몬", "자몽", "키위", "망고", "체리", "복숭아", "자두", "살구", "매실", "감", "배",
    "주스", "에이드", "칵테일", "와인", "맥주", "소주", "막걸리", "위스키", "보드카", "데킬라", "하이볼", "탄산수",
    "비행기", "기차", "버스", "택시", "자전거", "지하철", "배", "요트", "크루즈", "우주선", "로켓", "드론", "자동차", "트럭",
    "병원", "약국", "의사", "간호사", "환자", "진료", "처방", "수술", "입원", "퇴원", "응급실", "구급차", "백신", "마스크", "소독제", "체온계", "반창고",
    "공원", "산책", "등산", "캠핑", "낚시", "수영", "서핑", "스키", "골프", "테니스", "축구", "야구", "농구", "배구", "탁구", "볼링",
    "가족", "부모", "형제", "자매", "친척", "친구", "이웃", "동료", "선배", "후배", "연인", "배우자", "아기", "어린이", "청소년", "어른", "노인",
    "얼굴", "머리", "눈썹", "눈동자", "코", "입술", "이빨", "혀", "턱", "목", "어깨", "팔", "손목", "손가락", "손톱", "가슴", "배", "허리", "등", "엉덩이", "다리", "무릎", "발목", "발가락",
    "감정", "기쁨", "슬픔", "화남", "놀람", "두려움", "부끄럼", "지루함", "흥미", "만족", "불만", "질투", "연민", "공감", "자신감", "자존감", "열등감",
    "색깔", "빨강", "주황", "노랑", "초록", "파랑", "남색", "보라", "분홍", "하양", "검정", "회색", "갈색", "금색", "은색", "무지개", "단색", "혼합색",
    "숫자", "하나", "둘", "셋", "넷", "여섯", "일곱", "여덟", "아홉", "열", "스물", "서른", "마흔", "쉰", "예순", "일흔", "여든", "아흔",
    "시작", "중단", "계속", "종료", "확인", "취소", "저장", "삭제", "편집", "검색", "추가", "변경", "도움", "안내", "경고", "오류", "성공", "정보", "항목", "목록",
    "유리", "금속", "나무", "돌", "흙", "물", "불", "공기", "빛", "소리", "냄새", "맛", "느낌", "생각", "감각", "지능", "창의", "상상", "표현", "예술", "과학",
    "수학", "역사", "지리", "사회", "경제", "정치", "법률", "윤리", "철학", "종교", "언어", "문학", "교육", "심리", "의학", "공학", "기술", "정보", "통신", "우주인", "방울뱀", "사막여우",
    "가로등", "가위질", "가정교사", "가족사진", "키테라피", "갈림길", "걸림돌", "감사패", "감정표현", "강강술래", "개발자", "거북선", "건강검진", "건널목", "검정고시", "결혼기념", "경기장", "경찰관", "경호원", "계란후라이", "고속도로", "고인돌", "골목대장", "공기놀이", "공중전화", "공휴일", "과일가게", "과학상자", "관광버스", "광화문", "구급상자", "국회의원", "군고구마", "그림일기", "극장", "기념품", "기상캐스터", "기차여행", "긴급상황", "김장독", "까마귀", "까치밥", "꽃다발", "꿀벌", "꿈나라", "끝말잇기", "나무늘보", "나비넥타이", "낙하산", "낚시꾼", "난센스퀴즈", "날개", "남대문", "낭떠러지", "내비게이션", "냉장고", "네잎클로버", "노랫소리", "노트북", "놀이공원", "농구공", "눈사람", "다리미", "다람쥐", "다이아몬드", "단풍잎", "달리기", "닭꼬치", "담벼락", "당근", "대통령", "대한민국", "도서관", "독수리", "돈가스", "돌고래", "동물원", "두부", "두통약", "드라이기", "등산화", "디지털카메라", "라면", "라디오", "로봇", "리모컨", "마라톤", "마법사", "만두", "만리장성"
].map(word => word.trim());
const sentencePool = {
    kor: [
    "참 따뜻한 날이었다. 너와 함께여서였을지 모른다.",
    "엄마, 사랑해. 그 한마디가 왜 그리도 어려웠을까.",
    "나는 내 삶의 기적, 그 자체다.",
    ],
    eng: ["The weather is lovely today perfect for a nice walk.", "Pack my box with five dozen liquor jugs.", "Sphinx of black quartz judge my vow.", "Amazingly few discotheques provide jukeboxes.", "How vexingly quick daft zebras jump.", "Bright vixens jump dozy fowl quack.", "Quick wafting zephyrs vex bold Jim.", "Crazy Fredrick bought many very exquisite opal jewels.", "Hello how are you today?", "Thank you very much for your help.", "Pleased to meet you.", "Practice makes perfect.", "Have a wonderful day ahead.", "Good morning sunshine.", "Keep up the good work.", "See you later alligator.", "What a beautiful surprise.", "Actions speak louder than words."],
    korLong: [
        { title: "다락방의 햇살", content: `낡은 다락방 창문으로 스며드는 오후의 햇살은 먼지 쌓인 시간 위로 부드럽게 내려앉았다. 공기 중에는 오래된 책 냄새와 희미한 나무 향기가 뒤섞여, 마치 잊혀진 이야기들이 낮은 목소리로 속삭이는 듯했다. 빛줄기를 따라 부유하는 작은 먼지들은 금빛 가루처럼 반짝였고, 그 너머로 보이는 바깥세상은 한 폭의 수채화처럼 아련했다. 나는 삐걱이는 나무 계단을 밟고 올라와, 창가 낡은 흔들의자에 가만히 몸을 기댔다. 창밖으로 보이는 느티나무는 수백 년의 세월을 말없이 지켜온 듯, 바람이 불 때마다 잎사귀를 흔들며 낮은 노래를 불렀다. 그 풍경 속에서 나는 어린 시절의 기억들을 하나씩 꺼내보았다. 할머니가 들려주시던 옛날이야기, 친구들과 뛰놀던 골목길의 저녁노을, 처음으로 느껴본 설렘과 아픔. 모든 것이 희미한 필름처럼 머릿속을 스쳐 지나갔지만, 그 감정만큼은 여전히 선명하게 남아 가슴 한구석을 아릿하게 만들었다. 시간은 모든 것을 변화시키지만, 기억 속에 새겨진 온기는 영원히 변치 않는다는 것을, 나는 그 순간 깨달았다. 어쩌면 우리는 모두 마음속에 자신만의 작은 다락방을 가지고 살아가는지도 모른다. 힘들고 지칠 때마다 찾아가 위로받을 수 있는, 소중한 추억들이 잠들어 있는 비밀스러운 공간을.` },
                { title: "사람 사는 시장", content: `나는 가끔 오래된 시장을 찾는 것을 좋아한다. 대형마트의 깔끔함과 편리함도 좋지만, 시장에는 그곳에서만 느낄 수 있는 특별한 활기와 정겨움이 있다. 좌판 가득 싱싱한 채소와 과일을 진열해놓고 구성진 목소리로 손님을 부르는 상인들, 흥정을 하며 덤을 얻어가는 손님들의 웃음소리, 맛있는 냄새를 풍기며 발길을 유혹하는 길거리 음식들까지. 시장은 살아있는 사람들의 이야기로 가득한 공간이다. 나는 천천히 시장 골목을 걸으며, 다양한 물건들을 구경하고 사람들의 살아가는 모습을 관찰한다. 그 속에서 나는 잊고 지냈던 인간적인 따뜻함과 소박한 삶의 아름다움을 발견한다. 시장 상인들의 거친 손마디에는 정직한 땀의 가치가 담겨 있고, 그들의 구릿빛 얼굴에는 세월의 흔적과 삶의 지혜가 새겨져 있다. 그들은 단순히 물건을 파는 것이 아니라, 자신의 삶을 나누고 사람들과 정을 주고받는다. 그래서 시장에서의 거래는 단순한 매매를 넘어, 따뜻한 인간관계의 한 형태가 된다. 나는 시장 한구석 작은 분식집에 앉아 뜨끈한 어묵 국물을 마시며, 시장의 활기찬 풍경을 다시 한번 눈에 담았다. 이곳에는 여전히 변치 않는 사람 사는 냄새가 있었고, 그것이 나를 위로하고 새로운 힘을 주는 것 같았다.` },
    ],
    engLong: [
        { title: "The Old Attic", content: "The old attic window, streaked with the dust of ages, allowed the afternoon sun to filter in, casting a soft, golden glow over forgotten treasures. The air hung heavy with the scent of aged paper and faint wood, a nostalgic perfume that seemed to whisper tales of bygone eras. Tiny dust motes danced in the invading sunbeams, sparkling like miniature galaxies, and the world outside, viewed through the grimy pane, appeared as a distant, dreamlike watercolor. I had creaked my way up the wooden stairs, settling into the worn comfort of a rocking chair by the window. Below, an ancient oak stood sentinel, its leaves rustling a quiet, timeless song with every breeze, a silent observer of centuries unfolding. In that tranquil tableau, I found myself sifting through childhood memories: a grandmother's gentle voice narrating fairy tales, the vibrant hues of a sunset over a familiar alleyway, the first stirrings of a young heart's joy and sorrow. Time, in its relentless march, may alter all things, yet the warmth embedded in memory, I realized, remains an immutable sanctuary. Perhaps we all carry a small, secret attic within our souls, a place of solace filled with cherished recollections, a haven to retreat to when the world outside grows too loud." },
        { title: "The Desert's Beauty", content: "The desert stretched out before him, an endless expanse of undulating dunes under a sky so vast it seemed to swallow the horizon. The sun beat down relentlessly, and the air shimmered with an almost palpable heat. Yet, amidst this harsh and unforgiving landscape, there was a stark, austere beauty that captivated the soul. The way the wind sculpted the sand into ever-changing, sinuous patterns, the resilience of the sparse, thorny vegetation clinging stubbornly to life, the profound, almost deafening silence broken only by the whisper of the breeze – it all spoke of a raw, primal power and an ancient, unyielding spirit. He had come here seeking solitude, a place where the distractions and superficialities of the modern world would fade into insignificance, allowing him to confront the unadorned truths of his own existence. In the vast emptiness, he found not desolation, but a strange kind of freedom, a clarity that only such an elemental landscape could provide. The desert, in its starkness, mirrored the landscape of his own inner world, challenging and ultimately, offering a path to understanding." },
    ],
    jsLong: [
        { title: "API 데이터 가져오기", content: `// Example 1: Fetching and displaying data from an API\nasync function displayUsers() {\n  const userList = document.getElementById('user-list');\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    const users = await response.json();\n    userList.innerHTML = ''; // Clear previous list\n    users.forEach(user => {\n      const li = document.createElement('li');\n      li.textContent = \`\${user.name} (@\${user.username}) - \${user.email}\`;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    userList.innerHTML = '<li>Error loading users.</li>';\n    console.error('Fetching users failed:', error);\n  }\n}` },
        { title: "카운트다운 타이머", content: `// Example 2: Simple class for a countdown timer\nclass CountdownTimer {\n  constructor(duration, displayElement) {\n    this.duration = duration; // in seconds\n    this.display = displayElement;\n    this.timerId = null;\n  }\n\n  start() {\n    let remaining = this.duration;\n    const tick = () => {\n      const minutes = String(Math.floor(remaining / 60)).padStart(2, '0');\n      const seconds = String(remaining % 60).padStart(2, '0');\n      this.display.textContent = \`\${minutes}:\${seconds}\`;\n      if (--remaining < 0) { this.stop(); }\n    };\n    this.stop(); // Clear any existing timer\n    this.timerId = setInterval(tick, 1000);\n  }\n\n  stop() {\n    clearInterval(this.timerId);\n    this.display.textContent = 'Time is up!';\n  }\n}` },
        { title: "배열 필터링 및 매핑", content: `// Example 3: Filtering and mapping an array of objects\nconst products = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200, inStock: true },\n  { id: 2, name: 'T-Shirt', category: 'Apparel', price: 25, inStock: true },\n  { id: 3, name: 'Coffee Maker', category: 'Appliances', price: 80, inStock: false },\n  { id: 4, name: 'Smartphone', category: 'Electronics', price: 800, inStock: true }\n];\n\nconst availableElectronics = products\n  .filter(p => p.category === 'Electronics' && p.inStock)\n  .map(p => {\n    const priceWithTax = p.price * 1.10;\n    return { ...p, priceWithTax: priceWithTax.toFixed(2) };\n  });\n\nconsole.log(availableElectronics);` },
        { title: "Pub/Sub 패턴", content: `// Example 4: Implementing a simple Pub/Sub (Event Emitter) pattern\nconst eventBus = {\n  events: {},\n  subscribe(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    const index = this.events[event].push(listener) - 1;\n    return {\n      unsubscribe: () => {\n        this.events[event].splice(index, 1);\n      }\n    };\n  },\n  publish(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n};\n\nconst subscription = eventBus.subscribe('userLogin', (user) => console.log(\`\${user} logged in.\`));\neventBus.publish('userLogin', 'Alice');\nsubscription.unsubscribe();` },
        { title: "Debounce 함수", content: `// Example 5: Debounce function for performance optimization\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(context, args);\n    }, delay);\n  };\n}\n\nconst handleSearchInput = (query) => {\n  console.log(\`Searching for: \${query}\`);\n  // API call would go here\n};\n\nconst searchInput = document.getElementById('search');\nif (searchInput) {\n    searchInput.addEventListener('keyup', debounce((e) => handleSearchInput(e.target.value), 300));\n}` },
        { title: "모듈 패턴", content: `// Example 6: Module revealing pattern\nconst dataModule = (function() {\n  let privateData = []; // This is private\n\n  function add(item) {\n    privateData.push(item);\n    console.log('Item added.');\n  }\n\n  function get(index) {\n    return privateData[index];\n  }\n\n  // Publicly expose methods\n  return {\n    addItem: add,\n    getItem: get\n  };\n})();\n\ndataModule.addItem('First item');\nconsole.log(dataModule.getItem(0));` }
    ],
    python: [
        `name = "key_therapy"`,
        `score: int = 100`,
        `is_active: bool = True`,
        `user_profile = None`,
        `# End of Python short examples.`
    ],
    pythonLong: [
        { title: "웹 스크래핑 예제", content: `# Example 1: Web scraping with requests and BeautifulSoup\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_website_title(url: str) -> str:\n    """Scrapes the title of a given URL."""\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        soup = BeautifulSoup(response.text, 'html.parser')\n        title = soup.find('h1')\n        return title.string.strip() if title else 'No H1 title found.'\n    except requests.exceptions.RequestException as e:\n        print(f"An error occurred: {e}")\n        return "Error: Could not retrieve title."` },
        { title: "SQLite 데이터베이스", content: `# Example 6: Working with a simple SQLite database\nimport sqlite3\n\ndef setup_database(db_name: str):\n    # Connect to the database (or create it)\n    conn = sqlite3.connect(db_name)\n    cursor = conn.cursor()\n\n    # Create a table\n    cursor.execute('''\n    CREATE TABLE IF NOT EXISTS users\n    (id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT NOT NULL UNIQUE)\n    ''')\n\n    # Insert a row of data\n    try:\n        cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('John Doe', 'john.doe@email.com'))\n    except sqlite3.IntegrityError:\n        print("User already exists.")\n    \n    # Save (commit) the changes and close\n    conn.commit()\n    conn.close()` }
    ]
};
function getRandom(arr) {
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}
function initializeAudioPoolForPack(packKey) {
    if (!soundFiles[packKey] || soundFiles[packKey].length === 0) return;
    audioPool[packKey] = [];
    soundFiles[packKey].forEach(soundSrc => {
        const audio = new Audio(soundSrc);
        audio.preload = 'auto';
        audioPool[packKey].push(audio);
    });
}
function initializeAudioPool() {
    for (const packKey in soundFiles) {
        initializeAudioPoolForPack(packKey);
    }
}
function playTypingSound() {
    clearTimeout(soundTimer);
    soundTimer = setTimeout(() => {
        if (!soundEnabled || !currentSoundPack) return;
        const masterAudioPool = audioPool[currentSoundPack];
        if (!masterAudioPool || masterAudioPool.length === 0) {
            initializeAudioPoolForPack(currentSoundPack);
            return;
        }
        const masterAudio = getRandom(masterAudioPool);
        if (!masterAudio) return;
        const audioToPlay = masterAudio.cloneNode();
        audioToPlay.play().catch(e => {});
    }, 1);
}
function updateDropdown(level) {
    const gameLevelSelect = document.getElementById('gameLevelSelectInBar');
    if (gameLevelSelect) {
        gameLevelSelect.value = level;
    }
}
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('no-transition');
  languageSelectEl = document.getElementById('languageSelect');
  languageSelectLabelEl = document.getElementById('languageSelectLabel');
  toggleSoundBtn = document.getElementById('toggleSoundBtn');
  toggleHighlightBtn = document.getElementById('toggleHighlightBtn');
  // ==================== ▼▼▼ 3. JS 초기화 로직 수정 ▼▼▼ ====================
  toggleAutoCompleteBtn = document.getElementById('toggleAutoCompleteBtn');
  // ==================== ▲▲▲ 3. JS 초기화 로직 수정 ▲▲▲ ====================
  toggleLayoutBtn = document.getElementById('toggleLayoutBtn');
  lineDisplayArea = document.getElementById('line-display-area');
  typingInputField = document.getElementById('typing-input-field');
  fakeInputField = document.getElementById('fake-input-field');
  resultEl = document.getElementById('result');
  upcomingLinesArea = document.getElementById('upcoming-lines-area');
  soundPackSelectEl = document.getElementById('soundPackSelect');
  themeSelectEl = document.getElementById('themeSelect');
  toggleStatsBtn = document.getElementById('toggleStatsBtn');
  gameModeBtnEl = document.getElementById('gameModeBtn');
  progressBarContainerEl = document.querySelector('.progress-bar-container');
  progressBarEl = document.querySelector('.progress-bar');
  statsEl = document.getElementById('stats');
  gameAreaContainerEl = document.getElementById('game-area-container');
  toggleKeyboardGuideBtn = document.getElementById('toggleKeyboardGuideBtn');
  keyboardGuideEl = document.getElementById('keyboard-guide');
  helpModal = document.getElementById('helpModal');
  helpModalBody = document.getElementById('helpModalBody');
  helpModalClose = document.querySelector('.help-modal-close');
  freestyleAreaContainerEl = document.getElementById('freestyle-area-container');
  freestyleInputAreaEl = document.getElementById('freestyle-input-area');
  downloadFreestyleBtnEl = document.getElementById('download-freestyle-btn');
  freestyleFilenameInputEl = document.getElementById('freestyle-filename-input');
  freestyleToolbarEl = document.getElementById('freestyle-toolbar');
  insertDateBtn = document.getElementById('insertDateBtn');
  insertTimeBtn = document.getElementById('insertTimeBtn');
  emojiBtn = document.getElementById('emojiBtn');
  emojiPicker = document.getElementById('emoji-picker');
  copyAllBtn = document.getElementById('copyAllBtn');
  clearAllBtn = document.getElementById('clearAllBtn');
  insertHrBtn = document.getElementById('insertHrBtn');
  charCountEl = document.getElementById('charCount');
  wordCountEl = document.getElementById('wordCount');
  longTextSelectContainerEl = document.getElementById('longTextSelectContainer');
  longTextSelectEl = document.getElementById('longTextSelect');
  practiceTitleDisplayEl = document.getElementById('practice-title-display');
  soundSettingsEl = document.getElementById('soundSettingsElement');
  themeSettingsEl = document.getElementById('themeSettingsElement');
  mainControlsEl = document.querySelector('.main-controls');

  const allElements = [languageSelectEl, lineDisplayArea, typingInputField, fakeInputField, toggleSoundBtn, toggleHighlightBtn, toggleAutoCompleteBtn, toggleLayoutBtn, resultEl, upcomingLinesArea, soundPackSelectEl, themeSelectEl, toggleStatsBtn, gameModeBtnEl, progressBarContainerEl, progressBarEl, statsEl, gameAreaContainerEl, soundSettingsEl, themeSettingsEl, mainControlsEl, toggleKeyboardGuideBtn, keyboardGuideEl, freestyleAreaContainerEl, freestyleInputAreaEl, downloadFreestyleBtnEl, freestyleFilenameInputEl, freestyleToolbarEl, insertDateBtn, insertTimeBtn, emojiBtn, emojiPicker, copyAllBtn, clearAllBtn, insertHrBtn, charCountEl, wordCountEl, helpModal, helpModalBody, helpModalClose, longTextSelectContainerEl, longTextSelectEl, practiceTitleDisplayEl];
  if (!allElements.every(el => el)) {
      console.error("하나 이상의 필수 HTML 요소를 찾을 수 없습니다. 누락된 요소를 확인해주세요.");
      if (resultEl) resultEl.textContent = "페이지 로딩 오류.";
      return;
  }
  originalSoundParent = soundSettingsEl.parentNode;
  originalSoundNextSibling = soundSettingsEl.nextSibling;
  originalThemeParent = themeSettingsEl.parentNode;
  originalThemeNextSibling = themeSettingsEl.nextSibling;
  soundPackSelectEl.innerHTML = '';
  for (let i = 1; i <= totalSoundPacks; i++) {
    const option = document.createElement('option');
    option.value = String(i);
    option.textContent = String(i);
    soundPackSelectEl.appendChild(option);
  }
  soundPackSelectEl.value = currentSoundPack;
  const savedTheme = localStorage.getItem('typingTheme') || 'dark';
  applyTheme(savedTheme);
  themeSelectEl.value = savedTheme;
  document.getElementById('soundPackLabel').textContent = '타건음:';
  document.getElementById('themeSelectLabel').textContent = '테마:';
  initializeAudioPool();
  buildKeyboard();
  if (toggleLayoutBtn) {
    toggleLayoutBtn.addEventListener('click', () => {
        layoutCollapsed = !layoutCollapsed;
        updateLayout();
        localStorage.setItem('layoutCollapsed', layoutCollapsed);
    });
  }
  document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(button => {
    button.addEventListener('click', function() {
      showShortcutTooltipTemporarily(); 
      const type = this.dataset.practiceType;
      if (type === 'freestyle') {
          startFreestyleMode();
          return;
      }
      const lang = languageSelectEl.value;
      const isLong = (type === 'long');
      const mode = isLong ? `${lang}Long` : lang;
      startPractice(mode, true);
    });
  });
  if (gameModeBtnEl) {
    gameModeBtnEl.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('rainfall');
    });
  }
  if (gameAreaContainerEl) {
    gameAreaContainerEl.addEventListener('click', function(e) {
      if (e.target.closest('#gameHelpBtn')) {
        if (currentGameType) {
          showHelpModal(currentGameType);
        }
      }
    });
  }
  const restartPractice = () => {
    const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
    if (!activePracticeBtn || currentMode === 'freestyle') return;
    const type = activePracticeBtn.dataset.practiceType;
    const lang = languageSelectEl.value;
    const isLong = (type === 'long');
    const mode = isLong ? `${lang}Long` : lang;
    startPractice(mode, true);
  };
  languageSelectEl.addEventListener('change', restartPractice);
  toggleSoundBtn.classList.toggle('active', soundEnabled);
  toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
  if (statsVisible) {
    toggleStatsBtn.classList.add('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
    statsEl.classList.remove('hidden');
  } else {
    toggleStatsBtn.classList.remove('active');
    toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.add('hidden');
  }
  typingInputField.addEventListener('input', (e) => {
    soundPlayedForThisInput = false;
    handleInputEvent(e);
  });
 typingInputField.addEventListener('compositionstart', () => {
    isComposingNow = true;
  });
  typingInputField.addEventListener('compositionend', (e) => {
    isComposingNow = false;
    // 조합이 끝난 직후, 완성된 입력값으로 handleInputEvent를 수동으로 한번 더 호출합니다.
    handleInputEvent(e); 
  });
  if (fakeInputField && typingInputField) {
      fakeInputField.addEventListener('click', () => typingInputField.focus());
  }
  document.body.addEventListener('click', function(e) {
    if (emojiPicker.classList.contains('visible') && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
        emojiPicker.classList.remove('visible');
    }
    if (helpModal.classList.contains('visible') && !e.target.closest('.help-modal-content')) {
        hideHelpModal();
    }
    const isInteractiveElement = e.target.closest('button, a, select, input, textarea, #emoji-picker span, .help-modal-content');
    if (!isInteractiveElement) {
      if (document.body.classList.contains('game-mode-active')) {
        if (gameInputField && !gameInputField.disabled) gameInputField.focus();
      } else if (document.body.classList.contains('freestyle-mode-active')) {
        if (freestyleInputAreaEl) freestyleInputAreaEl.focus();
      } else {
        if (typingInputField && !typingInputField.disabled) typingInputField.focus();
      }
    }
  });
  toggleSoundBtn.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    toggleSoundBtn.classList.toggle('active', soundEnabled);
    toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    if (currentMode === 'game' && gameToggleSoundBtn) {
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    }
  });
  toggleHighlightBtn.addEventListener('click', () => {
    highlightEnabled = !highlightEnabled;
    toggleHighlightBtn.classList.toggle('active', highlightEnabled);
    toggleHighlightBtn.innerHTML = highlightEnabled ? '<i class="fas fa-highlighter"></i> 오타체크 ON' : '<i class="far fa-eye-slash"></i> 오타체크 OFF';
    
    // [수정] getTypingAnalysis를 사용하여 화면을 즉시 갱신합니다.
    const analysis = getTypingAnalysis(typingInputField.value, linesToPractice[currentDisplayLineIndex] || "");
    const currentLineEl = document.getElementById('current-typing-line');
    if (currentLineEl) {
        const innerSpan = currentLineEl.querySelector('span');
        if (innerSpan) {
            innerSpan.innerHTML = analysis.html;
        }
    }
  });
  // ==================== ▼▼▼ 3. JS 초기화 로직 수정 ▼▼▼ ====================
  toggleAutoCompleteBtn.addEventListener('click', () => {
    autoCompleteEnabled = !autoCompleteEnabled;
    updateAutoCompleteButton();
    localStorage.setItem('autoCompleteEnabled', autoCompleteEnabled);
  });
  // ==================== ▲▲▲ 3. JS 초기화 로직 수정 ▲▲▲ ====================
  soundPackSelectEl.addEventListener('change', (event) => {
    currentSoundPack = event.target.value;
    initializeAudioPoolForPack(currentSoundPack);
  });
  themeSelectEl.addEventListener('change', (event) => {
    const selectedTheme = event.target.value;
    applyTheme(selectedTheme);
    localStorage.setItem('typingTheme', selectedTheme);
  });
  toggleStatsBtn.addEventListener('click', () => {
    statsVisible = !statsVisible;
    toggleStatsBtn.classList.toggle('active', statsVisible);
    toggleStatsBtn.innerHTML = statsVisible ? '<i class="fas fa-chart-line"></i> 측정 ON' : '<i class="fas fa-eye-slash"></i> 측정 OFF';
    statsEl.classList.toggle('hidden', !statsVisible);
  });
  toggleKeyboardGuideBtn.addEventListener('click', () => {
    keyboardGuideEnabled = !keyboardGuideEnabled;
    toggleKeyboardGuideBtn.classList.toggle('active', keyboardGuideEnabled);
    toggleKeyboardGuideBtn.innerHTML = keyboardGuideEnabled ? '<i class="fas fa-keyboard"></i> 자리연습 ON' : '<i class="far fa-keyboard"></i> 자리연습 OFF';
    if (keyboardGuideEl) {
        keyboardGuideEl.classList.toggle('visible', keyboardGuideEnabled);
    }
    if (keyboardGuideEnabled) {
        updateKeyboardDisplay();
        updateKeyboardHighlight();
    } else {
        clearKeyboardHighlight();
    }
  });
  helpModalClose.addEventListener('click', hideHelpModal);
  freestyleInputAreaEl.addEventListener('input', () => {
    soundPlayedForThisInput = false; 
    playTypingSound();
    if (!startTime) {
        startTime = Date.now();
    }
    updateFreestyleStats();
  });
  freestyleInputAreaEl.addEventListener('keydown', (e) => {
    soundPlayedForThisInput = false;
    if (e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
        playTypingSound();
    }
  });
  downloadFreestyleBtnEl.addEventListener('click', handleFreestyleDownload);
  insertDateBtn.addEventListener('click', insertDate);
  insertTimeBtn.addEventListener('click', insertTime);
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('visible');
  });
  emojiPicker.querySelectorAll('span').forEach(emoji => {
    emoji.addEventListener('click', () => {
        insertAtCursor(freestyleInputAreaEl, emoji.textContent);
        emojiPicker.classList.remove('visible');
        freestyleInputAreaEl.focus();
    });
  });
  copyAllBtn.addEventListener('click', copyAllFreestyleText);
  clearAllBtn.addEventListener('click', clearAllFreestyleText);
  insertHrBtn.addEventListener('click', () => insertAtCursor(freestyleInputAreaEl, '\n\n---\n\n'));
  longTextSelectEl.addEventListener('change', () => {
      const lang = languageSelectEl.value;
      const mode = lang + 'Long';
      startPractice(mode, false);
  });
  
 const copyEmailBtn = document.getElementById('copyEmailBtn');
  if (copyEmailBtn) {
    copyEmailBtn.addEventListener('click', () => {
      const email = 'keytherapy@naver.com';
      navigator.clipboard.writeText(email).then(() => {
        showSharePopup('이메일 주소가 복사되었습니다!');
      }).catch(err => {
        console.error('이메일 복사 실패:', err);
        showSharePopup('복사에 실패했습니다.');
      });
    });
  }

  applyFontFamily("'Gowun Dodum', sans-serif");
  
  document.addEventListener('keydown', (e) => {
    const activeElTag = document.activeElement.tagName.toLowerCase();
    
    const isOverlayVisible = gameOverlayEl && gameOverlayEl.classList.contains('visible');
    const isStartMsgVisible = gameStartMessageEl && gameStartMessageEl.style.display !== 'none';

    if ((isOverlayVisible || isStartMsgVisible) && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        const nextBtn = document.getElementById('nextStepBtnOverlay');
        const startBtn = document.getElementById('startGameBtn');
        if (isOverlayVisible && nextBtn) nextBtn.click();
        else if (isStartMsgVisible && startBtn) startBtn.click();
        return;
    }

    if (e.key === 'Escape') {
      if (helpModal.classList.contains('visible')) {
          hideHelpModal();
      } else if (!document.body.classList.contains('game-mode-active')) {
          if (toggleLayoutBtn) {
              toggleLayoutBtn.click();
          }
      }
    }

    if (activeElTag === 'input' || activeElTag === 'textarea') {
      if (e.altKey) {
        if (document.activeElement.id === 'freestyle-filename-input') return;
      } else {
        return;
      }
    }

        if (e.altKey) {
        e.preventDefault();

                switch (e.key.toLowerCase()) { // 대소문자 구분 없이 처리하기 위해 toLowerCase() 추가
            // === 네비게이션 단축키 ===
            case 'arrowdown':
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) {
                        handleGameEnd(false, 'level_change'); // 게임 레벨 변경 시 재시작
                    }
                } else if (currentMode !== 'freestyle') {
                    restartCurrentPractice(); // 현재 연습 다시 시작
                }
                break;
            
            case 'arrowright':
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) changeGameLevel(1);
                } else if (currentMode.endsWith('Long')) {
                    changeLongText(1);
                } else if (currentMode !== 'freestyle') {
                    startPractice(currentMode, false);
                }
                break;

            case 'arrowleft':
                if (currentMode === 'game' && currentGameType) {
                    if (!isOverlayVisible) changeGameLevel(-1);
                } else if (currentMode.endsWith('Long')) {
                    changeLongText(-1);
                } else if (currentMode !== 'freestyle') {
                    startPractice(currentMode, false);
                }
                break;

            // === 기능 토글 단축키 ===
            case "'": // 다음 타건음
                if (soundPackSelectEl) {
                    let currentIndex = soundPackSelectEl.selectedIndex;
                    let nextIndex = (currentIndex + 1) % soundPackSelectEl.options.length;
                    soundPackSelectEl.selectedIndex = nextIndex;
                    soundPackSelectEl.dispatchEvent(new Event('change'));
                }
                break;
                
            case ';': // 이전 타건음
                if (soundPackSelectEl) {
                    let currentIndex = soundPackSelectEl.selectedIndex;
                    let prevIndex = (currentIndex - 1 + soundPackSelectEl.options.length) % soundPackSelectEl.options.length;
                    soundPackSelectEl.selectedIndex = prevIndex;
                    soundPackSelectEl.dispatchEvent(new Event('change'));
                }
                break;
            
            case 'n': // [변경] 타건음 ON/OFF
                if (toggleSoundBtn) toggleSoundBtn.click();
                break;

            case 'm': // [변경] 오타체크 ON/OFF
                if (toggleHighlightBtn) toggleHighlightBtn.click();
                break;

            case ',': // [추가] 특수기호 자동 ON/OFF
                if (toggleAutoCompleteBtn) toggleAutoCompleteBtn.click();
                break;
                
            case '.': // 측정 ON/OFF
                if (toggleStatsBtn) toggleStatsBtn.click();
                break;

            case '/': // 자리연습 ON/OFF
                if (toggleKeyboardGuideBtn) toggleKeyboardGuideBtn.click();
                break;
        }
    }
  });

  const savedLayoutState = localStorage.getItem('layoutCollapsed') === 'true';
  if (savedLayoutState) {
      layoutCollapsed = true;
      updateLayout();
  }
  
  // ==================== ▼▼▼ 3. JS 초기화 로직 수정 ▼▼▼ ====================
  const savedAutoComplete = localStorage.getItem('autoCompleteEnabled') === 'true';
  autoCompleteEnabled = savedAutoComplete;
  updateAutoCompleteButton();
  // ==================== ▲▲▲ 3. JS 초기화 로직 수정 ▲▲▲ ====================
  
  window.addEventListener('resize', alignInputField);

  startPractice('kor', true);
  setTimeout(() => {
    document.body.classList.remove('no-transition');
  }, 100);
});

// ==================== ▼▼▼ 3. JS 초기화 로직 수정 (함수 추가) ▼▼▼ ====================
function updateAutoCompleteButton() {
    if (!toggleAutoCompleteBtn) return;
    toggleAutoCompleteBtn.classList.toggle('active', autoCompleteEnabled);
    toggleAutoCompleteBtn.innerHTML = autoCompleteEnabled 
        ? '<i class="fas fa-magic"></i> 특수기호 자동 ON' 
        : '<i class="fas fa-wand-sparkles"></i> 특수문자 자동 OFF';
}
// ==================== ▲▲▲ 3. JS 초기화 로직 수정 (함수 추가) ▲▲▲ ====================

function applyFontFamily(family) {
    const root = document.documentElement;
    const config = fontConfig[family] || { scale: 1.0 };
    
    root.style.setProperty('--font-typing', family);
    root.style.setProperty('--font-scale-multiplier', config.scale);
}

function cleanupActiveModes() {
    document.body.classList.remove('game-mode-active', 'freestyle-mode-active', 'focus-mode-active');
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    freestyleStatsInterval = null;
    startTime = null;
    if(typingInputField) typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    if(gameInputField) gameInputField.removeEventListener('keydown', handleKeyDownEvent);
    enablePracticeControls();
}
// ==================== ▼▼▼ 5. 모드별 버튼 활성화/비활성화 처리 ▼▼▼ ====================
function disableFreestyleControls() {
    toggleHighlightBtn.classList.add('disabled');
    toggleKeyboardGuideBtn.classList.add('disabled');
    toggleAutoCompleteBtn.classList.add('disabled'); // 버튼 비활성화 추가
    languageSelectEl.closest('.language-settings').classList.add('disabled');
}

function enablePracticeControls() {
    toggleHighlightBtn.classList.remove('disabled');
    toggleKeyboardGuideBtn.classList.remove('disabled');
    toggleAutoCompleteBtn.classList.remove('disabled'); // 버튼 활성화 추가
    languageSelectEl.closest('.language-settings').classList.remove('disabled');
}
// ==================== ▲▲▲ 5. 모드별 버튼 활성화/비활성화 처리 ▲▲▲ ====================
function populateLongTextDropdown(lang) {
    const source = sentencePool[lang + 'Long'];
    if (!longTextSelectEl || !source) return;

    longTextSelectEl.innerHTML = '';

    const randomOption = document.createElement('option');
    randomOption.value = "-1";
    randomOption.textContent = "랜덤";
    longTextSelectEl.appendChild(randomOption);

    source.forEach((item, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = item.title;
        longTextSelectEl.appendChild(option);
    });
}
function startPractice(mode, resetSessionStats = false) {
    cleanupActiveModes();
    currentMode = mode;
    currentGameType = '';

    const isLongMode = mode.endsWith('Long');
    const lang = mode.replace('Long', '');

    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        const type = btn.dataset.practiceType;
        btn.classList.toggle('active', (isLongMode && type === 'long') || (!isLongMode && type === 'short'));
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');

    if (longTextSelectContainerEl) {
        longTextSelectContainerEl.classList.toggle('hidden', !isLongMode);
    }
    
    if(resultEl) resultEl.textContent = '새로운 문제를 불러옵니다...';
    if (typingInputField) {
        typingInputField.disabled = false;
        typingInputField.value = '';
        typingInputField.addEventListener('keydown', handleKeyDownEvent);
    }
    if (statsVisible && statsEl) statsEl.classList.remove('hidden');

    if (resetSessionStats) {
        overallMaxSpeed = 0; overallAvgSpeedLog = [];
        sessionTotalValidChars = 0; sessionTotalCorrectChars = 0; sessionTotalMistypedChars = 0;
        lastArticleSpeed = 0;
    }
    currentLineStartTime = null;
    currentArticleCorrectChars = 0;
    currentDisplayLineIndex = 0;
    
    const source = sentencePool[mode];
    let textToPractice = "";
    let titleToDisplay = "";

    if (!source || source.length === 0) {
        linesToPractice = ["선택한 언어 또는 모드에 대한 예문이 없습니다."];
    } else {
        if (isLongMode) {
            if (resetSessionStats) {
                populateLongTextDropdown(lang);
            }
            
            let selectedIndex = parseInt(longTextSelectEl.value, 10);
            
            if (resetSessionStats || selectedIndex === -1 || isNaN(selectedIndex)) {
                const randomIndex = Math.floor(Math.random() * source.length);
                textToPractice = source[randomIndex].content;
                titleToDisplay = source[randomIndex].title;
                longTextSelectEl.value = randomIndex;
            } else {
                textToPractice = source[selectedIndex].content;
                titleToDisplay = source[selectedIndex].title;
            }
        } else {
            textToPractice = getRandom(source);
        }
        linesToPractice = splitTextIntoLines(textToPractice, currentMode, window.innerWidth);
    }

    if (practiceTitleDisplayEl) {
        practiceTitleDisplayEl.textContent = titleToDisplay;
    }
    
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    
    if (progressBarContainerEl) {
        progressBarContainerEl.style.display = isLongMode && linesToPractice.length > 1 ? 'block' : 'none';
    }

    renderTypingLayout();
    if(resultEl) resultEl.textContent = '타자를 시작하세요!';
    updateStatsDisplay(resetSessionStats);
    updateProgressBar();
    updateFakeInput('', true);
    updateKeyboardDisplay();
    updateKeyboardHighlight();
    setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
}
function startFreestyleMode() {
    cleanupActiveModes();
    document.body.classList.add('freestyle-mode-active');
    currentMode = 'freestyle';
    document.querySelectorAll('.practice-mode-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === 'freestyle');
    });
    if (gameModeBtnEl) gameModeBtnEl.classList.remove('active');
    if (longTextSelectContainerEl) {
        longTextSelectContainerEl.classList.add('hidden');
    }
    disableFreestyleControls();
    if (statsVisible) {
        statsVisible = false;
        toggleStatsBtn.classList.remove('active');
        toggleStatsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 측정 OFF';
        statsEl.classList.add('hidden');
    }
    if (toggleHighlightBtn.classList.contains('active')) toggleHighlightBtn.classList.remove('active');
    if (toggleKeyboardGuideBtn.classList.contains('active')) toggleKeyboardGuideBtn.classList.remove('active');
    highlightEnabled = false;
    keyboardGuideEnabled = false;
    if (keyboardGuideEl) keyboardGuideEl.classList.remove('visible');
    if (resultEl) resultEl.textContent = '자유롭게 글을 작성하고 타건을 즐겨보세요.';
    startTime = null;
    overallMaxSpeed = 0;
    overallAvgSpeedLog = [];
    sessionTotalValidChars = 0;
    sessionTotalCorrectChars = 0;
    sessionTotalMistypedChars = 0;
    lastArticleSpeed = 0;
    updateStatsDisplay(true);
    if (document.getElementById('accuracyStat')) document.getElementById('accuracyStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('avgSpeedStat')) document.getElementById('avgSpeedStat').innerHTML = '<span class="value">—</span>';
    if (document.getElementById('maxSpeedStat')) document.getElementById('maxSpeedStat').innerHTML = '<span class="value">—</span>';
    freestyleInputAreaEl.value = '';
    freestyleInputAreaEl.focus();
    updateFreestyleStats();
    if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
    freestyleStatsInterval = setInterval(updateFreestyleStats, 500);
}
function updateFreestyleStats() {
    if (currentMode !== 'freestyle') {
        if(freestyleStatsInterval) clearInterval(freestyleStatsInterval);
        return;
    };
    const text = freestyleInputAreaEl.value;
    const charLength = text.length;
    const wordLength = text.trim().split(/\s+/).filter(Boolean).length;
    charCountEl.textContent = `${charLength}자`;
    wordCountEl.textContent = `${wordLength}단어`;
    if (startTime) {
        const elapsedMinutes = (Date.now() - startTime) / 60000;
        if (elapsedMinutes > 0) {
            const speed = Math.round((charLength / elapsedMinutes) * KOR_SPEED_FACTOR);
            if (statsVisible && document.getElementById('speedStat')) {
                document.getElementById('speedStat').textContent = `${speed} 타/분`;
            }
        }
    }
}
function handleFreestyleDownload() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        alert('저장할 내용이 없습니다.');
        return;
    }
    let filename = freestyleFilenameInputEl.value.trim();
    if (filename === '') {
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        filename = `keytherapy_${timestamp}`;
    }
    if (!filename.toLowerCase().endsWith('.txt')) {
        filename += '.txt';
    }
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function insertAtCursor(myField, myValue) {
    if (document.selection) {
        myField.focus();
        sel = document.selection.createRange();
        sel.text = myValue;
    }
    else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length;
        myField.selectionEnd = startPos + myValue.length;
    } else {
        myField.value += myValue;
    }
    updateFreestyleStats();
    myField.focus();
}
function copyAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') {
        showSharePopup("복사할 내용이 없습니다.");
        return;
    }
    navigator.clipboard.writeText(text).then(() => {
        showSharePopup("클립보드에 복사되었습니다.");
    }).catch(err => {
        console.error('클립보드 복사 실패:', err);
        showSharePopup("복사에 실패했습니다.");
    });
    freestyleInputAreaEl.focus();
}
function clearAllFreestyleText() {
    const text = freestyleInputAreaEl.value;
    if (text.trim() === '') return;
    if (confirm("정말 모든 내용을 삭제하시겠습니까?")) {
        freestyleInputAreaEl.value = '';
        updateFreestyleStats();
        freestyleInputAreaEl.focus();
    }
}
function insertDate() {
    const now = new Date();
    const dateString = `${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일`;
    insertAtCursor(freestyleInputAreaEl, dateString + " ");
}
function insertTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const formattedHours = (hours % 12) || 12;
    const timeString = `${ampm} ${formattedHours}:${minutes}`;
    insertAtCursor(freestyleInputAreaEl, timeString + " ");
}
function hexToRgb(hex) {
    if (!hex) return null;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function splitTextIntoLines(text, mode, screenWidth) {
    if (mode.startsWith('js') || mode.startsWith('python')) {
        return text.split('\n');
    }
    let maxLength;
    if (mode.endsWith('Long')) {
        if (screenWidth <= 480) maxLength = mode.startsWith('eng') ? 40 : 25;
        else if (screenWidth <= 768) maxLength = mode.startsWith('eng') ? 55 : 35;
        else maxLength = mode.startsWith('eng') ? 65 : 40;
    } else {
        maxLength = 1000;
    }
    const lines = [];
    if (!text || typeof text !== 'string') return [""];
    if (maxLength === 1000 || !mode.endsWith('Long')) {
        lines.push(text.trim());
    } else {
        let currentLine = "";
        const words = text.split(/(\s+)/);
        for (const word of words) {
            if (currentLine.length > 0 && currentLine.length + word.trim().length > maxLength && !/^\s+$/.test(word)) {
                lines.push(currentLine.trim());
                currentLine = "";
            }
            currentLine += word;
        }
        if (currentLine.trim().length > 0) lines.push(currentLine.trim());
    }
    return lines.length > 0 ? lines : [text.trim()];
}
function handleHighlightUpdate(typedValue, originalLine) {
    if (typeof originalLine !== 'string' || !originalLine) {
        return ' ';
    }

    let builtHTML = "";
    let originalIdx = 0;
    let typedIdx = 0;

    // 입력된 텍스트나 원본 텍스트 중 하나라도 끝에 도달할 때까지 반복
    while (originalIdx < originalLine.length || typedIdx < typedValue.length) {
        const originalChar = originalLine[originalIdx];
        const typedChar = typedValue[typedIdx];

        // 1. 원본 텍스트는 끝났는데 사용자가 더 입력한 경우 (글자 수 추가 오타)
        if (originalIdx >= originalLine.length) {
            // 남은 오타 글자들을 highlight 처리
            const remainingTyped = typedValue.substring(typedIdx).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
            builtHTML += `<span class="highlight">${remainingTyped}</span>`;
            break; // 더 이상 비교할 원본이 없으므로 종료
        }

        // 2. 입력된 텍스트가 아직 원본보다 짧은 경우 (아직 입력 안 한 부분)
        if (typedIdx >= typedValue.length) {
            // [핵심 수정] 남은 텍스트 전체를 가져와서 formatCodeLineForDisplay로 처리
            const remainingLine = originalLine.substring(originalIdx);
            builtHTML += `<span class="untyped-char">${formatCodeLineForDisplay(remainingLine)}</span>`;
            break; // 나머지 부분을 한 번에 처리했으므로 루프 종료
        }

        const displayChar = originalChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');

        // 3. 글자가 정확히 일치하는 경우
        if (originalChar === typedChar) {
            builtHTML += `<strong>${displayChar}</strong>`;
            originalIdx++;
            typedIdx++;
        }
        // 4. 글자가 일치하지 않는 경우 (지능적 오타 처리)
        else {
            // [삭제 오타 감지] 사용자가 한 글자 건너뛰었는가?
            if (originalIdx + 1 < originalLine.length && originalLine[originalIdx + 1] === typedChar) {
                builtHTML += `<span class="highlight">${displayChar}</span>`; // 건너뛴 글자를 오타 처리
                originalIdx++;
            }
            // [삽입 오타 감지] 사용자가 한 글자 더 쳤는가?
            else if (typedIdx + 1 < typedValue.length && originalChar === typedValue[typedIdx + 1]) {
                const wrongTypedChar = typedChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                builtHTML += `<span class="highlight">${wrongTypedChar}</span>`; // 잘못 삽입된 글자를 오타 처리
                typedIdx++;
            }
            // [단순 오타] 위 두 경우가 모두 아니면 단순 오타로 처리
            else {
                builtHTML += `<span class="highlight">${displayChar}</span>`;
                originalIdx++;
                typedIdx++;
            }
        }
    }

    return builtHTML || ' ';
}
function renderTypingLayout() {
    if (!lineDisplayArea || !upcomingLinesArea) return;
    lineDisplayArea.innerHTML = '';
    upcomingLinesArea.innerHTML = '';
    const fragmentPassedCurrent = document.createDocumentFragment();
    const fragmentUpcoming = document.createDocumentFragment();
    const passedLineText = (currentDisplayLineIndex > 0 && linesToPractice[currentDisplayLineIndex - 1] !== undefined) ? linesToPractice[currentDisplayLineIndex - 1] : " ";
    const passedEl = document.createElement('div');
    passedEl.classList.add('typing-line', 'passed');
    passedEl.innerHTML = `<span>${formatCodeLineForDisplay(passedLineText)}</span>`;
    if (passedLineText === " ") passedEl.style.visibility = 'hidden';
    fragmentPassedCurrent.appendChild(passedEl);
    const currentLineText = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : "";
    const currentEl = document.createElement('div');
    currentEl.id = 'current-typing-line';
    currentEl.classList.add('typing-line');
    if (currentLineText !== null && currentLineText !== undefined && currentLineText.length > 0) {
        currentEl.classList.add('current-to-type');
        currentEl.dataset.originalLine = currentLineText;
        const highlightedHTML = handleHighlightUpdate("", currentLineText);
        currentEl.innerHTML = `<span>${highlightedHTML}</span>`;
    } else {
        currentEl.innerHTML = '<span>&nbsp;</span>';
        currentEl.style.boxShadow = 'none';
        currentEl.style.backgroundColor = 'transparent';
        currentEl.style.border = '1px solid transparent';
    }
    fragmentPassedCurrent.appendChild(currentEl);
    lineDisplayArea.appendChild(fragmentPassedCurrent);
    for (let i = 1; i <= MAX_VISIBLE_UPCOMING_LINES; i++) {
        const upcomingIndex = currentDisplayLineIndex + i;
        const upcomingEl = document.createElement('div');
        upcomingEl.classList.add('typing-line', 'upcoming');
        if (upcomingIndex < linesToPractice.length && linesToPractice[upcomingIndex] !== undefined) {
            const upcomingLineText = linesToPractice[upcomingIndex];
            upcomingEl.innerHTML = `<span>${formatCodeLineForDisplay(upcomingLineText)}</span>`;
        } else {
            upcomingEl.innerHTML = '<span>&nbsp;</span>';
            upcomingEl.style.visibility = 'hidden';
        }
        fragmentUpcoming.appendChild(upcomingEl);
    }
    upcomingLinesArea.appendChild(fragmentUpcoming);
    alignInputField();
}

// ▼▼▼ 아래 코드 묶음 전체(함수 7개)를 복사해서 붙여넣으세요 ▼▼▼

function isSpecialCharacter(char) {
    return /[.,?!;:'"(){}[\]\/\-=\+_`~@#$%^&*|\\<>]/.test(char);
}

function formatCodeLineForDisplay(line) {
    if (!line) return '';
    const isCodeMode = currentMode.startsWith('js') || currentMode.startsWith('python');
    if (isCodeMode) {
        const match = line.match(/^( +)/);
        if (match) {
            const spaces = match[1];
            const restOfLine = line.substring(spaces.length);
            const visibleSpaces = `<span class="whitespace-char">${'·'.repeat(spaces.length)}</span>`;
            const escapedRest = restOfLine.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
            return visibleSpaces + escapedRest;
        }
    }
    return line.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
}

function updateFakeInput(typedValue, isReset = false) {
    if (!fakeInputField) return;

    if (isReset) {
        fakeInputField.innerHTML = `<span class="placeholder">타자 연습 시작...</span>`;
        return;
    }
    
    const placeholder = fakeInputField.querySelector('.placeholder');
    if (placeholder) placeholder.remove();

    if (typedValue.length === 0) {
        fakeInputField.innerHTML = `<span><span id="cursor"></span></span>`;
    } else {
        const escapedValue = typedValue.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
        fakeInputField.innerHTML = `<span>${escapedValue}<span id="cursor"></span></span>`;
    }
}


/**
 * [최종 아키텍처] 모든 타이핑 분석을 통합 처리하는 마스터 함수.
 * @param {string} typedValue - 사용자가 입력한 문자열
 * @param {string} originalLine - 원본 문자열
 * @returns {{html: string, effectiveIndex: number, correctChars: number}} - 분석 결과 객체
 */
function getTypingAnalysis(typedValue, originalLine) {
    if (!originalLine) {
        return { html: `<span class="highlight">${typedValue}</span>`, effectiveIndex: 0, correctChars: 0 };
    }
    if (typedValue.length === 0) {
        return {
            html: `<span class="untyped-char">${formatCodeLineForDisplay(originalLine)}</span>`,
            effectiveIndex: 0,
            correctChars: 0
        };
    }

    let builtHTML = "";
    let typedIdx = 0;
    let originalIdx = 0;
    let correctChars = 0;

    while (typedIdx < typedValue.length && originalIdx < originalLine.length) {
        const originalChar = originalLine[originalIdx];
        const typedChar = typedValue[typedIdx];
        const safeOriginalChar = originalChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/ /g, ' ');
        const safeTypedChar = typedChar.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/ /g, ' ');
        
        const errorTag = highlightEnabled ? 'span' : 'strong';
        const highlightClass = highlightEnabled ? 'highlight' : '';

        if (typedChar === originalChar) {
            builtHTML += `<strong>${safeOriginalChar}</strong>`;
            correctChars++;
            typedIdx++;
            originalIdx++;
        } else {
            const nextOriginalChar = (originalIdx + 1 < originalLine.length) ? originalLine[originalIdx + 1] : null;
            const nextTypedChar = (typedIdx + 1 < typedValue.length) ? typedValue[typedIdx + 1] : null;
            
            if (typedChar === nextOriginalChar) {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeOriginalChar}</${errorTag}>`;
                originalIdx++;
            } else if (nextTypedChar === originalChar) {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeTypedChar}</${errorTag}>`;
                typedIdx++;
            } else {
                builtHTML += `<${errorTag} class="${highlightClass}">${safeOriginalChar}</${errorTag}>`;
                typedIdx++;
                originalIdx++;
            }
        }
    }

    if (typedIdx < typedValue.length) {
        const remainingTyped = typedValue.substring(typedIdx).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
        const highlightClass = highlightEnabled ? 'highlight' : '';
        builtHTML += `<span class="${highlightClass}">${remainingTyped}</span>`;
    }

    if (originalIdx < originalLine.length) {
        const remaining = originalLine.substring(originalIdx);
        builtHTML += `<span class="untyped-char">${formatCodeLineForDisplay(remaining)}</span>`;
    }

    return { html: builtHTML, effectiveIndex: originalIdx, correctChars: correctChars };
}


function handleInputEvent(e) {
    if (isProgrammaticallyChangingInput) {
        return;
    }

    playTypingSound();

    if (currentMode !== 'game' && currentMode !== 'freestyle' && e.target === typingInputField) {
        const typedValue = e.target.value;
        const originalLine = linesToPractice[currentDisplayLineIndex] || "";

        // --- 1. [핵심] 모든 시각적 업데이트는 항상 즉시 실행 ---
        const analysis = getTypingAnalysis(typedValue, originalLine);
        
        const currentLineEl = document.getElementById('current-typing-line');
        if (currentLineEl) {
            const innerSpan = currentLineEl.querySelector('span');
            if (innerSpan) innerSpan.innerHTML = analysis.html;
        }
        updateFakeInput(typedValue, false);
        updateKeyboardHighlight(); // 이 함수가 항상 실행되어야 모음도 추천됩니다.

        // --- 2. 한글 조합 중이라면, 여기서 실행을 멈춥니다. ---
        if (isComposingNow) {
            return;
        }
        
        // --- 3. 조합이 끝난 후에만 아래의 기능적 로직을 실행합니다. ---
        
        // 통계 업데이트
        if (typedValue.length > 0) {
            if (!startTime) startTime = Date.now();
            if (originalLine && !currentLineStartTime) currentLineStartTime = Date.now();
            if (startTime) updateStatsDisplay(false);
        } else if (startTime && typedValue.length === 0) {
            updateStatsDisplay(false);
        }

        // 자동 완성 로직
        const effectiveIndex = analysis.effectiveIndex;
        const isDeletion = e.inputType && e.inputType.startsWith('delete');
        
        if (autoCompleteEnabled && !isDeletion && typedValue.length > 0) {
            if (effectiveIndex < originalLine.length) {
                const nextCharInOriginal = originalLine[effectiveIndex];
                if (isSpecialCharacter(nextCharInOriginal)) {
                    let textToAppend = "";
                    let lookaheadIndex = effectiveIndex;
                    while (lookaheadIndex < originalLine.length && isSpecialCharacter(originalLine[lookaheadIndex])) {
                        textToAppend += originalLine[lookaheadIndex];
                        lookaheadIndex++;
                    }
                    if (textToAppend.length > 0) {
                        isProgrammaticallyChangingInput = true;
                        const newTypedValue = typedValue + textToAppend;
                        typingInputField.value = newTypedValue;
                        isProgrammaticallyChangingInput = false;

                        const newAnalysis = getTypingAnalysis(newTypedValue, originalLine);
                        const innerSpan = document.querySelector('#current-typing-line span');
                        if (innerSpan) innerSpan.innerHTML = newAnalysis.html;
                        updateFakeInput(newTypedValue, false);
                    }
                }
            }
        }
    }
}

function handleKeyDownEvent(e) {
    if (e.isComposing) return;
    playTypingSound();
    const targetInput = e.target;
    if (currentMode === 'game' && targetInput === gameInputField) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            playTypingSound();
            if (currentGameType === 'rainfall') {
                handleRainfallGameInputSubmit();
            } else if (currentGameType === 'letterBlockBattle') {
                handleLetterBlockBattleInputSubmit();
            } else if (currentGameType === 'giantBattle') {
                handleGiantBattleInputSubmit();
            }
            return;
        }
        if (e.key === 'Backspace') {
            playTypingSound();
        }
        return;
    }
   if (currentMode !== 'game' && currentMode !== 'freestyle' && targetInput === typingInputField) {
        const typedValue = typingInputField.value;
        const originalLine = (currentDisplayLineIndex < linesToPractice.length) ? linesToPractice[currentDisplayLineIndex] : null;
        if (e.key === 'Enter') {
            e.preventDefault();
            if (originalLine !== null && originalLine !== undefined) {
                processCurrentLineCompletion();
            } else if (currentDisplayLineIndex >= linesToPractice.length) {
                startPractice(currentMode, false);
            }
        } else if (e.key === ' ' && originalLine !== null && typedValue.length >= originalLine.length) {
            e.preventDefault();
            processCurrentLineCompletion();
        }
    }
}

function processCurrentLineCompletion() {
    const typedValue = typingInputField.value;
    if (currentDisplayLineIndex >= linesToPractice.length) {
        startPractice(currentMode, false); return;
    }
    const originalLine = linesToPractice[currentDisplayLineIndex];
    if (originalLine === null || originalLine === undefined) {
        currentDisplayLineIndex++;
        if (currentDisplayLineIndex < linesToPractice.length) renderTypingLayout();
        else startPractice(currentMode, false);
        return;
    }

    const analysis = getTypingAnalysis(typedValue, originalLine);
    const lineCorrectCharsThisLine = analysis.correctChars;
    const lineMistypedCharsOnThisLine = typedValue.length - lineCorrectCharsThisLine;

    currentArticleCorrectChars += lineCorrectCharsThisLine;
    sessionTotalCorrectChars += lineCorrectCharsThisLine;
    sessionTotalMistypedChars += lineMistypedCharsOnThisLine;
    sessionTotalValidChars += originalLine.length;
    
    if (currentLineStartTime && lineCorrectCharsThisLine > 0) {
        const elapsedLineMinutes = (Date.now() - currentLineStartTime) / 60000;
        const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
        if (elapsedLineMinutes > 0.0001) {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / elapsedLineMinutes) * speedFactor);
        } else {
            lastArticleSpeed = Math.round((lineCorrectCharsThisLine / (0.5 / 60000)) * speedFactor);
        }
        if (lastArticleSpeed > 0 && lastArticleSpeed < 5000) {
            overallAvgSpeedLog.push(lastArticleSpeed);
            if (lastArticleSpeed > overallMaxSpeed) overallMaxSpeed = lastArticleSpeed;
        }
    } else if (originalLine.length > 0) {
        lastArticleSpeed = 0;
         if (overallAvgSpeedLog.length > 0 || lastArticleSpeed === 0) overallAvgSpeedLog.push(0);
    }

    currentDisplayLineIndex++;
    disassembledLine = Hangul.disassemble(linesToPractice[currentDisplayLineIndex] || '');
    if(typingInputField) {
        typingInputField.value = '';
        updateFakeInput('', true);
    }
    currentLineStartTime = null;
    if (!currentMode.endsWith('Long')) {
        currentArticleCorrectChars = 0;
        startTime = null;
    }
    if (currentDisplayLineIndex < linesToPractice.length) {
        renderTypingLayout();
        updateKeyboardHighlight();
        if(resultEl) resultEl.textContent = currentMode.endsWith('Long') ? '다음 줄...' : '다음 문제!';
        updateStatsDisplay(false);
        updateProgressBar();
        setTimeout(() => { if(typingInputField) typingInputField.focus(); }, 50);
    } else {
        updateStatsDisplay(false);
        updateProgressBar();
        if (currentMode.endsWith('Long')) {
            const finalAccuracy = sessionTotalValidChars > 0 ? Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100) : 0;
            const avgSpeed = overallAvgSpeedLog.length > 0 ? Math.round(overallAvgSpeedLog.reduce((a, b) => a + b, 0) / overallAvgSpeedLog.length) : 0;
            
            showResultOverlay({
                type: 'practice',
                title: '연습 완료!',
                stats: {
                    "평균 속도": `${avgSpeed} 타/분`,
                    "최고 속도": `${overallMaxSpeed} 타/분`,
                    "정확도": `${finalAccuracy}%`
                },
                nextAction: () => startPractice(currentMode, false),
                nextActionText: "다시하기 (Enter)"
            });
            currentArticleCorrectChars = 0;
            startTime = null;
        } else {
            if(resultEl) resultEl.textContent = '연습 완료! 새로운 문제 준비 중...';
            setTimeout(() => startPractice(currentMode, false), 200);
        }
    }
}

// ▲▲▲ 여기까지가 한 묶음 ▲▲▲

function updateStatsDisplay(isSessionReset = false) {
  const statsElements = {
    speed: document.getElementById('speedStat'),
    accuracy: document.getElementById('accuracyStat'),
    avg: document.getElementById('avgSpeedStat'),
    max: document.getElementById('maxSpeedStat')
  };
  if (!Object.values(statsElements).every(el => el)) return;
  let currentSpeedToShow = 0;
  if (isSessionReset) {
      currentSpeedToShow = 0;
  } else if (startTime === null && !currentMode.endsWith('Long')) {
      currentSpeedToShow = lastArticleSpeed;
  } else if (currentMode.endsWith('Long') && startTime && currentArticleCorrectChars > 0) {
      const elapsedMinutes = (Date.now() - startTime) / 60000;
      const speedFactor = (currentMode.startsWith('kor')) ? KOR_SPEED_FACTOR : 1;
      if (elapsedMinutes > 0.0001) {
        currentSpeedToShow = Math.round((currentArticleCorrectChars / elapsedMinutes) * speedFactor);
      } else {
        currentSpeedToShow = 0;
      }
  } else {
      currentSpeedToShow = lastArticleSpeed;
  }
  statsElements.speed.textContent = `${currentSpeedToShow} 타/분`;
  let accuracy = 0;
  if (isSessionReset) {
      accuracy = 0;
  } else if (sessionTotalValidChars > 0) {
      accuracy = Math.max(0, Math.min(Math.round((sessionTotalCorrectChars / sessionTotalValidChars) * 100), 100));
  }
  statsElements.accuracy.textContent = `${accuracy}%`;
  let finalOverallAverageSpeed = 0;
  if (isSessionReset) {
      finalOverallAverageSpeed = 0;
  } else if (overallAvgSpeedLog.length > 0) {
      finalOverallAverageSpeed = Math.round(overallAvgSpeedLog.reduce((a,b) => a+b,0) / overallAvgSpeedLog.length);
  }
  statsElements.avg.textContent = `${finalOverallAverageSpeed} 타/분`;
  statsElements.max.textContent = `${isSessionReset ? 0 : overallMaxSpeed} 타/분`;
}
function updateProgressBar() {
    if (progressBarEl && progressBarContainerEl && linesToPractice.length > 0 && currentMode.endsWith('Long')) {
        const progress = linesToPractice.length > 1 ? (currentDisplayLineIndex / linesToPractice.length) * 100 : (currentDisplayLineIndex >= 1 ? 100 : 0);
        progressBarEl.style.width = `${Math.min(progress, 100)}%`;
    } else if (progressBarEl) {
        progressBarEl.style.width = '0%';
    }
}
function activateGameMode(gameType) {
    cleanupActiveModes();
    document.body.classList.add('game-mode-active');
    currentMode = 'game';
    currentGameType = gameType;
    if (typingInputField) {
        typingInputField.removeEventListener('keydown', handleKeyDownEvent);
    }
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
    if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
    if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
    if (lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
    if (lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
    if (lbb_enemyNoPlayableBlocksTimerId) clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
    if (lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
    rainfall_isGameActive = false;
    lbb_isGameActive = false;
    gb_isGameActive = false;
    rainfall_isTimeStopped = false;
    lbb_isEnemyFrozen = false;
    lbb_finalBattleAnimation.isActive = false;
    lbb_isRelocating = false;
    lbb_playerNoPlayableBlocksTimerId = null;
    lbb_enemyNoPlayableBlocksTimerId = null;
    lbb_relocationCountdownIntervalId = null;
    lbb_relocationCountdown = 0;
    gameAreaContainerEl.innerHTML = `
        <div id="gameInternalControlsBar">
            <div class="game-control-row" id="gameTypeSelectionRow"></div>
            <div class="game-control-row" id="gameSettingsRow1"></div>
            <div class="game-control-row" id="gameSettingsRow2"></div>
        </div>
        <div class="game-ui-wrapper">
            <div id="game-start-message"></div>
            <canvas id="game-canvas"></canvas>
            <div id="lbb-timer-bar-container" style="display: none;">
                <div id="lbb-timer-bar"></div>
                <span id="lbb-timer-text"></span>
            </div>
            <input type="text" id="game-input-field" autocorrect="off" autocapitalize="off" spellcheck="false" autocomplete="off" placeholder="">
        </div>
        <div id="item-effect-popup"></div>
        <div id="gameOverlay" class="game-overlay"></div>`;
    gameStartMessageEl = gameAreaContainerEl.querySelector('#game-start-message');
    gameCanvas = gameAreaContainerEl.querySelector('#game-canvas');
    if (gameCanvas) {
        gameCtx = gameCanvas.getContext('2d');
    } else {
        console.error("activateGameMode: game-canvas 요소를 찾을 수 없습니다.");
        return;
    }
    gameInputField = gameAreaContainerEl.querySelector('#game-input-field');
    gameOverlayEl = gameAreaContainerEl.querySelector('#gameOverlay');
    itemEffectPopupEl = gameAreaContainerEl.querySelector('#item-effect-popup');
    lbbTimerBarContainerEl = gameAreaContainerEl.querySelector('#lbb-timer-bar-container');
    lbbTimerBarEl = gameAreaContainerEl.querySelector('#lbb-timer-bar');
    lbbTimerTextEl = gameAreaContainerEl.querySelector('#lbb-timer-text');
    if (gameInputField) {
        gameInputField.removeEventListener('keydown', handleKeyDownEvent);
        gameInputField.addEventListener('keydown', handleKeyDownEvent);
        gameInputField.removeEventListener('input', handleInputEvent);
        gameInputField.addEventListener('input', handleInputEvent);
    }
    const gameTypeRow = gameAreaContainerEl.querySelector('#gameTypeSelectionRow');
    const settingsRow1 = gameAreaContainerEl.querySelector('#gameSettingsRow1');
    const settingsRow2 = gameAreaContainerEl.querySelector('#gameSettingsRow2');
    if (!gameTypeRow || !settingsRow1 || !settingsRow2) {
        console.error("게임 컨트롤 바 요소를 찾을 수 없습니다. HTML 구조를 확인하세요.");
        return;
    }
    gameTypeRow.innerHTML = '';
    const sonagiBtn = document.createElement('button');
    sonagiBtn.classList.add('game-type-button');
    sonagiBtn.innerHTML = '<i class="fas fa-cloud-showers-heavy"></i> 소나기';
    sonagiBtn.dataset.game = 'rainfall';
    if (currentGameType === 'rainfall') sonagiBtn.classList.add('active');
    sonagiBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('rainfall');
    });
    gameTypeRow.appendChild(sonagiBtn);
    const letterBlockBtn = document.createElement('button');
    letterBlockBtn.classList.add('game-type-button');
    letterBlockBtn.innerHTML = '<i class="fas fa-th-large"></i> 블록 배틀';
    letterBlockBtn.dataset.game = 'letterBlockBattle';
    if (currentGameType === 'letterBlockBattle') letterBlockBtn.classList.add('active');
    letterBlockBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('letterBlockBattle');
    });
    gameTypeRow.appendChild(letterBlockBtn);
    const typingBattleBtn = document.createElement('button');
    typingBattleBtn.classList.add('game-type-button');
    typingBattleBtn.innerHTML = '<i class="fas fa-fist-raised"></i> 타이핑 배틀';
    typingBattleBtn.dataset.game = 'giantBattle';
    if (currentGameType === 'giantBattle') typingBattleBtn.classList.add('active');
    typingBattleBtn.addEventListener('click', () => {
        showShortcutTooltipTemporarily();
        activateGameMode('giantBattle');
    });
    gameTypeRow.appendChild(typingBattleBtn);
    settingsRow1.innerHTML = ''; 
    settingsRow2.innerHTML = '';
    const themeControlItem = document.createElement('div');
    themeControlItem.classList.add('game-control-item');
    themeControlItem.appendChild(themeSettingsEl);
    settingsRow1.appendChild(themeControlItem);
    const soundPackControlItem = document.createElement('div');
    soundPackControlItem.classList.add('game-control-item');
    soundPackControlItem.appendChild(soundSettingsEl);
    settingsRow1.appendChild(soundPackControlItem);
    gameToggleSoundBtn = document.createElement('button');
    gameToggleSoundBtn.id = 'gameToggleSoundBtn';
    gameToggleSoundBtn.classList.toggle('active', soundEnabled);
    gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
    gameToggleSoundBtn.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        gameToggleSoundBtn.classList.toggle('active', soundEnabled);
        gameToggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        if(toggleSoundBtn) {
            toggleSoundBtn.classList.toggle('active', soundEnabled);
            toggleSoundBtn.innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i> 타건음 ON' : '<i class="fas fa-volume-mute"></i> 타건음 OFF';
        }
    });
    const soundToggleControlItem = document.createElement('div');
    soundToggleControlItem.classList.add('game-control-item');
    soundToggleControlItem.appendChild(gameToggleSoundBtn);
    settingsRow1.appendChild(soundToggleControlItem);
    const levelControlItem = document.createElement('div');
    levelControlItem.classList.add('game-control-item');
    const levelSelectLabel = document.createElement('label');
    levelSelectLabel.htmlFor = 'gameLevelSelectInBar';
    levelSelectLabel.classList.add('select-label');
    levelSelectLabel.textContent = '레벨:';
    const gameLevelSelectInBar = document.createElement('select');
    gameLevelSelectInBar.id = 'gameLevelSelectInBar';
    gameLevelSelectInBar.className = 'game-control-select';
    let maxLevelForSelect;
    let currentLevelForSelect;
    if (gameType === 'rainfall') {
        maxLevelForSelect = rainfall_gameMainLevelsConfig.length;
        currentLevelForSelect = rainfall_gameLevel;
    } else if (gameType === 'letterBlockBattle') {
        maxLevelForSelect = LBB_MAX_LEVEL;
        currentLevelForSelect = lbb_gameLevel;
    } else if (gameType === 'giantBattle') {
        maxLevelForSelect = GB_MAX_LEVEL;
        currentLevelForSelect = gb_currentLevel;
    }
    for (let i = 1; i <= maxLevelForSelect; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i}`;
        gameLevelSelectInBar.appendChild(option);
    }
    gameLevelSelectInBar.value = currentLevelForSelect;
     gameLevelSelectInBar.addEventListener('change', (e) => {
        const newLevel = parseInt(e.target.value);
        let isActive = false;
        let isCountingDown = !!countdownTimerId;

        if (currentGameType === 'rainfall') {
            rainfall_gameLevel = newLevel;
            isActive = rainfall_isGameActive;
        } else if (currentGameType === 'letterBlockBattle') {
            lbb_gameLevel = newLevel;
            isActive = lbb_isGameActive;
        } else if (currentGameType === 'giantBattle') {
            gb_currentLevel = newLevel;
            isActive = gb_isGameActive;
        }
        if (isActive || isCountingDown) {
            handleGameEnd(false, 'level_change');
        }
    });
    levelControlItem.appendChild(levelSelectLabel);
    levelControlItem.appendChild(gameLevelSelectInBar);
    settingsRow2.appendChild(levelControlItem);
    const returnBtn = document.createElement('button');
    returnBtn.id = 'returnToPracticeBtnGame';
    returnBtn.innerHTML = `<i class="fas fa-keyboard"></i> 타자연습 가기`;
    returnBtn.addEventListener('click', () => returnToPracticeMode(true));
    settingsRow2.appendChild(returnBtn);
    const containerWidth = gameAreaContainerEl.querySelector('.game-ui-wrapper').clientWidth;
    gameCanvas.width = Math.min(containerWidth > 0 ? containerWidth : 600, 800);
    gameCanvas.height = Math.max(window.innerHeight * 0.55, 350);
    if (gameType === 'letterBlockBattle') {
        gameCanvas.height = Math.max(window.innerHeight * 0.48, 300);
        const boardAreaHeight = gameCanvas.height - 50;
        LBB_BLOCK_SIZE = Math.floor(Math.min(gameCanvas.width / LBB_BOARD_COLS, boardAreaHeight / LBB_BOARD_ROWS));
        const baseFontSize = LBB_BLOCK_SIZE * 0.28;
        lbb_blockTextFont = `bold ${Math.max(6, baseFontSize)}px 'Noto Sans KR', sans-serif`;
    }

    const startGameButtonHTML = `<button id="startGameBtn" class="game-button"><i class="fas fa-play"></i> 게임 시작 (Enter)</button>`;
    
    if (gameType === 'rainfall') {
        gameStartMessageEl.innerHTML = `
             <h2><i class="fas fa-cloud-showers-heavy"></i> 소나기</h2>
             <p>떨어지는 단어를 빠르게 입력하세요!<br>레벨을 선택하고 게임 시작 버튼을 눌러주세요.<br>각 레벨은 2분 동안 3단계의 난이도로 진행됩니다.</p>
             <div class="item-info">
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text} (+1 생명)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text} (3초 멈춤)</div>
                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text} (화면 정리)</div>
             </div>
             ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initRainfallGame, [true, selectedLevel]);
        });
        drawRainfallGame();
    } else if (gameType === 'letterBlockBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-th-large"></i> 블록 배틀</h2>
            <p>상하좌우 블록의 단어를 입력하여 이동하고, 적과 빈 칸으로 연결되면 승리합니다!<br>2분 안에 승부가 나지 않는다면 획득한 점수로 승패가 결정됩니다.</p>
            <div class="item-info">
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: ${LBB_BLOCK_EFFECT_TYPES.YELLOW.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: ${LBB_BLOCK_EFFECT_TYPES.RED.score}점</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: ${LBB_BLOCK_EFFECT_TYPES.BLUE.score}점 + 적 2초 정지</div>
               <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 너와 나의 위치 변경!</div>
            </div>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initLetterBlockBattleGame, [true, selectedLevel]);
        });
        generateLBBGameBoard();
        drawLetterBlockBattleGame();
    } else if (gameType === 'giantBattle') {
        gameStartMessageEl.innerHTML = `
            <h2><i class="fas fa-fist-raised"></i> 타이핑 배틀</h2>
            <p>쏟아지는 단어들을 정확히 입력하여 적의 공격을 막아내고,<br>당신의 공격 단어로 적을 격파하세요! 2분 안에 승리하세요!</p>
            <p>레벨을 선택하고 게임 시작 버튼을 누르세요.</p>
            ${startGameButtonHTML}`;
        gameAreaContainerEl.querySelector('#startGameBtn').addEventListener('click', () => {
            const selectedLevel = parseInt(gameAreaContainerEl.querySelector('#gameLevelSelectInBar').value);
            showCountdownThenStart(initGiantBattleGame, [true, selectedLevel]);
        });
        drawGiantBattleGame();
    }
    gameStartMessageEl.style.display = 'flex';
    gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
    document.querySelectorAll('.practice-mode-controls button[data-practice-type]').forEach(btn => btn.classList.remove('active'));
    if (gameModeBtnEl) {
        gameModeBtnEl.classList.add('active');
    }
}
function showGamePopup(text, duration = 1200, styleProps = {}) {
    if (!itemEffectPopupEl) itemEffectPopupEl = document.getElementById('item-effect-popup');
    if (itemEffectPopupEl) {
        itemEffectPopupEl.textContent = text;
        itemEffectPopupEl.style.backgroundColor = styleProps.backgroundColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
        itemEffectPopupEl.style.color = styleProps.color || getComputedStyle(document.documentElement).getPropertyValue('--button-text-on-accent').trim();

        itemEffectPopupEl.classList.add('visible');
        setTimeout(() => {
            if(itemEffectPopupEl) itemEffectPopupEl.classList.remove('visible');
        }, duration);
    }
}
function showSharePopup(message) {
    const popup = document.getElementById('result-share-popup');
    popup.textContent = message;
    popup.style.opacity = '1';
    popup.style.transform = 'translateX(-50%) translateY(0)';
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(20px)';
    }, 2000);
}
// --- RAINFALL (소나기) GAME FUNCTIONS ---
function initRainfallGame(fromStartButton = false, level) {
    if (level !== undefined) rainfall_gameLevel = level;
    if(fromStartButton) {
        if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
        if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
    }

    if(rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    if(rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

    rainfall_isGameActive = true;
    rainfall_gamePausedForOverlay = false;
    rainfall_gameScore = 0;
    rainfall_gameLives = RAINFALL_INITIAL_LIVES;
    rainfall_wordsOnScreen = [];
    rainfall_usedWordsInLevel.clear();
    rainfall_levelStartTime = Date.now();
    rainfall_isTimeStopped = false;

    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);

    rainfall_currentSubLevelIndex = 0;

    if(gameInputField) {
        gameInputField.disabled = false;
        gameInputField.value = '';
        gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
        setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
    }

    startRainfallWordGeneration();
    startRainfallGameLoop();
}
function startRainfallGameLoop() {
    if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
    function loop() {
        if (currentGameType !== 'rainfall' || !rainfall_isGameActive) {
             cancelAnimationFrame(rainfall_gameLoopId);
             rainfall_gameLoopId = null;
             return;
        }

        drawRainfallGame();

        if (rainfall_isGameActive && !rainfall_gamePausedForOverlay) {
            updateRainfallGameLogic();
        }

        rainfall_gameLoopId = requestAnimationFrame(loop);
    }
    rainfall_gameLoopId = requestAnimationFrame(loop);
}
function updateRainfallGameLogic() {
    if (!rainfall_isGameActive || !gameCanvas || rainfall_gamePausedForOverlay) return;
    if (rainfall_isTimeStopped) return;

    const now = Date.now();
    const elapsedTime = now - rainfall_levelStartTime;

    if (elapsedTime >= RAINFALL_LEVEL_DURATION_MS) {
        handleGameEnd(rainfall_gameLives > 0, 'timeUp');
        return;
    }

    const currentMainLevelConfig = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!currentMainLevelConfig) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const newSubLevel = Math.min(Math.floor(elapsedTime / RAINFALL_SUB_LEVEL_DURATION_MS), currentMainLevelConfig.subLevels.length - 1);
    if (newSubLevel > rainfall_currentSubLevelIndex) {
        rainfall_currentSubLevelIndex = newSubLevel;
        if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
        startRainfallWordGeneration();
    }

    for (let i = rainfall_wordsOnScreen.length - 1; i >= 0; i--) {
        const word = rainfall_wordsOnScreen[i];
        word.y += word.speed;
        if (word.y > gameCanvas.height + 20) {
            if (rainfall_gameLives > 0 && !word.itemType) {
                rainfall_gameLives--;
                triggerRainfallLifeLostEffect();
            }
            rainfall_wordsOnScreen.splice(i, 1);
        }
    }

    if (rainfall_gameLives <= 0) {
        handleGameEnd(false, 'lives');
    }
}
function drawRainfallGame() {
    if (!gameCtx || !gameCanvas) return;

    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
        return;
    }

    const bodyClasses = document.body.classList;
    let textColor;
    if (bodyClasses.contains('light-theme')) {
        textColor = '#524a42';
    } else if (bodyClasses.contains('pink-theme')) {
        textColor = '#4F333D';
    } else {
        textColor = '#e8e0d8';
    }

    gameCtx.font = "bold 16px 'Poppins', sans-serif";
    gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
    gameCtx.shadowBlur = 4;
    gameCtx.fillStyle = textColor;
    gameCtx.textAlign = 'left';
    gameCtx.fillText(`점수: ${rainfall_gameScore}`, 15 + 40, 30);

    gameCtx.textAlign = 'center';
    gameCtx.fillText(`레벨: ${rainfall_gameLevel}-${rainfall_currentSubLevelIndex + 1}`, gameCanvas.width / 2, 30);

    gameCtx.textAlign = 'right';
    gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gb-enemy-health-color').trim();
    gameCtx.fillText(`생명: ${'❤️'.repeat(rainfall_gameLives)}`, gameCanvas.width - 15, 30);
    gameCtx.shadowBlur = 0;


    if (lbbTimerBarContainerEl && rainfall_isGameActive) {
        const elapsedTime = Date.now() - rainfall_levelStartTime;
        const progress = 1 - (elapsedTime / RAINFALL_LEVEL_DURATION_MS);
        if(lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;

        const remainingTimeSec = Math.ceil(Math.max(0, RAINFALL_LEVEL_DURATION_MS - elapsedTime) / 1000);
        const minutes = Math.floor(remainingTimeSec / 60);
        const seconds = remainingTimeSec % 60;
        if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    gameCtx.font = RAINFALL_GAME_FONT;
    gameCtx.textAlign = 'center';

    for (const word of rainfall_wordsOnScreen) {
        gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
        gameCtx.shadowBlur = 4;

        if (word.itemType) {
            gameCtx.fillStyle = word.color;
            gameCtx.shadowColor = word.color;
            gameCtx.shadowBlur = 10;
        } else if (word.isFast) {
            gameCtx.fillStyle = 'tomato';
            gameCtx.shadowColor = 'tomato';
            gameCtx.shadowBlur = 5;
        } else {
            gameCtx.fillStyle = textColor;
        }
        gameCtx.fillText(word.text, word.x, word.y);
    }
    gameCtx.shadowBlur = 0;
}
function startRainfallWordGeneration() {
    const levelData = rainfall_gameMainLevelsConfig[rainfall_gameLevel - 1];
    if (!levelData || !levelData.subLevels) {
        console.error(`Rainfall: Invalid level data for level ${rainfall_gameLevel}.`);
        handleGameEnd(false, "config_error");
        return;
    }
    const levelConfig = levelData.subLevels[rainfall_currentSubLevelIndex];

    if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);

            function generateWord() {
                if (!rainfall_isGameActive || rainfall_gamePausedForOverlay || !gameCanvas) return;

                let newWordText;
                let isItem = Math.random() < RAINFALL_ITEM_SPAWN_PROBABILITY;
                let itemDetails = null;

                if (isItem) {
                    const itemTypes = Object.values(RAINFALL_ITEM_TYPES);
                    itemDetails = getRandom(itemTypes);
                    newWordText = itemDetails.text;
                } else {
                    const wordPool = gameWordsKor.filter(w => w.length <= 4);
                    const filteredPool = wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen && !rainfall_usedWordsInLevel.has(w));
                    newWordText = getRandom(filteredPool.length > 5 ? filteredPool : wordPool.filter(w => w.length >= levelConfig.wordMinLen && w.length <= levelConfig.wordMaxLen));
                    if (!newWordText) newWordText = '단어';
                }

                rainfall_usedWordsInLevel.add(newWordText);
                if (rainfall_usedWordsInLevel.size > 100) {
                    const oldestWord = rainfall_usedWordsInLevel.values().next().value;
                    rainfall_usedWordsInLevel.delete(oldestWord);
                }

                const isFast = !isItem && Math.random() < levelConfig.fastWordChance;

                rainfall_wordsOnScreen.push({
                    text: newWordText,
                    x: Math.random() * (gameCanvas.width - 100) + 50,
                    y: -20,
                    speed: levelConfig.fallSpeed * (isFast ? levelConfig.fastWordMultiplier : 1),
                    isFast: isFast,
                    itemType: isItem ? itemDetails.type : null,
                    color: isItem ? itemDetails.color : null,
                    duration: isItem ? itemDetails.duration : 0
                });
            }

            generateWord();
            rainfall_wordGenerationIntervalId = setInterval(generateWord, levelConfig.genRate);
        }
        function handleRainfallGameInputSubmit() {
            if (!rainfall_isGameActive || rainfall_gamePausedForOverlay) return;
            const typedWord = gameInputField.value.trim();
            if (typedWord === "") return;

            const wordsToKeep = [];
            const matchedWords = [];

            // 1. 입력된 단어와 일치하는 단어와 그렇지 않은 단어를 분리합니다.
            for (const word of rainfall_wordsOnScreen) {
                if (word.text === typedWord) {
                    matchedWords.push(word);
                } else {
                    wordsToKeep.push(word);
                }
            }

            // 2. 일치하는 단어가 있었는지 확인합니다.
            if (matchedWords.length > 0) {
                // 화면에 남을 단어 목록을 미리 업데이트하여 충돌을 방지합니다.
                rainfall_wordsOnScreen = wordsToKeep;

                // 3. 일치했던 모든 단어의 효과를 처리합니다.
                for (const word of matchedWords) {
                    if (word.itemType) {
                        // 아이템 효과를 발동시킵니다.
                        activateRainfallItemEffect(word.itemType, word.duration);
                    } else {
                        // 일반 단어는 점수를 추가합니다.
                        rainfall_gameScore += word.text.length * (word.isFast ? 2 : 1);
                    }
                }
            } else {
                // 일치하는 단어가 없으면 입력창에 효과를 줍니다.
                if(gameInputField) gameInputField.classList.add('shake-effect');
                setTimeout(() => { if(gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
            }
            
            gameInputField.value = "";
        }
        function activateRainfallItemEffect(itemType, duration) {
            let popupText = "";
            const itemInfo = Object.values(RAINFALL_ITEM_TYPES).find(it => it.type === itemType);
            if (!itemInfo) return;

            switch(itemType) {
                case 'extraLife':
                    if (rainfall_gameLives < 10) rainfall_gameLives++;
                    popupText = `생명 +1 ${itemInfo.icon}`;
                    break;
                case 'timeStop':
                    rainfall_isTimeStopped = true;
                    popupText = `시간 정지! ${itemInfo.icon}`;
                    if (window.rainfallTimeStopTimeoutId) clearTimeout(window.rainfallTimeStopTimeoutId);
                    window.rainfallTimeStopTimeoutId = setTimeout(() => { rainfall_isTimeStopped = false; }, duration);
                    break;
                case 'clearScreen':
                    popupText = `화면 정리! ${itemInfo.icon}`;
                    for (let j = rainfall_wordsOnScreen.length - 1; j >= 0; j--) {
                        if (!rainfall_wordsOnScreen[j].itemType) {
                            rainfall_gameScore += rainfall_wordsOnScreen[j].text.length;
                            rainfall_wordsOnScreen.splice(j, 1);
                        }
                    }
                    break;
            }
            if (popupText) showGamePopup(popupText, 1500);
        }
        function triggerRainfallLifeLostEffect() {
            if (gameCanvas) {
                gameCanvas.classList.add('flash-effect');
                setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300);
            }
        }
        // --- LETTER BLOCK BATTLE GAME FUNCTIONS ---
        function initLetterBlockBattleGame(fromStartButtonOrNextLevel = false, level) {
            if(level) lbb_gameLevel = level;
            if(fromStartButtonOrNextLevel) {
                if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
                if (lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'block';
            }

            if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
            if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
            if(lbb_playerNoPlayableBlocksTimerId) clearTimeout(lbb_playerNoPlayableBlocksTimerId);
            lbb_playerNoPlayableBlocksTimerId = null;
            if(lbb_relocationCountdownIntervalId) clearInterval(lbb_relocationCountdownIntervalId);
            lbb_relocationCountdownIntervalId = null;

            lbb_isGameActive = true;
            lbb_gamePausedForOverlay = false;
            lbb_gamePausedForEffect = false;
            lbb_isRelocating = false;

            lbb_enemyMoveDelay = lbb_levelDelays[lbb_gameLevel - 1];

            lbb_playerScore = 0;
            lbb_enemyScore = 0;

            generateLBBGameBoard();
            lbb_playerPos = { r: 0, c: 0 };
            lbb_enemyPos = { r: LBB_BOARD_ROWS - 1, c: LBB_BOARD_COLS - 1 };
            lbb_enemyOriginalStartPos = { ...lbb_enemyPos };

            if(lbb_gameBoard[lbb_playerPos.r] && lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c]) {
                lbb_gameBoard[lbb_playerPos.r][lbb_playerPos.c].broken = true;
            }
            if(lbb_gameBoard[lbb_enemyPos.r] && lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c]) {
                lbb_gameBoard[lbb_enemyPos.r][lbb_enemyPos.c].broken = true;
            }

            if (gameInputField) {
                gameInputField.disabled = false;
                gameInputField.value = '';
                gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
                setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
            }

            lbb_gameStartTime = Date.now();
            lbb_enemyActionIntervalId = setInterval(lbb_enemyAIAction, lbb_enemyMoveDelay);
            startLBBGameLoop();
        }

        function startLBBGameLoop() {
            if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
            function loop() {
                if (currentGameType !== 'letterBlockBattle' || !lbb_isGameActive) {
                    cancelAnimationFrame(lbb_gameLoopId);
                    lbb_gameLoopId = null;
                    return;
                }
                drawLetterBlockBattleGame();
                if(lbb_isGameActive && !lbb_gamePausedForOverlay){
                    updateLBBGameLogic();
                }
                lbb_gameLoopId = requestAnimationFrame(loop);
            }
            lbb_gameLoopId = requestAnimationFrame(loop);
        }

        function updateLBBGameLogic() {
            if (!lbb_isGameActive || !gameCanvas || lbb_gamePausedForOverlay) return;

            if (lbb_gameStartTime && (Date.now() - lbb_gameStartTime >= LBB_GAME_DURATION_MS)) {
                handleGameEnd(lbb_playerScore > lbb_enemyScore, "timeUp");
                return;
            }

            if (lbb_swapEffect.active) {
                updateLBBSwapAnimation();
            } else if (lbb_finalBattleAnimation.isActive) {
                updateLBBFinalBattleAnimation();
            } else {
                if (!lbb_isRelocating) {
                     checkAndTriggerPlayerLBBRelocation();
                }
            }

            lbb_blockBreakParticles = lbb_blockBreakParticles.filter(p => p.alpha > 0);
            lbb_blockBreakParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.alpha -= 0.02;
            });
        }

        function drawLetterBlockBattleGame() {
            if (!gameCtx || !gameCanvas) return;

            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
                return;
            }

            const boardWidth = LBB_BOARD_COLS * LBB_BLOCK_SIZE;
            const boardHeight = LBB_BOARD_ROWS * LBB_BLOCK_SIZE;
            const boardX = (gameCanvas.width - boardWidth) / 2;
            const boardY = (gameCanvas.height - boardHeight) / 2 + 15;

            const bodyClasses = document.body.classList;
            let textColor, inputBgColor, brokenColor, playerBlockBg, playerColor, enemyColor;
            if (bodyClasses.contains('light-theme')) {
                textColor = '#524a42';
                inputBgColor = '#fefcf9';
                brokenColor = '#f9f5f0';
                playerBlockBg = '#fffacd';
                playerColor = '#4A90E2';
                enemyColor = '#D0021B';
            } else if (bodyClasses.contains('pink-theme')) {
                textColor = '#4F333D';
                inputBgColor = '#fffafa';
                brokenColor = '#fff5f8';
                playerBlockBg = '#ffe8f0';
                playerColor = '#E91E63';
                enemyColor = '#7B1FA2';
            } else {
                textColor = '#e8e0d8';
                inputBgColor = '#33302e';
                brokenColor = '#262422';
                playerBlockBg = 'rgba(212, 175, 122, 0.08)';
                playerColor = 'dodgerblue';
                enemyColor = 'tomato';
            }

            const borderColor = getComputedStyle(document.documentElement).getPropertyValue(LBB_BLOCK_BORDER_COLOR_VAR).trim();

            for (let r = 0; r < LBB_BOARD_ROWS; r++) {
                for (let c = 0; c < LBB_BOARD_COLS; c++) {
                    const block = lbb_gameBoard[r] ? lbb_gameBoard[r][c] : null;
                    if (!block) continue;

                    const x = boardX + c * LBB_BLOCK_SIZE;
                    const y = boardY + r * LBB_BLOCK_SIZE;

                    gameCtx.fillStyle = block.broken ? brokenColor : inputBgColor;
                    gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);

                    if (!block.broken) {
                        const isPlayerAdjacent = Math.abs(lbb_playerPos.r - r) + Math.abs(lbb_playerPos.c - c) === 1;
                        if (isPlayerAdjacent) {
                            gameCtx.fillStyle = playerBlockBg;
                            gameCtx.fillRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                        }

                        gameCtx.font = lbb_blockTextFont;
                        gameCtx.textAlign = 'center';
                        gameCtx.textBaseline = 'middle';
                        gameCtx.fillStyle = block.effect.color || textColor;
                        gameCtx.fillText(block.word, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2);

                        if (block.effect.icon) {
                            gameCtx.font = `bold ${LBB_BLOCK_SIZE * 0.25}px sans-serif`;
                            gameCtx.fillText(block.effect.icon, x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE * 0.78);
                        }
                    }
                    gameCtx.strokeStyle = borderColor;
                    gameCtx.strokeRect(x, y, LBB_BLOCK_SIZE, LBB_BLOCK_SIZE);
                }
            }

            lbb_blockBreakParticles.forEach(p => {
                gameCtx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
                gameCtx.fillRect(boardX + p.x, boardY + p.y, 3, 3);
            });

            function drawCharacter(pos, color, isPlayer) {
                const x = boardX + pos.c * LBB_BLOCK_SIZE;
                const y = boardY + pos.r * LBB_BLOCK_SIZE;
                gameCtx.fillStyle = color;
                gameCtx.beginPath();
                gameCtx.arc(x + LBB_BLOCK_SIZE / 2, y + LBB_BLOCK_SIZE / 2, LBB_BLOCK_SIZE / 2 - 4, 0, Math.PI * 2);
                gameCtx.fill();
                if (isPlayer) {
                    gameCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--current-lbb-player-highlight-border').trim();
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                    gameCtx.lineWidth = 1;
                }
            }

            if (lbb_swapEffect.active) {
                drawCharacter(lbb_swapEffect.animPlayerPos, playerColor, true);
                drawCharacter(lbb_swapEffect.animEnemyPos, enemyColor, false);
            } else if (lbb_finalBattleAnimation.isActive) {
                drawCharacter(lbb_finalBattleAnimation.playerAnimPos, playerColor, true);
                drawCharacter(lbb_finalBattleAnimation.enemyAnimPos, enemyColor, false);
            } else {
                drawCharacter(lbb_playerPos, playerColor, true);
                drawCharacter(lbb_enemyPos, enemyColor, false);
            }

            gameCtx.font = "bold 18px 'Poppins', sans-serif";
            gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
            gameCtx.shadowBlur = 4;
            gameCtx.textAlign = 'left';
            gameCtx.fillStyle = playerColor;
            gameCtx.fillText(`플레이어: ${lbb_playerScore}`, 15 + 40, 30);
            gameCtx.textAlign = 'right';
            gameCtx.fillStyle = enemyColor;
            gameCtx.fillText(`적: ${lbb_enemyScore}`, gameCanvas.width - 15, 30);
            gameCtx.textAlign = 'center';
            gameCtx.fillStyle = textColor;
            gameCtx.fillText(`레벨: ${lbb_gameLevel}`, gameCanvas.width / 2, 30);

            if (lbb_relocationCountdown > 0) {
                gameCtx.font = "bold 16px 'Poppins', sans-serif";
                gameCtx.fillStyle = 'orange';
                gameCtx.textAlign = 'center';
                gameCtx.fillText(`길을 찾는 중... ${lbb_relocationCountdown}초`, gameCanvas.width / 2, gameCanvas.height - 20);
            }

            gameCtx.shadowBlur = 0;

            if (lbbTimerBarContainerEl && lbb_isGameActive) {
                const elapsedTime = Date.now() - lbb_gameStartTime;
                const progress = 1 - (elapsedTime / LBB_GAME_DURATION_MS);
                if (lbbTimerBarEl) lbbTimerBarEl.style.width = `${Math.max(0, progress) * 100}%`;
                const remainingTimeSec = Math.ceil(Math.max(0, LBB_GAME_DURATION_MS - elapsedTime) / 1000);
                const minutes = Math.floor(remainingTimeSec / 60);
                const seconds = remainingTimeSec % 60;
                if(lbbTimerTextEl) lbbTimerTextEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function generateLBBGameBoard() {
            lbb_gameBoard = [];
            const wordPoolSource = gameWordsKor;
            const wordPool = wordPoolSource.filter(word => word.length >= 2 && word.length <= 3);

            for (let r = 0; r < LBB_BOARD_ROWS; r++) {
                lbb_gameBoard[r] = [];
                for (let c = 0; c < LBB_BOARD_COLS; c++) {
                    const effectRoll = Math.random();
                    let effectType = LBB_BLOCK_EFFECT_TYPES.NORMAL;
                    if (effectRoll < LBB_ITEM_SPAWN_PROBABILITY) {
                        const itemRoll = Math.random();
                        if (itemRoll < 0.2) effectType = LBB_BLOCK_EFFECT_TYPES.GREEN;
                        else if (itemRoll < 0.5) effectType = LBB_BLOCK_EFFECT_TYPES.BLUE;
                        else if (itemRoll < 0.8) effectType = LBB_BLOCK_EFFECT_TYPES.RED;
                        else effectType = LBB_BLOCK_EFFECT_TYPES.YELLOW;
                    }
                    lbb_gameBoard[r][c] = {
                        word: getRandom(wordPool.length > 0 ? wordPool : wordPoolSource),
                        broken: false,
                        effect: effectType
                    };
                }
            }
        }

        function getSurroundingLBBBlocks(pos, checkBroken = true) {
            const blocks = [];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (const [dr, dc] of directions) {
                const r = pos.r + dr;
                const c = pos.c + dc;

                if (r >= 0 && r < LBB_BOARD_ROWS && c >= 0 && c < LBB_BOARD_COLS) {
                    const block = lbb_gameBoard[r][c];
                    if (!checkBroken || (block && !block.broken)) {
                        blocks.push({ ...block, r, c });
                    }
                }
            }
            return blocks;
        }

        function handleLetterBlockBattleInputSubmit() {
            if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isRelocating) return;
            const typedWord = gameInputField.value.trim();
            if (!typedWord) return;

            const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);

            const matchedBlock = surroundingBlocks.find(block => {
                if (!block) return false;
                return block.word === typedWord;
            });

            if (matchedBlock) {
                lbb_playerMoveAndBreak(matchedBlock);
                checkLBBBattleCondition();
            } else {
                if (gameInputField) gameInputField.classList.add('shake-effect');
                setTimeout(() => { if (gameInputField) gameInputField.classList.remove('shake-effect'); }, 200);
            }
            if (gameInputField) gameInputField.value = '';
        }

        function lbb_playerMoveAndBreak(targetBlock) {
            lbb_playerPos = { r: targetBlock.r, c: targetBlock.c };
            const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
            block.broken = true;

            lbb_playerScore += block.effect.score;
            lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
            if (block.effect.effect) {
                lbb_applyEffect(block.effect.effect, lbb_playerPos, true, block.effect.freezeDuration, block.effect.icon);
            }
        }

        function lbb_enemyAIAction() {
            if (!lbb_isGameActive || lbb_gamePausedForOverlay || lbb_gamePausedForEffect || lbb_isEnemyFrozen || lbb_isRelocating || lbb_finalBattleAnimation.isActive) return;

            const surroundingBlocks = getSurroundingLBBBlocks(lbb_enemyPos);
            if (surroundingBlocks.length > 0) {
                if (lbb_enemyNoPlayableBlocksTimerId) {
                    clearTimeout(lbb_enemyNoPlayableBlocksTimerId);
                    lbb_enemyNoPlayableBlocksTimerId = null;
                }
                const targetBlock = getRandom(surroundingBlocks);
                lbb_enemyPos = { r: targetBlock.r, c: targetBlock.c };
                const block = lbb_gameBoard[targetBlock.r][targetBlock.c];
                block.broken = true;
                lbb_enemyScore += block.effect.score;
                lbb_triggerBlockBreakEffect(targetBlock.r, targetBlock.c, block.effect.color);
                if (block.effect.effect) {
                     lbb_applyEffect(block.effect.effect, lbb_enemyPos, false, block.effect.freezeDuration, block.effect.icon);
                }
                checkLBBBattleCondition();
            } else {
                if (!lbb_enemyNoPlayableBlocksTimerId && !lbb_isRelocating) {
                    lbb_enemyNoPlayableBlocksTimerId = setTimeout(() => {
                        lbb_initiateRelocation(false);
                        lbb_enemyNoPlayableBlocksTimerId = null;
                    }, LBB_NO_PLAYABLE_RELOCATE_DELAY);
                }
            }
        }

        function lbb_applyEffect(effect, pos, isPlayer, duration, icon = '') {
            lbb_gamePausedForEffect = true;
            let popupText = '';

            switch (effect) {
                case 'freezeEnemy':
                    if (isPlayer) {
                        lbb_isEnemyFrozen = true;
                        popupText = `적 정지! ${icon}`;
                        if(lbb_enemyFreezeTimeoutId) clearTimeout(lbb_enemyFreezeTimeoutId);
                        lbb_enemyFreezeTimeoutId = setTimeout(() => { lbb_isEnemyFrozen = false; }, duration);
                    }
                    break;
                case 'swapPositions':
                    lbb_swapEffect.active = true;
                    lbb_swapEffect.step = 0;
                    lbb_swapEffect.playerOld = isPlayer ? { ...pos } : { ...lbb_playerPos };
                    lbb_swapEffect.enemyOld = isPlayer ? { ...lbb_enemyPos } : { ...pos };
                    lbb_swapEffect.animPlayerPos = { ...lbb_swapEffect.playerOld };
                    lbb_swapEffect.animEnemyPos = { ...lbb_swapEffect.enemyOld };
                    popupText = `위치 변경! ${icon}`;
                    break;
            }

            if (popupText) {
                showGamePopup(popupText, 1500);
            }

            setTimeout(() => {
                if(effect !== 'swapPositions') lbb_gamePausedForEffect = false;
            }, 500);
        }

        function updateLBBSwapAnimation() {
            if (!lbb_swapEffect.active) return;
            lbb_swapEffect.step++;
            const progress = lbb_swapEffect.step / lbb_swapEffect.totalSteps;

            const playerTarget = lbb_swapEffect.enemyOld;
            const enemyTarget = lbb_swapEffect.playerOld;

            lbb_swapEffect.animPlayerPos.r = lbb_swapEffect.playerOld.r + (playerTarget.r - lbb_swapEffect.playerOld.r) * progress;
            lbb_swapEffect.animPlayerPos.c = lbb_swapEffect.playerOld.c + (playerTarget.c - lbb_swapEffect.playerOld.c) * progress;

            lbb_swapEffect.animEnemyPos.r = lbb_swapEffect.enemyOld.r + (enemyTarget.r - lbb_swapEffect.enemyOld.r) * progress;
            lbb_swapEffect.animEnemyPos.c = lbb_swapEffect.enemyOld.c + (enemyTarget.c - lbb_swapEffect.enemyOld.c) * progress;

            if (lbb_swapEffect.step >= lbb_swapEffect.totalSteps) {
                lbb_swapEffect.active = false;
                lbb_playerPos = { ...playerTarget };
                lbb_enemyPos = { ...enemyTarget };
                lbb_gamePausedForEffect = false;
            }
        }
        function lbb_triggerBlockBreakEffect(r, c, colorHex) {
            const colorRgb = hexToRgb(colorHex) || { r: 180, g: 180, b: 180 };
            for (let i = 0; i < 15; i++) {
                lbb_blockBreakParticles.push({
                    x: c * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
                    y: r * LBB_BLOCK_SIZE + LBB_BLOCK_SIZE / 2,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    ...colorRgb,
                    alpha: 1
                });
            }
        }

        function checkLBBBattleCondition() {
            const path = findPath(lbb_playerPos, lbb_enemyPos);
            if (path) {
                lbb_triggerFinalBattleAnimation(path);
            }
        }

        function findPath(start, end) {
            const queue = [[start, [start]]];
            const visited = new Set([`${start.r},${start.c}`]);

            while (queue.length > 0) {
                const [current, path] = queue.shift();

                if (current.r === end.r && current.c === end.c) {
                    return path;
                }

                const neighbors = getSurroundingLBBBlocks(current, false).filter(b => b.broken);

                for (const neighbor of neighbors) {
                    const posKey = `${neighbor.r},${neighbor.c}`;
                    if (!visited.has(posKey)) {
                        visited.add(posKey);
                        const newPath = [...path, neighbor];
                        queue.push([neighbor, newPath]);
                    }
                }
            }
            return null;
        }
        function lbb_triggerFinalBattleAnimation(pathToMeet) {
            if (lbb_finalBattleAnimation.isActive) return;

            lbb_finalBattleAnimation.isActive = true;
            lbb_finalBattleAnimation.step = 0;
            lbb_finalBattleAnimation.playerStartPos = { ...lbb_playerPos };
            lbb_finalBattleAnimation.enemyStartPos = { ...lbb_enemyPos };
            lbb_finalBattleAnimation.playerAnimPos = { ...lbb_playerPos };
            lbb_finalBattleAnimation.enemyAnimPos = { ...lbb_enemyPos };
            lbb_finalBattleAnimation.meetingPoint = pathToMeet[Math.floor(pathToMeet.length / 2)];
        }

        function updateLBBFinalBattleAnimation() {
            if (!lbb_finalBattleAnimation.isActive) return;

            lbb_finalBattleAnimation.step++;
            const progress = lbb_finalBattleAnimation.step / lbb_finalBattleAnimation.totalSteps;

            const meetingR = lbb_finalBattleAnimation.meetingPoint.r;
            const meetingC = lbb_finalBattleAnimation.meetingPoint.c;

            lbb_finalBattleAnimation.playerAnimPos.r = lbb_finalBattleAnimation.playerStartPos.r + (meetingR - lbb_finalBattleAnimation.playerStartPos.r) * progress;
            lbb_finalBattleAnimation.playerAnimPos.c = lbb_finalBattleAnimation.playerStartPos.c + (meetingC - lbb_finalBattleAnimation.playerStartPos.c) * progress;
            lbb_finalBattleAnimation.enemyAnimPos.r = lbb_finalBattleAnimation.enemyStartPos.r + (meetingR - lbb_finalBattleAnimation.enemyStartPos.r) * progress;
            lbb_finalBattleAnimation.enemyAnimPos.c = lbb_finalBattleAnimation.enemyStartPos.c + (meetingC - lbb_finalBattleAnimation.enemyStartPos.c) * progress;

            if (lbb_finalBattleAnimation.step >= lbb_finalBattleAnimation.totalSteps) {
                lbb_finalBattleAnimation.isActive = false;
                handleGameEnd(lbb_playerScore > lbb_enemyScore, "battle");
            }
        }

        function checkAndTriggerPlayerLBBRelocation() {
            if(lbb_isRelocating) return;
            const surroundingBlocks = getSurroundingLBBBlocks(lbb_playerPos);
            if(surroundingBlocks.length === 0){
                if(!lbb_playerNoPlayableBlocksTimerId) {
                    lbb_relocationCountdown = Math.ceil(LBB_NO_PLAYABLE_RELOCATE_DELAY / 1000);
                    lbb_playerNoPlayableBlocksTimerId = setTimeout(() => {
                        lbb_initiateRelocation(true);
                        lbb_playerNoPlayableBlocksTimerId = null;
                        clearInterval(lbb_relocationCountdownIntervalId);
                        lbb_relocationCountdownIntervalId = null;
                    }, LBB_NO_PLAYABLE_RELOCATE_DELAY);

                    lbb_relocationCountdownIntervalId = setInterval(() => {
                        lbb_relocationCountdown--;
                        if(lbb_relocationCountdown <= 0) {
                            clearInterval(lbb_relocationCountdownIntervalId);
                            lbb_relocationCountdownIntervalId = null;
                        }
                    }, 1000);
                }
            } else {
                if (lbb_playerNoPlayableBlocksTimerId) {
                    clearTimeout(lbb_playerNoPlayableBlocksTimerId);
                    lbb_playerNoPlayableBlocksTimerId = null;
                }
                if(lbb_relocationCountdownIntervalId) {
                    clearInterval(lbb_relocationCountdownIntervalId);
                    lbb_relocationCountdownIntervalId = null;
                }
                lbb_relocationCountdown = 0;
            }
        }

        function lbb_initiateRelocation(isPlayerRelocation) {
            if (isPlayerRelocation) {
                lbb_isRelocating = true;
                showGamePopup("길이 막혔습니다! 재배치합니다...", 2000);
                setTimeout(() => lbb_performRelocation(true), 1000);
            } else {
                lbb_performRelocation(false);
            }
        }

        function lbb_performRelocation(isPlayerRelocation) {
            const opponentPos = isPlayerRelocation ? lbb_enemyPos : lbb_playerPos;
            const newPos = findValidLbbRelocationSpot(opponentPos, LBB_BOARD_ROWS, LBB_BOARD_COLS, LBB_MIN_RELOCATION_DISTANCE_FROM_OPPONENT);

            if(newPos) {
                if(isPlayerRelocation) {
                    lbb_playerPos = newPos;
                } else {
                    lbb_enemyPos = newPos;
                }
                lbb_gameBoard[newPos.r][newPos.c].broken = true;
            } else {
                handleGameEnd(false, "stuck");
            }
            if (isPlayerRelocation) {
               lbb_isRelocating = false;
            }
        }

        function findValidLbbRelocationSpot(opponentCurrentPos, boardRows, boardCols, minDistanceFromOpponent) {
            const allSpots = [];
            for(let r=0; r<boardRows; r++){
                for(let c=0; c<boardCols; c++){
                    if(!lbb_gameBoard[r][c].broken){
                         const dist = Math.sqrt(Math.pow(r - opponentCurrentPos.r, 2) + Math.pow(c - opponentCurrentPos.c, 2));
                         if(dist >= minDistanceFromOpponent){
                            allSpots.push({r, c});
                         }
                    }
                }
            }
            return getRandom(allSpots) || getRandom(lbb_gameBoard.flat().map((b, i) => ({...b, r: Math.floor(i/boardCols), c: i%boardCols})).filter(b => !b.broken));
        }


        // === TYPING BATTLE (Giant Battle) GAME FUNCTIONS ===
        function initGiantBattleGame(fromStartButtonOrNextLevel = false, level) {
            if (level) gb_currentLevel = level;
            if(fromStartButtonOrNextLevel) {
                if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
                if(lbbTimerBarContainerEl) lbbTimerBarContainerEl.style.display = 'none';
            }

            if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
            if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId); 

            gb_isGameActive = true;
            gb_gamePausedForOverlay = false;
            gb_playerHealth = GB_MAX_PLAYER_HEALTH;
            gb_enemyAttacks = [];
            gb_gameStartTime = Date.now();
            gb_enemyHitEffectTimer = 0;

            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            gb_enemyHealth = currentLevelConfig.enemyHealth;

            gb_spawnPlayerAttackWord();

            if(gameInputField) {
              gameInputField.disabled = false;
              gameInputField.value = '';
              gameInputField.placeholder = "단어 입력 후 Enter 또는 Space";
              setTimeout(() => { if(gameInputField) gameInputField.focus(); }, 100);
            }
            
            let lastAttackTime = 0;
            function enemyAttackLoop(timestamp) {
                if (!gb_isGameActive) {
                    if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
                    return;
                };
                if (!lastAttackTime) lastAttackTime = timestamp;
                const elapsed = timestamp - lastAttackTime;
                const interval = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))].attackInterval;
                if(elapsed > interval) {
                    gb_spawnEnemyAttack();
                    lastAttackTime = timestamp;
                }
                gb_enemyAttackIntervalId = requestAnimationFrame(enemyAttackLoop);
            }
            requestAnimationFrame(enemyAttackLoop);

            startGiantBattleGameLoop();
        }
        function startGiantBattleGameLoop() {
            if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
            function loop() {
                if (currentGameType !== 'giantBattle' || !gb_isGameActive) {
                     cancelAnimationFrame(gb_gameLoopId);
                     gb_gameLoopId = null;
                     return;
                }
                drawGiantBattleGame();
                if (gb_isGameActive && !gb_gamePausedForOverlay) {
                    updateGiantBattleGameLogic();
                }
                gb_gameLoopId = requestAnimationFrame(loop);
            }
            gb_gameLoopId = requestAnimationFrame(loop);
        }
        function updateGiantBattleGameLogic() {
            if (!gb_isGameActive || !gameCanvas || gb_gamePausedForOverlay) return;

            if (gb_gameStartTime && (Date.now() - gb_gameStartTime >= GB_GAME_DURATION_MS)) {
                handleGameEnd(gb_playerHealth > 0, "timeUp");
                return;
            }

            if (gb_enemyHitEffectTimer > 0) {
                gb_enemyHitEffectTimer -= 1000 / 60;
                if (gb_enemyHitEffectTimer < 0) gb_enemyHitEffectTimer = 0;
            }

            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            for (let i = gb_enemyAttacks.length - 1; i >= 0; i--) {
                const attack = gb_enemyAttacks[i];
                attack.y += currentLevelConfig.attackSpeed;

                const attackObjectHeight = 40;
                const playerHpBarY = gameCanvas.height - 35 - 18;
                const playerHitZoneY = playerHpBarY - attackObjectHeight / 2 - 5;

                if (attack.y + attackObjectHeight / 2 > playerHitZoneY) {
                    gb_enemyAttacks.splice(i, 1);
                    gb_playerHealth -= GB_ENEMY_ATTACK_DAMAGE;
                    const damageText = attack.isSpecial ? `특별 공격 피격! 🔥` : `피격! 🤕`;
                    showGamePopup(damageText, 800, { backgroundColor: `rgba(211, 84, 109, 0.7)` });
                    if (gameCanvas) { gameCanvas.classList.add('flash-effect'); setTimeout(() => { if(gameCanvas) gameCanvas.classList.remove('flash-effect'); }, 300); }

                    if (gb_playerHealth <= 0) {
                        gb_playerHealth = 0;
                        handleGameEnd(false, "hp");
                        return;
                    }
                } else if (attack.y > gameCanvas.height + attackObjectHeight) {
                     gb_enemyAttacks.splice(i, 1);
                }
            }

            if (gb_enemyHealth <= 0) {
                gb_enemyHealth = 0;
                handleGameEnd(true, "hp");
                return;
            }
        }
        function drawGiantBattleGame() {
            if (!gameCtx || !gameCanvas) return;

            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (gameStartMessageEl && gameStartMessageEl.style.display === 'flex') {
                return;
            }

            const bodyClasses = document.body.classList;
            let mainTextColor, accentColor, specialAttackColor;
            if (bodyClasses.contains('light-theme')) {
                mainTextColor = '#524a42';
                accentColor = '#b89a6c';
                specialAttackColor = '#b89a6c';
            } else if (bodyClasses.contains('pink-theme')) {
                mainTextColor = '#4F333D';
                accentColor = '#E85D75';
                specialAttackColor = '#E85D75';
            } else {
                mainTextColor = '#e8e0d8';
                accentColor = '#d4af7a';
                specialAttackColor = '#d4af7a';
            }

            function drawHealthBar(x, y, width, height, currentHealth, maxHealth, colorVar, label = "", textAlign = 'left') {
                const healthColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
                const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--gb-health-bar-bg-color').trim();

                gameCtx.fillStyle = bgColor;
                gameCtx.fillRect(x, y, width, height);

                const healthPercentage = Math.max(0, currentHealth) / maxHealth;
                const currentHealthWidth = width * healthPercentage;

                const gradient = gameCtx.createLinearGradient(x, y, x, y + height);
                gradient.addColorStop(0, healthColor);
                gradient.addColorStop(1, hexToDarker(healthColor, 0.3));
                gameCtx.fillStyle = gradient;
                gameCtx.fillRect(x, y, currentHealthWidth, height);

                gameCtx.fillStyle = 'rgba(255,255,255,0.2)';
                gameCtx.fillRect(x, y, currentHealthWidth, height / 2);

                if (label) {
                    gameCtx.fillStyle = mainTextColor;
                    gameCtx.font = "bold 12px 'Poppins', sans-serif";
                    gameCtx.textAlign = textAlign;
                    gameCtx.textBaseline = "bottom";
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 4;
                    gameCtx.fillText(label, textAlign === 'left' ? x : x + width, y - 5);
                    gameCtx.shadowBlur = 0;
                }
            }

            function hexToDarker(hex, percent) {
              let { r, g, b } = hexToRgb(hex);
              r = parseInt(r * (1 - percent));
              g = parseInt(g * (1 - percent));
              b = parseInt(b * (1 - percent));
              return `rgb(${r}, ${g}, ${b})`;
            }
            const topUiY = 30;
            const uiMargin = 15;
            const healthBarHeight = 18;

            const enemyHealthBarWidth = gameCanvas.width * 0.3;
            drawHealthBar(gameCanvas.width - enemyHealthBarWidth - uiMargin, topUiY, enemyHealthBarWidth, healthBarHeight, gb_enemyHealth, gb_levelConfigs[gb_currentLevel - 1].enemyHealth, '--gb-enemy-health-color', "적 HP", 'right');

            const playerAreaBottomMargin = 50;
            const playerHpBarWidth = gameCanvas.width * 0.3;
            const playerHpBarX = gameCanvas.width - playerHpBarWidth - uiMargin;
            const playerHpBarY = gameCanvas.height - playerAreaBottomMargin - healthBarHeight;
            drawHealthBar(playerHpBarX, playerHpBarY, playerHpBarWidth, healthBarHeight, gb_playerHealth, GB_MAX_PLAYER_HEALTH, '--gb-player-health-color', "플레이어 HP", 'right');

            gameCtx.shadowColor = 'rgba(0,0,0,0.4)';
            gameCtx.shadowBlur = 4;
            gameCtx.fillStyle = mainTextColor;
            gameCtx.font = "bold 16px 'Poppins', sans-serif";
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.fillText(`레벨: ${gb_currentLevel}`, gameCanvas.width / 2, topUiY);

            if (gb_gameStartTime) {
                const remainingTime = Math.max(0, GB_GAME_DURATION_MS - (Date.now() - gb_gameStartTime));
                const minutes = Math.floor(remainingTime / 60000);
                const seconds = Math.floor((remainingTime % 60000) / 1000);
                gameCtx.font = "bold 14px 'Poppins', sans-serif";
                gameCtx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, gameCanvas.width / 2, topUiY + 20);
            }

            const attackWordBoxHeight = 40;
            const attackWordBoxWidth = gameCanvas.width * 0.3;
            const attackWordBoxX = (gameCanvas.width - attackWordBoxWidth) / 2;
            const attackWordBoxY = gameCanvas.height - attackWordBoxHeight - 20;

            gameCtx.strokeStyle = accentColor;
            gameCtx.lineWidth = 2;
            gameCtx.beginPath();
            gameCtx.roundRect(attackWordBoxX, attackWordBoxY, attackWordBoxWidth, attackWordBoxHeight, 8);
            gameCtx.stroke();
            gameCtx.lineWidth = 1;

            gameCtx.font = "bold 18px 'Poppins', sans-serif";
            gameCtx.fillStyle = accentColor;
            gameCtx.textAlign = "center";
            gameCtx.textBaseline = "middle";
            gameCtx.shadowColor = 'rgba(0,0,0,0.2)';
            gameCtx.shadowBlur = 2;
            gameCtx.fillText(gb_playerAttackWord, attackWordBoxX + attackWordBoxWidth / 2, attackWordBoxY + attackWordBoxHeight / 2);

            gameCtx.font = "bold 24px 'Poppins', sans-serif";
            gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
            gameCtx.shadowBlur = 5;
            gameCtx.shadowOffsetX = 1;
            gameCtx.shadowOffsetY = 1;

            for (const attack of gb_enemyAttacks) {
                gameCtx.fillStyle = attack.isSpecial ? specialAttackColor : mainTextColor;
                if (attack.isSpecial) {
                    gameCtx.shadowColor = accentColor;
                    gameCtx.shadowBlur = 10;
                } else {
                    gameCtx.shadowColor = 'rgba(0,0,0,0.7)';
                    gameCtx.shadowBlur = 5;
                }
                gameCtx.fillText(attack.word, attack.x, attack.y);
            }
            gameCtx.shadowBlur = 0;
            gameCtx.shadowOffsetX = 0;
            gameCtx.shadowOffsetY = 0;
        }
        function gb_spawnPlayerAttackWord() {
            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            const wordPool = gameWordsKor;
            const minLen = Math.max(3, currentLevelConfig.wordMinLen);
            const filteredWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
            gb_playerAttackWord = getRandom(filteredWordPool.length > 0 ? filteredWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "공격";
        }
        function gb_spawnDefenseWord(currentLevelConfig) {
            const wordPool = gameWordsKor;
            const minLen = Math.max(3, currentLevelConfig.wordMinLen);
            const defenseWordPool = wordPool.filter(w => w.length >= minLen && w.length <= 4);
            return getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLen && w.length <= 4)) || "수비";
        }
        function gb_spawnEnemyAttack() {
            if (!gb_isGameActive || gb_gamePausedForOverlay || !gameCanvas) return;
            const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
            const wordPool = gameWordsKor;

            let word = "";
            let isSpecialAttack = Math.random() < GB_SPECIAL_ATTACK_CHANCE;
            let originalWordForSpecial = "";
            const minLenForAttack = Math.max(3, currentLevelConfig.wordMinLen);

            if (isSpecialAttack) {
                const specialMinLen = 4;
                const specialWordPool = wordPool.filter(w => w.length === specialMinLen);
                word = getRandom(specialWordPool.length > 0 ? specialWordPool : wordPool.filter(w => w.length === 4)) || "강타";
                originalWordForSpecial = word;
            } else {
                const defenseWordPool = wordPool.filter(w => w.length >= minLenForAttack && w.length <=4);
                word = getRandom(defenseWordPool.length > 0 ? defenseWordPool : wordPool.filter(w => w.length >= minLenForAttack && w.length <=4)) || "돌격";
            }

            const startY = -20;

            gb_enemyAttacks.push({
                word: word,
                originalWord: isSpecialAttack ? originalWordForSpecial : word,
                x: Math.random() * (gameCanvas.width - 100) + 50,
                y: startY,
                speed: currentLevelConfig.attackSpeed,
                element: 'rock',
                isSpecial: isSpecialAttack
            });
        }
        function handleGiantBattleInputSubmit() {
            if (currentGameType !== 'giantBattle' || !gb_isGameActive || gb_gamePausedForOverlay) return;
            const typedWordFull = gameInputField.value.trim();
            if (typedWordFull === "") return;

            const typedWord = typedWordFull;

            const playerAttackWordToMatch = gb_playerAttackWord;
            if (typedWord === playerAttackWordToMatch) {
                gb_playerAttack();
                if(gameInputField) gameInputField.value = "";
                return;
            }

            const sortedEnemyAttacks = [...gb_enemyAttacks].sort((a,b) => b.y - a.y);
            for (let i = 0; i < sortedEnemyAttacks.length; i++) {
                const enemyAttack = sortedEnemyAttacks[i];
                const enemyWordToMatch = enemyAttack.word;

                if (typedWord === enemyWordToMatch) {
                    if (enemyAttack.isSpecial) {
                        enemyAttack.isSpecial = false;
                        const currentLevelConfig = gb_levelConfigs[Math.max(0, Math.min(gb_currentLevel - 1, gb_levelConfigs.length - 1))];
                        enemyAttack.word = gb_spawnDefenseWord(currentLevelConfig);
                        showGamePopup("특수 공격 무력화! 🛡️", 1000, { backgroundColor: `rgba(80, 150, 255, 0.7)` });
                    } else {
                        gb_playerDefend(enemyAttack);
                    }
                    if(gameInputField) gameInputField.value = "";
                    return;
                }
            }

            if(gameAreaContainerEl) gameAreaContainerEl.classList.add('shake-effect');
            setTimeout(() => { if(gameAreaContainerEl) gameAreaContainerEl.classList.remove('shake-effect'); }, 200);
            if(gameInputField) gameInputField.value = "";
        }
        function gb_playerAttack() {
            gb_enemyHealth -= GB_PLAYER_ATTACK_DAMAGE;
            gb_enemyHitEffectTimer = GB_ENEMY_HIT_EFFECT_DURATION;
            showGamePopup(`명중! 💥`, 800, { backgroundColor: `rgba(255, 100, 80, 0.7)` });
            gb_spawnPlayerAttackWord();
            if (gb_enemyHealth <= 0) {
                gb_enemyHealth = 0;
                handleGameEnd(true, "hp");
            }
        }
        function gb_playerDefend(rock) {
            const index = gb_enemyAttacks.indexOf(rock);
            if (index > -1) {
                gb_enemyAttacks.splice(index, 1);
                showGamePopup("방어! 🛡️", 800, { backgroundColor: `rgba(80, 200, 120, 0.7)` });
            }
        }

        // ---------------------------------------------------
        // ▼▼▼▼▼ 단축키 헬퍼 함수 ▼▼▼▼▼
        // ---------------------------------------------------
        function restartCurrentPractice() {
            if (currentMode === 'freestyle' || currentMode === 'game') return;

            typingInputField.value = '';
            currentDisplayLineIndex = 0;
            currentLineStartTime = null;
            disassembledLine = Hangul.disassemble(linesToPractice[0] || '');

            if (currentMode.endsWith('Long')) {
                startTime = null;
                currentArticleCorrectChars = 0;
            }
            
            renderTypingLayout();
            updateProgressBar();
            updateFakeInput('', true);
            updateKeyboardHighlight();
            if(resultEl) resultEl.textContent = '다시 시작!';
            setTimeout(() => typingInputField.focus(), 50);
        }

        function changeGameLevel(direction) { // direction: 1 for next, -1 for previous
            if (currentMode !== 'game' || !currentGameType) return;
            
            const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');
            if (!gameLevelSelectEl) return;

            let maxLevel = 1;
            if (currentGameType === 'rainfall') maxLevel = rainfall_gameMainLevelsConfig.length;
            else if (currentGameType === 'letterBlockBattle') maxLevel = LBB_MAX_LEVEL;
            else if (currentGameType === 'giantBattle') maxLevel = GB_MAX_LEVEL;

            let currentLevel = parseInt(gameLevelSelectEl.value);
            let newLevel = currentLevel + direction;

            newLevel = Math.max(1, Math.min(newLevel, maxLevel));

            if (newLevel !== currentLevel) {
                const levelVarName = {
                    rainfall: 'rainfall_gameLevel',
                    letterBlockBattle: 'lbb_gameLevel',
                    giantBattle: 'gb_currentLevel'
                }[currentGameType];

                window[levelVarName] = newLevel;
                updateDropdown(newLevel);
                
                handleGameEnd(false, 'level_change'); 
            }
        }
        function changeLongText(direction) { // direction: 1 for next, -1 for previous
            if (!currentMode.endsWith('Long') || !longTextSelectEl) return;

            const options = Array.from(longTextSelectEl.options);
            let currentIndex = longTextSelectEl.selectedIndex;

            if (currentIndex <= 0) {
                currentIndex = 1;
            }

            let nextIndex = currentIndex + direction;

            if (nextIndex >= options.length) {
                nextIndex = 1;
            } else if (nextIndex < 1) {
                nextIndex = options.length - 1;
            }

            longTextSelectEl.value = options[nextIndex].value;
            startPractice(currentMode, false);
        }
        // ---------------------------------------------------
        // ▼▼▼▼▼ 게임 종료 처리 함수 ▼▼▼▼▼
        // ---------------------------------------------------
        function handleGameEnd(playerWins, reason) {
            let isActive;
            switch (currentGameType) {
                case 'rainfall': isActive = rainfall_isGameActive; rainfall_isGameActive = false; break;
                case 'letterBlockBattle': isActive = lbb_isGameActive; lbb_isGameActive = false; break;
                case 'giantBattle': isActive = gb_isGameActive; gb_isGameActive = false; break;
                default: return;
            }
            if (!isActive && reason !== 'level_change') return;

            if (currentGameType === 'rainfall') {
                if (rainfall_gameLoopId) cancelAnimationFrame(rainfall_gameLoopId);
                if (rainfall_wordGenerationIntervalId) clearInterval(rainfall_wordGenerationIntervalId);
                rainfall_gameLoopId = null;
                rainfall_wordGenerationIntervalId = null;
            } else if (currentGameType === 'letterBlockBattle') {
                if (lbb_gameLoopId) cancelAnimationFrame(lbb_gameLoopId);
                if (lbb_enemyActionIntervalId) clearInterval(lbb_enemyActionIntervalId);
                lbb_gameLoopId = null;
                lbb_enemyActionIntervalId = null;
            } else if (currentGameType === 'giantBattle') {
                if (gb_gameLoopId) cancelAnimationFrame(gb_gameLoopId);
                if (gb_enemyAttackIntervalId) cancelAnimationFrame(gb_enemyAttackIntervalId);
                gb_gameLoopId = null;
                gb_enemyAttackIntervalId = null;
            }

            if(gameInputField) gameInputField.disabled = true;

            let gameConfig, currentLevel, resultData;
            window.gameResultData = null;
            const gameLevelSelectEl = document.getElementById('gameLevelSelectInBar');

            if (currentGameType === 'rainfall') {
                gameConfig = { name: '소나기', maxLevel: rainfall_gameMainLevelsConfig.length, initFunc: initRainfallGame, levelVarName: 'rainfall_gameLevel' };
                currentLevel = rainfall_gameLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 클리어!` : '게임 오버', gameName: '소나기', stats: { '레벨': currentLevel, '점수': rainfall_gameScore } };
            } else if (currentGameType === 'letterBlockBattle') {
                gameConfig = { name: '블록 배틀', maxLevel: LBB_MAX_LEVEL, initFunc: initLetterBlockBattleGame, levelVarName: 'lbb_gameLevel' };
                currentLevel = lbb_gameLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '블록 배틀', stats: { '레벨': currentLevel, '내 점수': lbb_playerScore, '적 점수': lbb_enemyScore } };
            } else if (currentGameType === 'giantBattle') {
                gameConfig = { name: '타이핑 배틀', maxLevel: GB_MAX_LEVEL, initFunc: initGiantBattleGame, levelVarName: 'gb_currentLevel' };
                currentLevel = gb_currentLevel;
                resultData = { type: 'game', title: playerWins ? `레벨 ${currentLevel} 승리!` : '패배', gameName: '타이핑 배틀', stats: { '레벨': currentLevel, '남은 HP': Math.round(gb_playerHealth) } };
            } else {
                return;
            }

            const selectedLevelInDropdown = gameLevelSelectEl ? parseInt(gameLevelSelectEl.value) : currentLevel;

            if (reason === 'level_change') {
                showCountdownThenStart(gameConfig.initFunc, [true, selectedLevelInDropdown]);
                return;
            }
            
            let nextActionText = '';
            if (playerWins && currentLevel < gameConfig.maxLevel) {
                nextActionText = `다음 레벨 (${currentLevel + 1}) (Enter)`;
                resultData.nextAction = () => {
                    const nextLevel = currentLevel + 1;
                    window[gameConfig.levelVarName] = nextLevel;
                    updateDropdown(nextLevel);
                    showCountdownThenStart(gameConfig.initFunc, [true, nextLevel]);
                };
            } else if (playerWins) {
                resultData.title = `🏆 모든 레벨 클리어!`;
                nextActionText = "처음부터 다시하기 (Enter)";
                resultData.nextAction = () => {
                     window[gameConfig.levelVarName] = 1;
                     updateDropdown(1);
                     showCountdownThenStart(gameConfig.initFunc, [true, 1]);
                };
            } else {
                if(reason === 'timeUp' && ((currentGameType === 'letterBlockBattle' && lbb_playerScore > lbb_enemyScore) || (currentGameType === 'giantBattle' && gb_playerHealth > 0))) {
                     resultData.title = `시간 종료 (판정승)`;
                }
                nextActionText = "다시 도전 (Enter)";
                resultData.nextAction = () => {
                    const levelToRetry = selectedLevelInDropdown;
                    window[gameConfig.levelVarName] = levelToRetry;
                    updateDropdown(levelToRetry);
                    showCountdownThenStart(gameConfig.initFunc, [true, levelToRetry]);
                };
            }
            resultData.nextActionText = nextActionText;
            
            window.gameResultData = resultData;
            showResultOverlay(resultData);
        }
        function showCountdownThenStart(startGameFunction, args = [true, 1]) {
            if (countdownTimerId) {
                clearTimeout(countdownTimerId);
                countdownTimerId = null;
            }

            if(gameStartMessageEl) gameStartMessageEl.style.display = 'none';
            if(gameOverlayEl) gameOverlayEl.classList.remove('visible');

            let count = 3;
            const countdown = () => {
                const drawFunc = window[`draw${currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1)}Game`];
                if (drawFunc) drawFunc(); 
                
                if (count > 0) {
                    gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
                    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    gameCtx.font = "bold 80px 'Poppins', sans-serif";
                    gameCtx.fillStyle = 'white';
                    gameCtx.textAlign = 'center';
                    gameCtx.textBaseline = 'middle';
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 10;
                    gameCtx.fillText(count, gameCanvas.width / 2, gameCanvas.height / 2);
                    gameCtx.shadowBlur = 0;
                    count--;
                    countdownTimerId = setTimeout(countdown, 1000);
                } else {
                    gameCtx.fillStyle = 'rgba(0,0,0,0.5)';
                    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    gameCtx.font = "bold 70px 'Poppins', sans-serif";
                    gameCtx.fillStyle = 'white';
                    gameCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    gameCtx.shadowBlur = 10;
                    gameCtx.fillText('START!', gameCanvas.width / 2, gameCanvas.height / 2);
                    gameCtx.shadowBlur = 0;
                    countdownTimerId = setTimeout(() => {
                        countdownTimerId = null;
                        startGameFunction(...args);
                    }, 500);
                }
            };
            countdown();
        }
        function returnToPracticeMode(resetSessionStats = true) {
            cleanupActiveModes();
            const gameInternalControlsBar = document.getElementById('gameInternalControlsBar');
            if (mainControlsEl && originalSoundParent && originalThemeParent && soundSettingsEl && themeSettingsEl && gameInternalControlsBar) {
                if (soundSettingsEl.parentNode && soundSettingsEl.parentNode.classList.contains('game-control-item')) {
                     originalSoundParent.insertBefore(soundSettingsEl, originalSoundNextSibling);
                }
                if (themeSettingsEl.parentNode && themeSettingsEl.parentNode.classList.contains('game-control-item')) {
                    originalThemeParent.insertBefore(themeSettingsEl, originalThemeNextSibling);
                }
            }
            if (gameToggleSoundBtn && gameToggleSoundBtn.parentNode) {
                gameToggleSoundBtn.parentNode.removeChild(gameToggleSoundBtn);
                gameToggleSoundBtn = null;
            }
            if (!statsVisible) {
                statsVisible = true;
                toggleStatsBtn.classList.add('active');
                toggleStatsBtn.innerHTML = '<i class="fas fa-chart-line"></i> 측정 ON';
                statsEl.classList.remove('hidden');
            }
            let lastPracticeMode = 'kor';
            const activePracticeBtn = document.querySelector('.practice-mode-controls button[data-practice-type].active');
            if (activePracticeBtn && languageSelectEl) {
                const type = activePracticeBtn.dataset.practiceType;
                const lang = languageSelectEl.value;
                if(type !== 'freestyle' && type !== 'game'){
                    lastPracticeMode = (type === 'long') ? `${lang}Long` : lang;
                }
            }
            updateKeyboardDisplay();
            updateKeyboardHighlight();
            startPractice(lastPracticeMode, resetSessionStats);
        }
        const charToKeyMap = {
            'ㅂ': 'q', 'ㅈ': 'w', 'ㄷ': 'e', 'ㄱ': 'r', 'ㅅ': 't', 'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅔ': 'p',
            'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l',
            'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
            'ㅃ': 'q', 'ㅉ': 'w', 'ㄸ': 'e', 'ㄲ': 'r', 'ㅆ': 't', 'ㅒ': 'o', 'ㅖ': 'p',
            '[': '[', ']': ']', ';': ';', "'": "'", ',': ',', '.': '.', '/': '/', ' ': 'space',
            '{': '[', '}': ']', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/',
            '`': 'backquote', '~': 'backquote', '!': '1', '@': '2', '#': '3', '$': '4', '%': '5',
            '^': '6', '&': '7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '='
        };

        const Hangul = (() => {
            const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
            const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const HANGUL_OFFSET = 0xAC00;

            const disassemble = (str) => {
                return str.split('').map(char => {
                    const code = char.charCodeAt(0);
                    if (code >= HANGUL_OFFSET && code <= 0xD7A3) {
                        const uniValue = code - HANGUL_OFFSET;
                        const jong = uniValue % 28;
                        const jung = Math.floor((uniValue - jong) / 28) % 21;
                        const cho = Math.floor(uniValue / (21 * 28));
                        
                        const result = [CHO[cho]];
                        const jungJamo = JUNG[jung];
                        switch(jungJamo) {
                            case 'ㅘ': result.push('ㅗ', 'ㅏ'); break;
                            case 'ㅙ': result.push('ㅗ', 'ㅐ'); break;
                            case 'ㅚ': result.push('ㅗ', 'ㅣ'); break;
                            case 'ㅝ': result.push('ㅜ', 'ㅓ'); break;
                            case 'ㅞ': result.push('ㅜ', 'ㅔ'); break;
                            case 'ㅟ': result.push('ㅜ', 'ㅣ'); break;
                            case 'ㅢ': result.push('ㅡ', 'ㅣ'); break;
                            default: result.push(jungJamo); break;
                        }
                        
                        if (jong > 0) {
                            const jongJamo = JONG[jong];
                            switch(jongJamo) {
                                case 'ㄳ': result.push('ㄱ', 'ㅅ'); break;
                                case 'ㄵ': result.push('ㄴ', 'ㅈ'); break;
                                case 'ㄶ': result.push('ㄴ', 'ㅎ'); break;
                                case 'ㄺ': result.push('ㄹ', 'ㄱ'); break;
                                case 'ㄻ': result.push('ㄹ', 'ㅁ'); break;
                                case 'ㄼ': result.push('ㄹ', 'ㅂ'); break;
                                case 'ㄽ': result.push('ㄹ', 'ㅅ'); break;
                                case 'ㄾ': result.push('ㄹ', 'ㅌ'); break;
                                case 'ㄿ': result.push('ㄹ', 'ㅍ'); break;
                                case 'ㅀ': result.push('ㄹ', 'ㅎ'); break;
                                case 'ㅄ': result.push('ㅂ', 'ㅅ'); break;
                                default: result.push(jongJamo); break;
                            }
                        }
                        return result;
                    }
                    return [char];
                }).flat();
            };
            return { disassemble };
        })();

        function alignInputField() {
            const currentLineEl = document.getElementById('current-typing-line');
            const fakeInputEl = document.getElementById('fake-input-field');

            if (!currentLineEl || !fakeInputEl) return;

            const lineSpan = currentLineEl.querySelector('span');
            
            // 예문 텍스트가 없으면 기본 패딩으로 리셋
            if (!lineSpan || lineSpan.textContent.trim() === '') {
                fakeInputEl.style.paddingLeft = '16px'; // CSS에 정의된 기본값
                return;
            }

            const lineRect = lineSpan.getBoundingClientRect();
            const inputContainerRect = fakeInputEl.getBoundingClientRect();
            
            // 예문 시작 X좌표와 입력창 컨테이너 시작 X좌표의 차이를 계산
            const requiredPadding = lineRect.x - inputContainerRect.x;
            
            // 계산된 패딩 적용 (음수 방지)
            if (requiredPadding >= 0) {
                fakeInputEl.style.paddingLeft = `${requiredPadding}px`;
            }
        }

        function buildKeyboard() {
            if (!keyboardGuideEl) return;
            keyboardGuideEl.innerHTML = '';
            
            const layout = [
                ['`','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
                ['Tab','q','w','e','r','t','y','u','i','o','p','[',']','\\'],
                ['CapsLock','a','s','d','f','g','h','j','k','l',';',"'",'Enter'],
                ['ShiftLeft','z','x','c','v','b','n','m',',','.','/','ShiftRight'],
                ['ControlLeft', 'AltLeft', 'Space', 'AltRight', 'ControlRight']
            ];

            const keyInfo = {
                '`': { base: '`', shift: '~' }, '1': { base: '1', shift: '!' },
                '2': { base: '2', shift: '@' }, '3': { base: '3', shift: '#' },
                '4': { base: '4', shift: '$' }, '5': { base: '5', shift: '%' },
                '6': { base: '6', shift: '^' }, '7': { base: '7', shift: '&' },
                '8': { base: '8', shift: '*' }, '9': { base: '9', shift: '(' },
                '0': { base: '0', shift: ')' }, '-': { base: '-', shift: '_' },
                '=': { base: '=', shift: '+' },

                'q': { eng: 'Q', kor: 'ㅂ', shiftKor: 'ㅃ' }, 'w': { eng: 'W', kor: 'ㅈ', shiftKor: 'ㅉ' },
                'e': { eng: 'E', kor: 'ㄷ', shiftKor: 'ㄸ' }, 'r': { eng: 'R', kor: 'ㄱ', shiftKor: 'ㄲ' },
                't': { eng: 'T', kor: 'ㅅ', shiftKor: 'ㅆ' }, 'y': { eng: 'Y', kor: 'ㅛ' }, 'u': { eng: 'U', kor: 'ㅕ' },
                'i': { eng: 'I', kor: 'ㅑ' }, 'o': { eng: 'O', kor: 'ㅐ', shiftKor: 'ㅒ' }, 'p': { eng: 'P', kor: 'ㅔ', shiftKor: 'ㅖ' },
                '[': { base: '[', shift: '{' }, ']': { base: ']', shift: '}' }, '\\': { base: '\\', shift: '|' },
                
                'a': { eng: 'A', kor: 'ㅁ' }, 's': { eng: 'S', kor: 'ㄴ' }, 'd': { eng: 'D', kor: 'ㅇ' },
                'f': { eng: 'F', kor: 'ㄹ' }, 'g': { eng: 'G', kor: 'ㅎ' }, 'h': { eng: 'H', kor: 'ㅗ' },
                'j': { eng: 'J', kor: 'ㅓ' }, 'k': { eng: 'K', kor: 'ㅏ' }, 'l': { eng: 'L', kor: 'ㅣ' },
                ';': { base: ';', shift: ':' }, "'": { base: "'", shift: '"' },

                'z': { eng: 'Z', kor: 'ㅋ' }, 'x': { eng: 'X', kor: 'ㅌ' }, 'c': { eng: 'C', kor: 'ㅊ' },
                'v': { eng: 'V', kor: 'ㅍ' }, 'b': { eng: 'B', kor: 'ㅠ' }, 'n': { eng: 'N', kor: 'ㅜ' }, 'm': { eng: 'M', kor: 'ㅡ' },
                ',': { base: ',', shift: '<' }, '.': { base: '.', shift: '>' }, '/': { base: '/', shift: '?' }
            };

            layout.forEach((row, index) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = `keyboard-row row-${index + 1}`;
                
                const keysWrapper = document.createElement('div');
                keysWrapper.className = 'keys-wrapper';

                row.forEach(keyId => {
                    const keyDiv = document.createElement('div');
                    let dataKey = keyId.toLowerCase().replace('left', '').replace('right', '');
                    if(dataKey === '`') dataKey = 'backquote';
                    keyDiv.dataset.key = dataKey;
                    keyDiv.classList.add('keyboard-key');

                    const data = keyInfo[keyId.toLowerCase()];
                    if (data) {
                        const mainChar = data.eng ? data.eng.toLowerCase() : data.base;
                        const shiftChar = data.eng ? data.eng.toUpperCase() : data.shift;
                        const korMain = data.kor || data.base || '';
                        const korShift = data.shiftKor || data.shift || '';
                        
                        keyDiv.innerHTML = `
                            <div class="key-eng">
                                <span class="key-shift-char">${shiftChar}</span>
                                <span class="key-main-char">${mainChar}</span>
                            </div>
                            <div class="key-kor">
                                <span class="key-shift-char">${korShift}</span>
                                <span class="key-main-char">${korMain}</span>
                            </div>
                        `;
                    } else {
                         keyDiv.classList.add('special-key');
                         keyDiv.textContent = keyId.replace(/Left|Right/, '');
                    }

                    if (['a', 's', 'd', 'f', 'j', 'k', 'l', ';'].includes(keyId.toLowerCase())) {
                        keyDiv.classList.add('home-row-base');
                    }

                    const keyWidths = {
                        backspace: '2x', tab: '1.5x', capslock: '1.75x', enter: '2.25x',
                        shiftleft: '2.5x', shiftright: '2.5x', space: 'space'
                    };
                    if(keyWidths[keyId.toLowerCase()]) {
                        keyDiv.classList.add(`key-width-${keyWidths[keyId.toLowerCase()]}`);
                    }

                    keysWrapper.appendChild(keyDiv);
                });
                rowDiv.appendChild(keysWrapper);
                keyboardGuideEl.appendChild(rowDiv);
            });
        }

        function updateKeyboardDisplay() {
            if (!keyboardGuideEl) return;
            
            const lang = currentMode.replace('Long', '');
            
            keyboardGuideEl.className = 'keyboard-guide';
            if (keyboardGuideEnabled) {
                keyboardGuideEl.classList.add('visible');
            }
            keyboardGuideEl.classList.add(`lang-${lang}`);
        }

        function clearKeyboardHighlight() {
            if (!keyboardGuideEl) return;
            const highlightedKeys = keyboardGuideEl.querySelectorAll('.highlight-key');
            highlightedKeys.forEach(key => key.classList.remove('highlight-key'));
        }

        // ▼▼▼ 아래의 최종 수정된 updateKeyboardHighlight 함수를 붙여넣으세요 ▼▼▼

function updateKeyboardHighlight() {
    if (!keyboardGuideEnabled || !keyboardGuideEl || currentMode === 'game' || currentMode === 'freestyle') {
        clearKeyboardHighlight();
        return;
    }

    clearKeyboardHighlight();

    const disassembledTyped = Hangul.disassemble(typingInputField.value);
    let nextCharIndex = disassembledTyped.length;

    // [핵심 수정] 자동 완성이 켜져 있을 때 특수문자를 건너뛰는 로직
    if (autoCompleteEnabled) {
        while (
            nextCharIndex < disassembledLine.length &&
            isSpecialCharacter(disassembledLine[nextCharIndex])
        ) {
            // 다음 글자가 특수문자이면, 인덱스를 1 증가시켜 건너뜁니다.
            nextCharIndex++;
        }
    }

    // 모든 추천 과정을 건너뛰고 문장의 끝에 도달했다면, 함수를 종료합니다.
    if (nextCharIndex >= disassembledLine.length) {
        return;
    }

    const nextCharToPress = disassembledLine[nextCharIndex];
    if (!nextCharToPress) return;

    const shiftKeyMap = {
        '~':'`', '!':'1', '@':'2', '#':'3', '$':'4', '%':'5', '^':'6', '&':'7', '*': '8', '(': '9', ')': '0', '_': '-', '+': '=',
        '{': '[', '}': ']', '|': '\\', ':': ';', '"': "'", '<': ',', '>': '.', '?': '/'
    };
    
    let keyId;
    let isShiftNeeded = false;

    // 한글 쌍자음/쌍모음 처리
    const isKorMode = currentMode.startsWith('kor');
    if (isKorMode && 'ㅃㅉㄸㄲㅆㅒㅖ'.includes(nextCharToPress)) {
        isShiftNeeded = true;
        keyId = charToKeyMap[nextCharToPress];
    } 
    // 영어 대문자 처리
    else if (nextCharToPress >= 'A' && nextCharToPress <= 'Z') {
        isShiftNeeded = true;
        keyId = nextCharToPress.toLowerCase();
    } 
    // 나머지 쉬프트 필요한 특수문자 처리
    else if (shiftKeyMap[nextCharToPress]) {
        isShiftNeeded = true;
        keyId = shiftKeyMap[nextCharToPress];
    } 
    // 일반 문자 처리
    else {
        keyId = charToKeyMap[nextCharToPress] || nextCharToPress.toLowerCase();
    }
    
    if(keyId === '`') keyId = 'backquote';

    if (keyId) {
        const keyElements = keyboardGuideEl.querySelectorAll(`.keyboard-key[data-key="${keyId}"]`);
        keyElements.forEach(el => el.classList.add('highlight-key'));
    }
    
    if (isShiftNeeded) {
        const shiftKeys = keyboardGuideEl.querySelectorAll('.keyboard-key[data-key="shift"]');
        shiftKeys.forEach(key => key.classList.add('highlight-key'));
    }
}

        // === HELP MODAL FUNCTIONS ===
        function getHelpContent(gameType) {
            const contents = {
                rainfall: {
                    title: '<i class="fas fa-cloud-showers-heavy"></i> 소나기 게임 방법',
                    body: `<p>하늘에서 떨어지는 단어들을 사라지기 전에 입력하여 점수를 획득하는 게임입니다.</p>
                           <p>단어가 바닥에 닿으면 생명이 1 감소하며, 생명을 모두 잃으면 게임이 종료됩니다.</p>
                           <div class="item-info">
                                <div><strong>아이템 종류:</strong></div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.EXTRA_LIFE};"></span> ${RAINFALL_ITEM_TYPES.EXTRA_LIFE.text}: 생명이 1 증가합니다.</div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.TIME_STOP};"></span> ${RAINFALL_ITEM_TYPES.TIME_STOP.text}: 3초 동안 모든 단어의 움직임이 멈춥니다.</div>
                                <div><span style="background-color:${RAINFALL_ITEM_COLORS.CLEAR_SCREEN};"></span> ${RAINFALL_ITEM_TYPES.CLEAR_SCREEN.text}: 화면의 모든 일반 단어를 제거하고 점수를 얻습니다.</div>
                           </div>`
                },
                letterBlockBattle: {
                    title: '<i class="fas fa-th-large"></i> 블록 배틀 게임 방법',
                    body: `<p>상하좌우에 인접한 블록의 단어를 입력하여 이동하고 점수를 얻습니다. 블록을 부숴 적과 나의 캐릭터가 빈 칸으로 연결되면 전투가 일어나며, 점수가 높은 쪽이 승리합니다.</p>
                           <p>2분 안에 승부가 나지 않으면 점수가 더 높은 쪽이 판정승합니다.</p>
                           <div class="item-info">
                                <div><strong>특수 블록:</strong></div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.YELLOW.color};">${LBB_BLOCK_EFFECT_TYPES.YELLOW.icon}</span> 노랑 블록: 2점</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.RED.color};">${LBB_BLOCK_EFFECT_TYPES.RED.icon}</span> 빨강 블록: 3점</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.BLUE.color};">${LBB_BLOCK_EFFECT_TYPES.BLUE.icon}</span> 파랑 블록: 적을 2초간 얼립니다.</div>
                                <div><span class="item-icon" style="color:${LBB_BLOCK_EFFECT_TYPES.GREEN.color};">${LBB_BLOCK_EFFECT_TYPES.GREEN.icon}</span> 초록 블록: 적과 나의 위치를 바꿉니다.</div>
                           </div>`
                },
                giantBattle: {
                    title: '<i class="fas fa-fist-raised"></i> 타이핑 배틀 게임 방법',
                    body: `<p>화면 하단의 공격 단어를 입력하여 적을 공격하고, 위에서 내려오는 적의 공격 단어를 입력하여 방어하세요.</p>
                           <p>2분 내에 적의 HP를 0으로 만들거나, 시간이 종료됐을 때 나의 HP가 더 많으면 승리합니다.</p>`
                }
            };
            return contents[gameType] || { title: '도움말', body: '게임 정보를 찾을 수 없습니다.' };
        }

        function showHelpModal(gameType) {
            const content = getHelpContent(gameType);
            if (helpModalBody) helpModalBody.innerHTML = `<h2>${content.title}</h2>${content.body}`;
            if (helpModal) helpModal.classList.add('visible');
            
            if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = true;
            else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = true;
            else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = true;
        }

        function hideHelpModal() {
            if (helpModal) helpModal.classList.remove('visible');

            if (currentGameType === 'rainfall') rainfall_gamePausedForOverlay = false;
            else if (currentGameType === 'letterBlockBattle') lbb_gamePausedForOverlay = false;
            else if (currentGameType === 'giantBattle') gb_gamePausedForOverlay = false;
        }
        async function shareResult() {
            if (!window.gameResultData) {
                showSharePopup('공유할 결과 데이터가 없습니다.');
                return;
            }

            const resultData = window.gameResultData;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const width = 500;
            const height = 280;
            const padding = 30;
            const borderRadius = 12;

            canvas.width = width;
            canvas.height = height;

            const theme = document.body.classList.contains('light-theme') ? 'light' : (document.body.classList.contains('pink-theme') ? 'pink' : 'dark');
            
            const colors = {
                dark: { bg: '#2a2826', text: '#e8e0d8', accent: '#d4af7a', secondary: '#b2aca2' },
                light: { bg: '#fff', text: '#524a42', accent: '#b89a6c', secondary: '#756A5F' },
                pink: { bg: '#ffffff', text: '#4F333D', accent: '#E85D75', secondary: '#735A64' }
            };
            const currentTheme = colors[theme];
            
            ctx.fillStyle = currentTheme.bg;
            ctx.beginPath();
            ctx.moveTo(borderRadius, 0);
            ctx.lineTo(width - borderRadius, 0);
            ctx.quadraticCurveTo(width, 0, width, borderRadius);
            ctx.lineTo(width, height - borderRadius);
            ctx.quadraticCurveTo(width, height, width - borderRadius, height);
            ctx.lineTo(borderRadius, height);
            ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
            ctx.lineTo(0, borderRadius);
            ctx.quadraticCurveTo(0, 0, borderRadius, 0);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = currentTheme.accent;
            ctx.font = "bold 36px 'Playfair Display', serif";
            ctx.textAlign = 'center';
            ctx.fillText(resultData.title, width / 2, padding + 40);
            
            ctx.font = "500 18px 'Poppins', sans-serif";
            const stats = Object.entries(resultData.stats);
            const statY = 130;
            const statXMargin = width / (stats.length + 1);

            stats.forEach(([key, value], index) => {
                const x = statXMargin * (index + 1);
                ctx.fillStyle = currentTheme.secondary;
                ctx.fillText(key + ':', x, statY);
                ctx.fillStyle = currentTheme.text;
                ctx.fillText(value, x, statY + 28);
            });

            canvas.toBlob(async (blob) => {
                if (!blob) return;
                
                const file = new File([blob], 'keytherapy-result.png', { type: 'image/png' });
                const shareTitle = 'Key Therapy 게임 결과';
                const shareText = `🎉 ${resultData.title} 🎉\n\n지금 바로 Key Therapy에서 타자 실력을 확인해보세요!`;
                const shareUrl = 'https://keytherapy.vercel.app';

                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    try {
                        await navigator.share({
                            files: [file],
                            title: shareTitle,
                            text: shareText,
                            url: shareUrl,
                        });
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.error('Web Share API 공유 실패:', error);
                            showSharePopup('결과 공유에 실패했습니다.');
                        }
                    }
                } else {
                    try {
                        const clipboardItem = new ClipboardItem({
                            'image/png': blob,
                            'text/plain': new Blob([`${shareTitle}\n${shareText}\n${shareUrl}`], { type: 'text/plain' })
                        });
                        await navigator.clipboard.write([clipboardItem]);
                        showSharePopup('결과 이미지와 링크가 복사되었습니다!');
                    } catch (error) {
                        console.error('클립보드 복사 실패:', error);
                        showSharePopup('결과 공유에 실패했습니다.');
                    }
                }
            }, 'image/png');
        }

        function showResultOverlay(resultData) {
            if (!gameOverlayEl) return;

            let statsHtml = '';
            for (const [key, value] of Object.entries(resultData.stats)) {
                statsHtml += `<div class="stat-item"><span class="label">${key}:</span><span class="value">${value}</span></div>`;
            }

            const shareButtonHtml = `<button id="shareResultBtn" class="game-button secondary"><i class="fas fa-share-alt"></i> 결과 공유하기</button>`;

            gameOverlayEl.innerHTML = `
                <div class="result-card">
                    <h2>${resultData.title}</h2>
                    <div class="result-card-stats">${statsHtml}</div>
                    <div class="result-buttons">
                        <button id="nextStepBtnOverlay" class="game-button">${resultData.nextActionText}</button>
                        ${shareButtonHtml}
                    </div>
                </div>`;

            setTimeout(() => {
                gameOverlayEl.classList.add('visible');
            }, 100);

            const nextBtn = document.getElementById('nextStepBtnOverlay');
            const shareBtn = document.getElementById('shareResultBtn');
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    gameOverlayEl.classList.remove('visible');
                    resultData.nextAction();
                });
            }

            if (shareBtn) {
                shareBtn.addEventListener('click', shareResult);
            }
        }
        function updateLayout() {
            if (!toggleLayoutBtn) return;

            document.body.classList.toggle('layout-collapsed', layoutCollapsed);
            if (layoutCollapsed) {
                toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-down"></i> 메뉴 펼치기(Esc)';
            } else {
                toggleLayoutBtn.innerHTML = '<i class="fas fa-chevron-up"></i> 메뉴 숨기기(Esc)';
            }
        }

        function applyTheme(theme) {
            document.body.classList.remove('light-theme', 'pink-theme');
            if (theme === 'light') document.body.classList.add('light-theme');
            else if (theme === 'pink') document.body.classList.add('pink-theme');

            if (gameCanvas && currentGameType) {
                requestAnimationFrame(() => {
                    if (currentGameType === 'rainfall') drawRainfallGame();
                    else if (currentGameType === 'letterBlockBattle') drawLetterBlockBattleGame();
                    else if (currentGameType === 'giantBattle') drawGiantBattleGame();
                });
            }
        }
</script>
</body>
</html>
